{"meta":{"title":"lmzqm","subtitle":"iOS 开发者","description":"just do it","author":"lmzqm","url":"http://yoursite.com"},"pages":[{"title":"iOS","date":"2018-04-02T01:49:22.000Z","updated":"2018-04-02T01:49:22.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"适配器模式","slug":"design-adapter-pattern","date":"2018-05-21T10:06:57.000Z","updated":"2018-05-22T01:52:46.000Z","comments":true,"path":"2018/05/21/design-adapter-pattern/","link":"","permalink":"http://yoursite.com/2018/05/21/design-adapter-pattern/","excerpt":"摘要： 适配器的使用大家应该比较熟悉了吧！加入我们去欧洲旅游的时候，在我们的国内使用的电器，可能不一定能在欧洲国家使用（国内是220V，国外是110V）这时候需要用到适配器，有了适配器可以确保你在110V的时候也能够正常使用电器。简而言之就是我们要使用某个方法，但是我们无法实现，或者说有一个类已经实现了该方法，那我们就可以采用适配的方法来完成，当然还有很多例子可以满足这个需求。\b","text":"摘要： 适配器的使用大家应该比较熟悉了吧！加入我们去欧洲旅游的时候，在我们的国内使用的电器，可能不一定能在欧洲国家使用（国内是220V，国外是110V）这时候需要用到适配器，有了适配器可以确保你在110V的时候也能够正常使用电器。简而言之就是我们要使用某个方法，但是我们无法实现，或者说有一个类已经实现了该方法，那我们就可以采用适配的方法来完成，当然还有很多例子可以满足这个需求。\b 模式动机 在软件开发中采用类似于电源适配器的设计和编码技巧称为适配器模式； 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时候，现有的类可以满足客户的功能需求，但是他所提供的接口不一定是客户所期望的，这可能是因为现有的类中方法名与目标类中的方法名不一致所导致的； 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用，如果不进行这样转化，客户端就不能利用现有类的功能，适配器模式可以完成这样的转化 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器（Adapter） ,它所包装的对象\b就是适配者 也就是被适配的类 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用，也就是说：当客户类调用适配器的方法的时候，适配类中将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类，因此，适配器可以使用由接口不兼容而不能交互的类可以一起工作 模式定义 适配器模式：将一个接口转换成为客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名是包装器。适配器模式可以作为类结构模式，也可以作为对象\b结构模式。 模式\b结构 适配器模式包含如下角色： * target :目标抽象类 * Adapter ： 适配器类 * Adaptee ：适配者类 * Client : 客户端 适配器分为对象适配器和类适配器 对象适配器： 类适配器： 时序图 代码分析通过UML图和时序图我们可以大体猜测出代码的逻辑 类之间的关系：Traget 和 Adapter 是继承的关系 Adapter 和 Adaptee 是关联的关系（聚合和组合也是一种关联的关系） Target123456@interface target ：NSObject-(void)request;@end 适配者12345@interface \bAdaptee : NSObject-(void)specificRequest;@end 适配器1234567891011121314151617181920212223@interface Adapter : target@property (nonatomic ,strong) Adaptee *adaptee;@end// 适配器的实现@implementation Adapter-(instancetype)initWithAdaptee:(Adaptee *)adaptee&#123; self = [super init]; if (self) &#123; self.adaptee = adaptee; &#125; return self;&#125; -(void)request&#123; [self.adaptee specificRequest]; &#125;@end 使用123Adaptee *adaptee = [Adaptee new];Adapter *adapter = [Adapter initWithAdaptee:adaptee];[adapter request];","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"单例模式","slug":"design-sigleton-pattern","date":"2018-05-21T09:33:22.000Z","updated":"2018-05-22T01:52:44.000Z","comments":true,"path":"2018/05/21/design-sigleton-pattern/","link":"","permalink":"http://yoursite.com/2018/05/21/design-sigleton-pattern/","excerpt":"摘要： 对于系统中的某些类来说，只有一个实例是很重要的。该实例可以很好的对数据进行管理和控制。同时也能够更好的控制显示和隐藏的操作等等。那如何才能保证一个类只有一个实例呢？并且比较重要的是，这个实例\b还比较容易访问到，定义一个全局的变量，\b可以确保对象随时都可以被访问，但是不能防止我们实例化多个对象。\b一个更好的办法就是让类自身负责保存它的唯一实例，这个类可以保证\b没有其他实例被创建，并且他可以提供一个方法该实例的方法。这就是单例模式。","text":"摘要： 对于系统中的某些类来说，只有一个实例是很重要的。该实例可以很好的对数据进行管理和控制。同时也能够更好的控制显示和隐藏的操作等等。那如何才能保证一个类只有一个实例呢？并且比较重要的是，这个实例\b还比较容易访问到，定义一个全局的变量，\b可以确保对象随时都可以被访问，但是不能防止我们实例化多个对象。\b一个更好的办法就是让类自身负责保存它的唯一实例，这个类可以保证\b没有其他实例被创建，并且他可以提供一个方法该实例的方法。这就是单例模式。 定义 单例模式： 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类，它提供全局访问的方法。 单例模式有三个要点： 某个类只有一个实例 它必须是自行创建这个实例 必须向整个\b系统提供这个实例 结构 从上图中可以看出：首先必须包含一个自身的变量 123456789101112131415161718192021222324+(Singleton *)getInstance()&#123; if (instance == null)&#123; instance = [[Singleton alloc] init]; &#125; return instance;&#125;+(void)operation&#123; NSLog(@&quot; singleton operation&quot;); // 这样操作就进一步的\b保证只有一个实例的产生了 [[Singleton getInstance] addOperation];&#125;-(void)addOperation&#123;&#125;---------操作-------[[Singleton getInstance] addOperation]; 模式分析单例模式的目的是保证一个类\b仅有一个实例，并提供一个访问它的全局访问点。单例模式包含角色只有一个，就是单例类 Singleton 。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它，除此之外，该模式还\b包含一个静态私有成员变量与静态\b公有\b的工厂方法，该工厂方法\b负责检验实例的存在性病实例化自己，然后存在在静态成员的变量中，以确保一个实例被创建。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"iOS 延时操作","slug":"ios-time-delay-method","date":"2018-05-16T07:40:46.000Z","updated":"2018-05-18T01:02:45.000Z","comments":true,"path":"2018/05/16/ios-time-delay-method/","link":"","permalink":"http://yoursite.com/2018/05/16/ios-time-delay-method/","excerpt":"摘要： 在开发的过程中很多时候我们需要用到延时的操作，或者说定时执行\b某些任务，当然我们可能在主线程执行，也可能是在子线程中执行，有些\b延时操作可以\b重复执行，可不可以取消执行等等。所以这里我们就需要定义一些适合我们的延时方法来执行相对应的操作。","text":"摘要： 在开发的过程中很多时候我们需要用到延时的操作，或者说定时执行\b某些任务，当然我们可能在主线程执行，也可能是在子线程中执行，有些\b延时操作可以\b重复执行，可不可以取消执行等等。所以这里我们就需要定义一些适合我们的延时方法来执行相对应的操作。 NSTimer特点： 可以在主线程和子线程中执行 但是方法有所不同 可以取消 可以马上执行 而且可以重复执行 主线程执行1NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timeAction) userInfo:nil repeats:YES]; 子线程执行在子线程中执行\b，需要runloop的配合才能使用123NSTimer *timer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(timeAction) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];[[NSRunLoop currentRunLoop] run]; 取消1[timer invalidate]; 后台执行采用的是后台播放音频操作的方式，首先要满足1234//开启后台处理多媒体事件 [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; AVAudioSession *session=[AVAudioSession sharedInstance]; [session setActive:YES error:nil]; 然后在进入后台的时候，要定义个taskID 1234567891011121314151617181920UIApplication* app = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier bgTask; bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;]; dispatch_async(dispatch_get_main_queue(), ^&#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;); PerformSelector这是针对NSObject的一个类别，所以\b对象都可以使用该方法； 特点是：该方法只能在主线程中执行，可以传递参数\b，也可以取消 但问题是不可以暂停 而且也不存在重复的操作 ·@interface NSObject (NSDelayedPerforming)· 创建的操作123- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay; 取消的操作12+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; GCD特点： 可以在子线程和主线程执行 不可暂停 不同意取消12345678// 主线程执行dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; &#125;); // 子线程执行 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)),dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),^&#123; &#125;); NSThread特点：阻塞线程 （最好不要放在主线程执行） 1[NSThread sleepForTimeInterval:15]; 感谢iOS延迟操作，看这个就行了 NSTimer使用注意点 iOS NSTimer定时器详解 定时器nstimer 详解","categories":[],"tags":[{"name":"iOS 延时操作","slug":"iOS-延时操作","permalink":"http://yoursite.com/tags/iOS-延时操作/"}]},{"title":"建造者模式","slug":"design-builder-model","date":"2018-05-15T09:02:25.000Z","updated":"2018-05-18T01:06:47.000Z","comments":true,"path":"2018/05/15/design-builder-model/","link":"","permalink":"http://yoursite.com/2018/05/15/design-builder-model/","excerpt":"摘要： 无论是在现实世界中还是在软件系统中，都存在一些比较复杂的对象，他们拥有多个组成部分，如汽车，它包括车轮，方向盘，发动机等各个部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一个完整的汽车，可以通过建造者模式对其进行设计和描述。建造者模式可以将组件和其组装过程分开，一步一步创建一个复杂对象。用户只需要指定复杂对象的类型就可以得到该对象，而\b无须知道其内部的具体的构造细节。","text":"摘要： 无论是在现实世界中还是在软件系统中，都存在一些比较复杂的对象，他们拥有多个组成部分，如汽车，它包括车轮，方向盘，发动机等各个部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一个完整的汽车，可以通过建造者模式对其进行设计和描述。建造者模式可以将组件和其组装过程分开，一步一步创建一个复杂对象。用户只需要指定复杂对象的类型就可以得到该对象，而\b无须知道其内部的具体的构造细节。 需求这里我们将造车的操作引入到我们的需求中这里首先我们需要创建车，这时候我们的建造者可以建造SUV,小轿车，由指挥者来指挥具体生成那种车型 定义建造者模式：将一个复杂对象的构建于它的表示分离，是的同样的构建过程可以创建不同的表示 建造者模式是一步一步创建一个复杂的对象，它允许用户只\b通过指定复杂的对象的类型和内容就可以构建他们，用户不需要指定内部的具体构建细节。建造者模式属于对象创建模式。 模式结构建造者模式\b包含如下角色： Builder:抽象建造者 ConcreteBuilder: 具体建造者 Dierctor: 指挥者 Product: 产品角色 通过上图我们可以分析下类之间的关系： concreteBuilder 与 product是依赖的关系（是属于最弱的一种关系，作为返回值的操作）Director 和 Builder 之间是一个聚合的关系 （\b生命周期不一样,也是一种属性，）当然Builder和ConcreteBuilder 之间是一种实现关系 时序图 代码分析首先：产品 \bProduct (车) Builder :抽象建造者123\bCarBuilder:\b-(void)buildCar; 具体的建造者： CarSuvBuilder: SUV的\b建造者 1234567@property (nonatomic ,strong) Car *carProduct;\b-(void)buildCar&#123; carProduct = [[carProduct alloc] init]; carProduct.name = @&quot;SUV&quot;;&#125; CarMpvBuilder: MPV的建造者 1234567@property (nonatomic ,strong) Car *carProduct;\b-(void)buildCar&#123; carProduct = [[carProduct alloc] init]; carProduct.name = @&quot;MPV&quot;;&#125; 指挥者：1234567CarDirector ：@Property(nonatomic ,strong) CarBuilder builder;-(Car*)createCar&#123; [builder buildCar];&#125; 使用：1234CarDirector *director = [[CarBuilder alloc] init];director.builder = [[CarSuvBuilder alloc] init];[director createCar]; 实例分析 在AFNetworking中我们的request的序列化的操作，就是采用\b建造者模式 角色： 建造者：\bAFURLReqeustSerialization 具体建造者： AFHTTPRequestSerializer AFJSONRequestSerializer 指挥者：AFHTTPSessionManager 产品：\bNSURLReqeust 模式分析建造者模式和抽象工厂模式的比较： 与抽象工厂模式想比，\b建造者模式模式返回的是一个组装好的完整的产品，而抽象工厂模式返回的是一系列相关的产品，这些产品位于不同的产品登记中，构成一个产品族 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需的对象，而建造者模式中客户端可以不直接调用建造者模式的相关方法，而是通过指挥者类来\b指定如何生成对象，包括对象的组装过程和建造过程，它侧重于一步步构造一个复杂对象，返回一个完整的对象 如果将抽象工厂模式看成一个汽车配件生成工厂，生成一个产品簇的产品，那么建造者模式就是一个汽车组装工厂，通过对不见的组装可以返回一个完整的汽车","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"iOS LLDB 调试","slug":"ios-debug-lldb","date":"2018-05-10T08:48:24.000Z","updated":"2018-05-15T03:16:26.000Z","comments":true,"path":"2018/05/10/ios-debug-lldb/","link":"","permalink":"http://yoursite.com/2018/05/10/ios-debug-lldb/","excerpt":"摘要： 在\b平常调试的时候，总是有一些是正常的调试无法满足的地方，比如说要修改参数的某个值，或者说要需要打印一些信息，以及针对界面中需要修改一些参数。正常情况下都是需要将代码修改，然后再重启应用才能开到效果。常规操作……","text":"摘要： 在\b平常调试的时候，总是有一些是正常的调试无法满足的地方，比如说要修改参数的某个值，或者说要需要打印一些信息，以及针对界面中需要修改一些参数。正常情况下都是需要将代码修改，然后再重启应用才能开到效果。常规操作…… LLDB 简介Xcode中内嵌了LLDB控制台，就是我们正常使用NSLog()来打印信息的时候，所显示的地方。但是如果我们想要使用LLDB命令的时候，必须让程序进入暂停状态。 LLDB 语法首先关于LLDB的使用，语法要先有所了解，接下来才能更好的大展拳脚呀！&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;]] &lt;action&gt; [-options [option-value]] [argument] 看上去似乎有点复杂点，但是这里需要明确两个&lt; &gt; 和 [] 符号，一个是必填一个是可填的参数 所有这样就会相对简单了； \\ 和 \\ :LLDB 调试的时候使用的\b命令，命令和子命令是按照层级结构来排列的：一个命令对象会为其指明了对象创建一个上下文 ，子命令还会为其子命令创建上下文 以此类推 \\ 执行命令的操作 \\ 命令的选项 \\ 命令的参数 举个例子： breakpoint set -f HelloWorld.m -n main -l 67 对这个命令解析command :breakpointaction :setoptions: -f -n -largument: HelloWorld.m main 67 原始命令LLDB支持不带命令选项的原始命令，原始命令会将命令后面的所有东西都当做参数来看待。当然原始命令也是可以带参数的的，需要在命令选项后面加–区分命令选项和参数 eg: expr count expr -0 – count 唯一匹配原则LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一\b匹配到某个命令，则只写前n个字母等于写下完整的命令 比如说： breakpoint brexpression expr LLDB 命令help个人认为这是最重要的一个命令啦！明白怎么使用这个，后续的问题就看你自己的了首先可能刚接触\bLLDB 还不知怎么使用最简单的： 假如说你对breakpoint比较有兴趣 想要知道具体怎么用 \b 假如你对breakpoint 中的set 比较关注的话 这样一步一步的下来你就会对这个命令比较熟悉了。当然最主要的是\b你需要对一些常用的命令有所了解，这样扩展起来就会比较快速了。 expression\bexpression 命令的作用是执行一个表达式，并将表达式的结构进行返回输出expression &lt;cmd-options&gt; -- &lt;expr&gt; \\: 命令选项 – 命令选项符结束，表示所有的命令选项已经设置完毕，如果没有命令选项，– 可以省略 \\表示要\b执行的表达式 expression 可以说是LLDB中最重要的命令，主要实现了2个功能 我们可以执行某个表达式，改变程序的运行轨迹。expr self.view.backgroundColor = [UIColor redColor]; // 改变颜色expr (void)[CATransaction flush];// 刷新界面 将返回值输出，可以打印信息 12(lldb) expr self(Class) $0 = _AFURLSessionTaskSwizzling p &amp; Print &amp; call正常情况下，我们直接用expression\b还是比较少的，相对于打印操作的时候，更多的时候我们使用的是p、print、call 这三个命令其实都是expression – 的别名1234Command Options Usage: p &lt;expr&gt;&apos;p&apos; is an abbreviation for &apos;expression --&apos; print 表示打印某个东西，可以是变量和表达式 p 可以看做是print的简写 call 调用\b某个方法 根据\b唯一匹配原则，如果你没有自己\b添加特殊的命令别名。e也可以表示expression的意思，原始命令默认没有命令选项，所以e也能带给你同样的效果 po正常情况下打印出来的对象都是一个指针，而不是我们希望看到的对象的本身，这样的话，我们想要查看对象的一些属性的时候就无法满足我们的需求了，这时候可以使用po这个命令来进行打印一个OC的对象\b 1234567891011Command Options Usage: po &lt;expr&gt;&apos;po&apos; is an abbreviation for &apos;expression -O --&apos;(lldb) po self&lt;AFHTTPSessionManager: 0x16d581e0, baseURL: (null), session: &lt;__NSURLSessionLocal: 0x16d5e620&gt;, operationQueue: &lt;NSOperationQueue: 0x16d582a0&gt;&#123;name = &apos;NSOperationQueue 0x16d582a0&apos;&#125;&gt;(lldb) p self(AFHTTPSessionManager *) $10 = 0x16d581e0(lldb) thread是针对同一进程中一个或\b多个线程的操作的命令\b。 thread backtrace &amp; bt当我们想要了解当前\b线程的堆栈信息的时候，可以使用这个命令将堆栈信息给打印出来1thread backtrace [-c &lt;count&gt;] [-s &lt;frame-index&gt;] [-e &lt;boolean&gt;] thread backtrace 后面跟的\b都是命令选项 -c :设置打印堆栈\b的帧数（frame） -s :设置从哪个帧开始打印 -e :是否显示额外的回溯 123456(lldb) thread backtrace* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 149.1* frame #0: 0x002170d0 GyennoSpoon`-[AFURLSessionManager initWithSessionConfiguration:](self=0x16d581e0, _cmd=&quot;initWithSessionConfiguration:&quot;, configuration=0x16e5ff90) at AFURLSessionManager.m:555frame #1: 0x001f4e40 GyennoSpoon`-[AFHTTPSessionManager initWithBaseURL:sessionConfiguration:](self=0x00000000, _cmd=&quot;initWithBaseURL:sessionConfiguration:&quot;, url=@&quot;http://apptest.gyenno.com/service_im_test/v3/&quot;, configuration=0x16e5ff90) at AFHTTPSessionManager.m:69frame #2: 0x00128f74 GyennoSpoon`+[GYNetworking creatJsonManagerWithUrl:](self=GYNetworking, _cmd=&quot;creatJsonManagerWithUrl:&quot;, url=@&quot;http://apptest.gyenno.com/service_im_test/v3/&quot;) at GYNetworking.m:232frame #3: 0x0012b5ee GyennoSpoon`+[GYNetworking postV4RequestWithURL:paramters:onSuccess:onError:](self=GYNetworking, _cmd=&quot;postV4RequestWithURL:paramters:onSuccess:onError:&quot;, url=@&quot;user/signIn&quot;, paramters=3 key/value pairs, successBlock=0x00196e0d, errorBlock=0x00197811) at GYNetworking.m:421 在这里当我们的程序发生crash的时候，我们可以使用thread backtrace 查看\b堆栈调用可以查看发生错误的对应的行数，这样就可以方便我们跟踪问题当然在使用的时候可以使用bt 来替代thead backtrace 的操作 thread returnDebug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值，这时候就该thread return 了。 1thread return [&lt;expr&gt;] thread return 可以接受一个表达式，调用命令之后直接从当前的frame返回表达式的值 使用方法：只需要在方法的开始的位置上加一个断点，当程序中断的时候，输入命令就可以了 thread return NO效果就相当于在断点位置直接调用return NO ，\b不会执行断点后面的代码 c &amp; n &amp; s &amp; finish在我们调试程序的时候，这些都是比较常用的\b调试操作LLDB也分别针对这些命令使用了不同的快捷键来标识相对应的操作 c/continue/thread continue : 这三个命令效果相等于上图中的第一个按钮，表示程序继续运行 n/next/thread step-over :这三个命令等同于上图中第二个按钮，表示单步运行 s/step/thread step-in :这三个命令效果等同于第三个按钮 ，表示进入某个方法 finish /thread step-out : 这两个命令等同于第四个按钮，表示直接走完当前方法，返回到上一层frame thread 其他不常用的命令thread 相关的还有一些其他不怎么常用的命令， thread jump : 直接让程序跳到某一行，由于ARC编译器实际插入不少retain,release命令，跳过一些代码不执行可能会造成对象内存混乱发生crash thread list : 列出所有的线程 thread select：选择某个线程 thread until ：传入一个line\b的参数，让\b程序执行到这行暂停 thread info : 输出当前线程的信息 frameframe 对应的就是堆栈中的信息，当然我们可以查看到一些比较详细的信息 frame veriable在我们平时进行debug的时候，主要的目的就是为了查看变量的值，但是通过frame variable命令我们可以打印冲当前frame的所有变量 1234(lldb) frame variable(AppDelegate *) self = 0x16d16710(SEL) _cmd = &quot;loginInWindow:&quot;(NSConcreteNotification *) info = 0x16e47560 @&quot;loginIn&quot; \b这里打印的是当前frame的所有的参数，如果需要打印是具体的参数的话，可以使用 123(lldb) frame variable method(__NSCFConstantString *) method = 0x003abe30 @&quot;GET&quot;(lldb) frame 不常用的命令一般用frame来打印所有变量用的比较多，frame还有些不怎么常用的命令： frame info:查看当前frame的信息 frame select:选择某个frame breakpoint\b调试的时候，我们用的最多的就是断点 breakpoint setbreakpoint set 命令在于设置断点，LLDB提供了很多设置断点的方式：使用 -n 根据方法名设置断点1breakpoint set -n viewWillAppear: 使用-f 指定文件 eg:我们需要给ViewController.m 中的viewDidLoad设置断点 1breakpoint set -f ViewController.m -n viewDidLoad 使用-l指定\b文件的某一行设置断点1breakpoint set -f ViewController.m -l 38 使用-c 设置条件断点 eg: text：方法\b接收一个ret的参数，我们想让ret == YES的时候，程序中断1breakpoint set -n text: -c ret == YES 使用-o 设置单次断点eg:如果某个断点我们只想让它中断一次：1breakpoint set -n text: -o breakpoint Command有时候我们可能需要给断点添加一些命令，比如每次走到这个断点的时候\b，我们需要打印self的对象。我们只需要给断点添加一个po self的命令，就不用每次断点再输出po self了 breakpoint command add: breakpoint command add命令就是给断点添加命令的命令\b 1breakpoint command add -o &quot;po self.view&quot; 3 -o的写法是–one-liner 表示增加一条命令，3 表示的是id为3的breakpoint ; 如果需要添加多个命令的话可以使用1234(lldb) breakpoint command add 237Enter your debugger command(s). Type &apos;DONE&apos; to end.&gt; po self&gt; DONE breakpoint command list如果你想要查看某个断点已有的命令，可以使用breakpoint command list .1234(lldb) breakpoint command list 237Breakpoint 237: Breakpoint commands: po self breakpoint command delete用于删除某个断点的命令 123(lldb) breakpoint command delete 237(lldb) breakpoint command listerror: No breakpoint specified for which to list the commands breakpoint list用于查看\b断点列表 1234567(lldb) breakpoint listCurrent breakpoints:1: file = &apos;/Users/lmzqm/GyennoSpoonIOS/GyennoSpoon/GyennoSpoon/NetWorkManager/NetWorkManager.m&apos;, line = 292, exact_match = 0, locations = 1, resolved = 1, hit count = 0 1.1: where = GyennoSpoon`__47-[NetWorkManager validateUser:success:failure:]_block_invoke + 32 at NetWorkManager.m:292, address = 0x00091aa0, resolved, hit count = 02: file = &apos;/Users/lmzqm/GyennoSpoonIOS/GyennoSpoon/GyennoSpoon/NetWorkManager/NetWorkManager.m&apos;, line = 298, exact_match = 0, locations = 1, resolved = 1, hit count = 0 breakpoint disable/enable让断点失效/生效的操作 后面跟参数也是断点的id \b breakpoint delete删除某个具体的断点 12(lldb) breakpoint delete 2371 breakpoints deleted; 0 breakpoint locations disabled. 如果想要删除所有的断点 就不需要带参数就可以了 watchpointbreakpoint 和watchpoint 最大的不同是一个是\b针对断点进行监控\b，一个是针对地址进行控制。使用watchpoint 来对地址进行观察，当地址里面的东西改变的时候，就让这个程序中断。 watchpoint set用于添加一个watchpoint .只要这个地址中的内容发生变化了，程序就会中断。 watchpoint set variable 12345(lldb) watchpoint set variable wifiSSIDWatchpoint created: Watchpoint 1: addr = 0x006e5428 size = 4 state = enabled type = w declare @ &apos;/Users/lmzqm/GyennoSpoonIOS/GyennoSpoon/GyennoSpoon/Devices/Controller/GYEDeviceConnectViewController.m:134&apos; watchpoint spec = &apos;wifiSSID&apos; new value: 0x16eb8ab0 其中传入的是变量名称 watchpoint set expression 如果我们瞎用直接观察某个地址\b，我们可以使用watchpoint set expression:可以先用p 打印地址，然后再监听这个地址 watchpoint command和breakpoint 类似，在watchpoint中也\b可以添加命令 watchpoint command add 1(lldb) watchpoint command add -o &apos;bt&apos; 1 watchpoint command list watchpoint command delete Watchpoint list如果我们想要看所有的watchpoint,可以使用watchpoint list watchpoint disable当我们不想要让某个watchpoint生效的时候，可以使用watchpoint disable watchpoint enable当我们想要某个watchpoint 生效的时候 watchpoint delete删除某个watchpoint 的操作 Targettarget modules lookup (image lookup) 对于target这个命令\b，用的比较多的可能就是target modules lookup.由于LLDB给target modusles \b取了个别名image ,所以这个命令我们又可以写成 image lookup image lookup -address当我们有一个地址的时候，想要查找这个地址具体对应的文件位置，可以使用image lookup –address .可以简写为 image lookup -a比如在我们程序奔溃的是，我们可以通过这个边界的地址，来查看具体是哪里发生了奔溃1image lookup -a 0x0000000xxxx image lookup -name当我们需要查找一个方法或者符号信息，比如所在文件位置的时候，我们可以使用image lookup –name12345(lldb) image lookup -n userDetailAction2 matches found in /Users/lmzqm/Library/Developer/Xcode/DerivedData/GyennoSpoon-elemepertoodhifkmigcnotkwtxs/Build/Products/Debug-iphoneos/GyennoSpoon.app/GyennoSpoon: Address: GyennoSpoon[0x0009de98] (GyennoSpoon.__TEXT.__text + 612160) Summary: GyennoSpoon`-[GYENoSpoonViewController userDetailAction] at GYENoSpoonViewController.m:44 Address: GyennoSpoon[0x000bd6f8] (GyennoSpoon.__TEXT.__text + 741280) Summary: GyennoSpoon`-[GYEMySpoonViewController userDetailAction] at GYEMySpoonViewController.m:42 可以通过这个迅速的查找到\b对应方法所在的位置 image lookup – type当我们需要查看一个类型的时候，可以使用image lookup –type 123456789(lldb) image lookup -t SpoonModel1 match found in /Users/lmzqm/Library/Developer/Xcode/DerivedData/GyennoSpoon-elemepertoodhifkmigcnotkwtxs/Build/Products/Debug-iphoneos/GyennoSpoon.app/GyennoSpoon:id = &#123;0x700000027&#125;, name = &quot;SpoonModel&quot;, byte-size = 12, decl = SpoonModel.h:11, compiler_type = &quot;@interface SpoonModel : NSObject&#123; NSString * _prefix; NSString * _detail;&#125;@property ( getter = prefix,setter = setPrefix:,readwrite,copy,nonatomic ) NSString * prefix;@property ( getter = detail,setter = setDetail:,readwrite,copy,nonatomic ) NSString * detail;@end&quot; target stop-hooktarget stop-hook命令是让你在可以在每次stop的时候去执行一些命令： target stop-hook 只对breakpoint 和 watchpoint 的程序的stop生效。点击xcode上的暂停是不会生效的 target stop-hook add &amp; display 假如我们想要在每次程序stop的时候，都用命令打印当前frame的所有变量，我们可以添加一个stop-hook target stop-hook list 当添加完stop-hook之后，我们想看当前所有的stop-hook怎么办，可以使用stop-hook list target stop-hook delete &amp; undisplay 有添加的命令就会有删除的命令 如果觉得命令有点长 可以直接使用 undisplay target stop-hook disable/enable 如果我们想要让某个stop-hook失效的时候，我们可以使用 \btarget stop-hook disable id 当然有失效就会有生效 可以使用 target stop-hook enable id target symbols add (add-dsym) dsym文件，程序运行的时候，都会编译成二进制文件。因为计算机只\b识别二进制文件，那为什么我们还能在代码上打断点？ 这主要是因为在编译的时候xcode 会生成dsYM 文件记录了哪些代码对应着哪些二进制，这样我们对代码打断点就会对应到二进制上 当Xcode找不到dsYM文件的时候，我们就无法对代码打断点。进行调试。target symbols add 命令的作用就是让我们可以手动的将dsYM 文件添加上去。LLDB 对这个\b命令起来一个别名：add-dsYM 感谢熟练使用 LLDB，让你调试事半功倍与调试器共舞 - LLDB 的华尔兹","categories":[],"tags":[{"name":"LLDB","slug":"LLDB","permalink":"http://yoursite.com/tags/LLDB/"}]},{"title":"AFNetworking源码之AFURLRequestSerialization","slug":"AFNetworking-AFURLRequestSerialization","date":"2018-05-09T01:50:01.000Z","updated":"2018-05-16T09:31:49.000Z","comments":true,"path":"2018/05/09/AFNetworking-AFURLRequestSerialization/","link":"","permalink":"http://yoursite.com/2018/05/09/AFNetworking-AFURLRequestSerialization/","excerpt":"摘要：在之前我们看到过\bAFHTTPSessionManager 中进行网络请求操作的时候有两个步骤： 首先先构建request 通过构建的request来创建task 关于利用request来创建task的步骤以及在AFURLSessionManager中已经将过程的\b都有很详细的描述了。 那我们的reqeust是如何进行构建的呢？就是我们今天的主角啦！","text":"摘要：在之前我们看到过\bAFHTTPSessionManager 中进行网络请求操作的时候有两个步骤： 首先先构建request 通过构建的request来创建task 关于利用request来创建task的步骤以及在AFURLSessionManager中已经将过程的\b都有很详细的描述了。 那我们的reqeust是如何进行构建的呢？就是我们今天的主角啦！ 实例这里直接截取代码后面再一步\b\b一步的解析：这里是核心代码哦！来自于 AFHTTPSessionManager123NSError *serializationError = nil;NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; API解析接下来分析下AFURLRequestSerialization的来龙去脉 AFURLRequestSerialization123456@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;// 该协议只有一个方法- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW; AFHTTPReqeustSerializer首先：@interface AFHTTPRequestSerializer : NSObject &lt;AFURLRequestSerialization&gt; 属性123456789101112131415161718192021222324252627// \b字符串的编码格式 主要用于对参数的编码 默认是NSUTF8stringEncoding@property (nonatomic, assign) NSStringEncoding stringEncoding;// 创建的请求是否可以使用蜂窝\b数据 默认是YES@property (nonatomic ,assign) BOOL allowsCellularAccess;// 请求的缓存策略 默认是：NSURLRequestUseProtocolCachePolicy@property (nonatomic ,assign) NSURLRequestCachePolicy cachePolicy;// 创建的request是否可以用默认的cookie 处理 默认是YES@property (nonatomic ,assign) BOOL HTTPShouldHandleCookies;// 请求是否在接收到响应之前继续传输数据 默认为NO@property (nonatomic ,assign) BOOL HTTPShouldUsePipelining;// 请求的网络服务@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;// 请求超时时间@property (nonatomic, assign) NSTimeInterval timeoutInterval;// 请求头的\b字段@property (nonatomic ,readonly, strong) NSDictionary &lt;NSString *,NSString *&gt; *HTTPReqeustHeaders;// 针对序列化后将参数转为字符串的请求 \bGET HEAD delete@property (nonatomic, strong) NSSet &lt;NSString *&gt; *HTTPMethodsEncodingParametersInURI; 方法12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建并返回一个采用默认配置的序列化对象+（instancetype ）serializer;// 为请求头设置信息- (void)setValue:(nullable NSString *)valueforHTTPHeaderField:(NSString *)field;// 获取请求头中对应字段的值 没有就返回nil- (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;// 为&quot;Authorization&quot; 设置字段值- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username password:(NSString *)password;// 清楚&quot;Authorization&quot;- (void)clearAuthorizationHeader;- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;// 设置序列化的\b接口- (void)setQueryStringSerializationWithBlock:(nullable NSString * (^)(NSURLRequest *request, id parameters, NSError * __autoreleasing *error))block// 接下来请求的方法// 创建一个NSMutableURLReqeust 对象通过特殊的HTTP方法和URL-(NSMutableURLRequest*)requestWith\bMethod:(NSString *)methods URLString:(NSString *)URLString parameters:(nullable id )parameters error:(NSError *_Nullable __autoreleasing *)error;// 这里也是创建一个NSMutableURLReqeust 并且利用特殊的参数和multipart formData 来构建一个‘multipart/form-data’的\bHTTP BODY - (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(nullable NSDictionary&lt;NSString *, id&gt; *)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError * _Nullable __autoreleasing *)error;//- (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request writingStreamContentsToFile:(NSURL *)fileURL completionHandler:(nullable void (^)(NSError * _Nullable error))handler; 初始化操作12345678910111213141516171819202122232425262728293031323334353637383940-（instancetype）init&#123; self = [super init]; if (!self) &#123; return nil; &#125; self.stringEncoding = NSUTF8StringEncoding; self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary]; // 枚举系统的语言列表 然后设置Accept-language NSMutableArray *acceptLanugagesComponents = [NSMutableArray array]; [NSLocation preferredLanguages] enumerateKeysAndObjectsUsingBlock:^(id obj,NSUInteger idx ,BOOL *stop)]&#123; float q = 1.0f- (idx *0.1f); [acceptLanugagesComponents addObject:[NSString stringWithFormat:@&quot;%@;q=%0.1g&quot;,obj,q]]; *stop = q&lt; 0.5f; &#125; [self setvalue:[acceptLanugagesComponents componentJoinedByString:@&quot;,&quot;] forHTTPHeaderField:@&quot;Accept-Language&quot;]; NSString *userAgent = nil; userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]]; // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html// 需要将parameter转换为query参数的方法集合self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil];self.mutableObservedChangedKeyPaths = [NSMutableSet set];// 添加对 蜂窝数据，缓存策略。cookie 管道 网络状态 超时这几个属性的观察for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext]; &#125;&#125;return self;&#125; 感谢AFNetWorking源码之AFURLRequestSerialization","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"工厂方法模式","slug":"factior-method-pattern","date":"2018-05-08T08:19:41.000Z","updated":"2018-05-09T01:32:37.000Z","comments":true,"path":"2018/05/08/factior-method-pattern/","link":"","permalink":"http://yoursite.com/2018/05/08/factior-method-pattern/","excerpt":"摘要：工厂方法模式成为工厂模式，它属于类创建模式。在工厂模式中。工厂的父类负责定义创建产品对象的公共接口，而子类则负责生成具体的产品对象，这样做的目的是将产品类的实例操作延迟到工厂子类中完成，\b也就是通过工厂子类来创建具体的产品类。","text":"摘要：工厂方法模式成为工厂模式，它属于类创建模式。在工厂模式中。工厂的父类负责定义创建产品对象的公共接口，而子类则负责生成具体的产品对象，这样做的目的是将产品类的实例操作延迟到工厂子类中完成，\b也就是通过工厂子类来创建具体的产品类。 模式结构工厂方法模式包含如下角色： Product ：抽象产品 ConcreteProduct : 具体角色 Factory : 抽象工厂 ConcreteFactory : 具体工厂 代码分析需求分析： 首先由\b一个文件导出操作，一个是导出PDF 一个是导出HTML的操作 // 抽象的工厂 @protocol GYEFileFactory &lt;NSObject&gt; -(id&lt;GYEProduct&gt;) creatProduct; @end // 具体的工厂 @interface GYEHtmlFileFactory:NSObject &lt;GYEFileFactory&gt; @end // 具体的工厂 @interface GYEPDFFileFactory:NSObject &lt;GYEFileFactory&gt; @end 在具体的工厂中创建具体的对象 @implementation GYEHtmlFileFactory -(id&lt;GYEProduct&gt;) creatProduct{ return [[GYEHtmlProduct alloc] init]; } @end @implementation GYEPDFFileFactory -(id&lt;GYEProduct&gt;) creatProduct{ return [[GYEPDFPriduct alloc] init]; } @end 模式分析 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用面向对象的多态性，工厂方法模式保持了简单工厂模式的特点，而且也克服了它的缺点。在工厂模式中不在负责所有产品的创建而是将具体的创建交给子类去做。\b这个核心类仅仅负责给出具体工厂必须实现的接口，而不是负责哪一个产品被实例化的细节，这使得工厂模式可以允许系统在不修改工厂角色的情况下引进新产品 总结 工厂方法模式的主要优点是增加了新的产品类的时候无需修改\b现有系统\b，并封装了产品对象的创建细节，系统有良好的灵活性和可扩展性；缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对的增加，在一定程度上增加了系统的复杂性","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"简单工厂模式","slug":"simple-factory-pattern","date":"2018-05-08T06:45:39.000Z","updated":"2018-05-09T01:32:41.000Z","comments":true,"path":"2018/05/08/simple-factory-pattern/","link":"","permalink":"http://yoursite.com/2018/05/08/simple-factory-pattern/","excerpt":"摘要： 简单工厂模式又称为静态工厂方法模式。它属于创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他\b类的实例，被创建的实例通常具有共同的父类。","text":"摘要： 简单工厂模式又称为静态工厂方法模式。它属于创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他\b类的实例，被创建的实例通常具有共同的父类。 模式结构 简单工厂模式包含如下角色： Factory：工厂角色 工厂角色服装实现穿甲所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是创建所有对象的父类，负责描述所有实例的公共接口 ConcreteProduct：具体产品角色 具体的产品角色是创建的目标，所有创建的对象都充当这个角色的某一个具体类的实例 代码分析 将根据产品，工厂，\b\b和使用方法来进行分析 产品： // 创建一个抽象的产品 @protocol GYEProduct &lt;NSObject&gt; - (void)use; @end // 具体的产品A @interface GYESimpleProductA : NSObject &lt;GYEProduct&gt; @end // 具体的产品B @interface GYESimplePriductB : NSObject &lt;GYEProduct&gt; @end 工厂类： @implementation GYESimpleFactory -(id&lt;GYEProduct&gt; )createProduct:(NSString *)product{ if ([product isEqualToString:@&quot;A&quot;]) { return [GYESimpleProductA new]; }else if([product isEqualToString:@&quot;B&quot;]){ return [[GYESimplePriductB alloc] init]; }else{ return nil; } } 使用： -(void)test{ id &lt;GYEProduct&gt; product = [self createProduct:@&quot;A&quot;]; [product use]; } 优化： 这里工厂类中，随着产品的增加 if…else…的操作会越来越多，慢慢的增加，一直这样下去将会越来越长 这里可以使用runtime的方式来进行简化操作 //这里也可以采用runtime的方式来进行处理 // 根据传入的的类的字符串来进行操作 Class class = NSClassFromString(product); if ([class conformsToProtocol:NSProtocolFromString(@“GYEProduct”)]) { //判断这个实例有没有实现GYEProduct这个协议 return [[class alloc] init]; } 在使用的时候也要进行修改： -(void)test{ id &lt;GYEProduct&gt; product = [self createProduct:NSStringFromClass([GYESimplePriductB class])]; [product use]; } 模式分析 将对象的创建和对象本身业务\b处理分离可以降低系统的耦合度，是的两者修改起来相对容易 在对外部的使用过程中使用父类来替代子类，这样可以统一做处理，而且子类都需要实现父类的方法 简单工厂模式主要在于工厂\b类中需要根据传入的参数然后\b创建对应的子类的实例化对象 该方法屏蔽了实例化的过程，对于用户来说\b不需要知道如何创建的，只需要根据自己的需求来获取对应的实例就可以了 实例运用在AFNetworking中有一个序列化的操作： 首先\b有一个协议 AFURLRequestSerialization @protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt; 协议中有一个方法： -(nullable NSURLRequest )requestBySerializingRequest:(NSURLRequest )request withParameters:(nullable id)parameters error:(NSError _Nullable __autoreleasing )error AFHTTPRequestSerializer @interface AFHTTPRequestSerializer : NSObject - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error { NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; // 对GET HEAD DELETE等方法中，直接使用父类的处理方式 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) { // 将HttpRequstHeader中的值添加加入到请求头中 if (![request valueForHTTPHeaderField:field]) { [mutableRequest setValue:value forHTTPHeaderField:field]; } }]; NSString *query = nil; if (parameters) { if (self.queryStringSerialization) { NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) { if (error) { *error = serializationError; } return nil; } } else { switch (self.queryStringSerializationStyle) { case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; } } } if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) { if (query &amp;&amp; query.length &gt; 0) { mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]]; } } else { // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) { query = @&quot;&quot;; } if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) { [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; } [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; } return mutableRequest; } AFJSONRequestSerializer @interface AFJSONRequestSerializer : AFHTTPRequestSerializer - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error { NSParameterAssert(request); // 对于GET HEAD DELETE等方法中，直接使用父类的处理方式 if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) { return [super requestBySerializingRequest:request withParameters:parameters error:error]; } NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) { if (![request valueForHTTPHeaderField:field]) { [mutableRequest setValue:value forHTTPHeaderField:field]; } }]; // 设置请求头的Content-Type类型 if (parameters) { if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) { [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; } [mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]]; } return mutableRequest; } 在使用的时候：我们可以将其改造成\b简单工厂模式 NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; 总结 针对类的实例化过程进行了抽象，能够将对象的创建和对象的使用过程进行分离 简单工厂模式由三个角色：工厂角色 负责创建所有实例的内部逻辑；抽象\b产品 是\b所创建的所有对象的父类，负责提供实例所有的共接口；具体的产品角色是创建目标 简单工厂模式最大的优点就是实现了对象的创建和使用的分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂不够灵活，增加新的\b具体产品需要修改工厂类的相关逻辑代码而且\b随者产品的增加会越来越复杂 \b","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"AFNetworking-AFHTTPSessionManager 详解","slug":"AFNetworking-AFHTTPSessionManager","date":"2018-05-08T02:51:55.000Z","updated":"2018-05-08T06:31:26.000Z","comments":true,"path":"2018/05/08/AFNetworking-AFHTTPSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/08/AFNetworking-AFHTTPSessionManager/","excerpt":"摘要： 这里我们要给大家讲述下AFHTTPSessionManager\b\b中的知识点。\b首先要知道AFHTTPSessionManager是继承与AFURLSessionManager的，所以，创建\bTask的是可以完成的。AFHTTPSessionManager 更多是关注与HTTP的请求的操作，其核心更多是关于Request的构建，这个request主要用于task的创建。","text":"摘要： 这里我们要给大家讲述下AFHTTPSessionManager\b\b中的知识点。\b首先要知道AFHTTPSessionManager是继承与AFURLSessionManager的，所以，创建\bTask的是可以完成的。AFHTTPSessionManager 更多是关注与HTTP的请求的操作，其核心更多是关于Request的构建，这个request主要用于task的创建。 属性//这个是请求的基础URL 后续的可以使用拼接构成一个新的URL来进行请求的操作 @property(readonly , nonatomic, strong, nullable) NSURL *baseURL; // 这是请求的序列化 主要针对请求的过程中进行reqeust的构建 @property(nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLReqeustSerialization&gt; *requestSerializer; // 这是响应的序列化 主要针对Response中数据的处理操作 @property (nonatomic, strong) AFHTTPReponseSerializer &lt;AFURLResonseSerialization&gt; *responseSerializer; 方法这里的方法主要有初始化的方法，还有针对不同请求方式的方法 初始化/** Creates and returns an `AFHTTPSessionManager` object. */ + (instancetype)manager; /** Initializes an `AFHTTPSessionManager` object with the specified base URL. @param url The base URL for the HTTP client. @return The newly-initialized HTTP client */ - (instancetype)initWithBaseURL:(nullable NSURL *)url; // - (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration { //调用父类来创建一个实例 self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) { url = [url URLByAppendingPathComponent:@&quot;&quot;]; } self.baseURL = url; // 默认采用HTTPSErializer self.requestSerializer = [AFHTTPRequestSerializer serializer]; // 默认采用JSONResonseSerilizer self.responseSerializer = [AFJSONResponseSerializer serializer]; return self; } GET// 通过一个requst来创建并运行一个Get的请求 - (nullable NSURLSessionDataTask*)GET:(NSString*)URLString parameters:(nullable id)parameters success:(nullable void(^)(NSURLSessionDataTask *_Nullable task ,id _Nullable responseObject ))success failure:(nullable void (^)(NSURLSessionDataTask *_Nullable task ,NSError *error))failure; - (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; HEAD- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; POST- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE; - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; PUT- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; PATCH- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; DELETE- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 核心// 构建网络请求的操作 这里主要是针对一些\b比较\b简单的 除了带\bformData 的数据的处理 - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure { // 这里进行序列化的操作 通过序列化\b获得到\b一个请求操作 NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; // 如果序列化出错的处理操作 if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } // 获取task的操作 __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask; } POST的操作方式 - (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure { NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError]; NSDictionary *dic = request.allHTTPHeaderFields; // NSData *data = request.HTTPBodyStream; // id body = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; NSLog(@&quot;%@&quot;,dic); // NSLog(@&quot;%@&quot;,body); if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(task, error); } } else { if (success) { success(task, responseObject); } } }]; [task resume]; return task; } POST请求的常用格式 在众多请求方法中POST的请求还是相对复杂点的，比如\b说比较常见的文件上传的请求操作，其中还会带带一些额外的参数，这样的话请求体的构建\b就会比较复杂点。 application/x-www-form-urlencoded 格式的\bPOST请求这是比较常见的POST提交数据的方式。浏览器原生表单，如果不设置\b的话，默认就会用这种方式提交。如果以这种格式\b进行操作的话：提交的数据会按照 key1=val1&amp;key2=val2的方式进行编码。同时key和val都会进行URL转码 代码展示： // 构建一个sessionConfig NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; config.HTTPAdditionalHeaders = @{};//可以添加额外的请求头信息 // 创建一个HTTPSessionManager AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:_config.baseUrl] sessionConfiguration:config]; //创建一个请求的序列化操作 AFHTTPRequestSerializer *serializer = [AFHTTPRequestSerializer serializer]; // 设置超时时间 serializer.timeoutInterval = 10; // 可以添加一些请求头的信息 [serializer setValue:@&quot;&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; manager.requestSerializer = serializer; NSMutableSet *mulSet = [NSMutableSet setWithSet:manager.responseSerializer.acceptableContentTypes]; [mulSet addObject:@&quot;application/json&quot;]; [mulSet addObject:@&quot;text/plain&quot;]; [mulSet addObject:@&quot;text/json&quot;]; [mulSet addObject:@&quot;text/html&quot;]; // 添加\b响应序列化操作 manager.responseSerializer = [AFHTTPResponseSerializer serializer]; manager.responseSerializer.acceptableContentTypes = mulSet; // 构建task的操作进行网络请求 [manager POST:url parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; multipart/form-data格式的POST请求这种格式主要针对上传文件的操作， 请求头和请求体的格式是比较特殊的首先：content-Type的值必须是multipart/form-data同时\b：同时还需要规定一个内容分割符来分割请求体重多个POST的内容 请求头中信息中：Content-Type:multipart/form-data ;boundary=xxxx 请求体中的信息： POST /upload HTTP/1.1 Host: xxxxx.xxxx.com Content-Type:multipart/form-data ;boundary=xxxxxx Accept-Encoding: gzip, deflate Connection: keep-alive Date: 2017-10-19 18:11:53 +0800 Accept: */* User-Agent: GyennoMedical/4.0.0 (iPhone; iOS 11.0.3; Scale/3.00) Accept-Language: en-US Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJvcmdUeXBlIjoxLCJzdWIiOiIxMzgwMDEzODAwMyIsInVzZXJUeXBlIjoxLCJleHAiOjE1MDk1Mjk1MzYsInVzZXJJZCI6OTg2NTc5LCJvcmdJZCI6Mn0.CKxnt5f5uTRvUwuEybcN79RG-uf74pFbWwWbCFk8jJI Content-Length: 4556 --xxxxxxx Content-Disposition:form-data;name=&quot;meta&quot; xxxxxxxxx 对应的字段内容 --xxxxxxx Content-Disposition:form-data;name=&quot;fileupload&quot; filename=&quot;file1.jpeg&quot; Content-Type:image/jpeg XXXXXXXXXXXXXX //图片的数据 --xxxxxxx-- 先构建下核心代码： [manager POST:prefixUrlString parameters:@{@&quot;meta&quot;:str} constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { NSData *data = UIImageJPEGRepresentation(image, 0.01); [formData appendPartWithFileData:data name:@&quot;fileUpload&quot; fileName:@&quot;file1.jpeg&quot; mimeType:@&quot;image/jpeg&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { successBlock(responseDic); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; application/json\b格式的POST请求这种格式的操作下会将数据采用json的格式进行组合 这里需要注意的就是针对\b请求序列化操作的时候采用\b AFHTTPRequestSerializer *serializer = [AFJSONRequestSerializer serializer]; 这样就可以达到效果了。 POST /xxxxx/xxxxxx HTTP/1.1 Host: xxxxx.xxxxx.com Content-Type: application/json Accept-Encoding: gzip, deflate Connection: keep-alive Date: 2017-10-17 18:11:53 +0800 Accept: */* User-Agent: GyennoMedical/4.0.0 (iPhone; iOS 11.0.3; Scale/3.00) Accept-Language: en-US Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJvcmdUeXBlIjoxLCJzdWIiOiIxMzgwMDEzODAwMyIsInVzZXJUeXBlIjoxLCJleHAiOjE1MDk1Mjk1MzYsInVzZXJJZCI6OTg2NTc5LCJvcmdJZCI6Mn0.CKxnt5f5uTRvUwuEybcN79RG-uf74pFbWwWbCFk8jJI Content-Length: 108 {&quot;userId&quot;:&quot;xxxxxxx&quot;,&quot;pageNo&quot;:1,&quot;orgType&quot;:1,&quot;pageSize&quot;:5,&quot;orgId&quot;:2,&quot;userType&quot;:1,&quot;accountNumber&quot;:&quot;xxxxxxxxx&quot;} 总结 通过上面的代码中的展示，我们可以清楚AFHTTPSessionManager主要是 RequestSerializer 和 AFURLSessionManger中的两个部分来构建： serilizer 主要是通过获取的参数来进行URLReqest的构建 URLSessionManger 主要通过request来创建Task 并允许task 所以将在下一篇分析下RequestSerializer 里面的东西 其中重点讲放在POST的请求中","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"设计模式","slug":"design-create-model","date":"2018-05-03T10:31:21.000Z","updated":"2018-05-15T09:00:43.000Z","comments":true,"path":"2018/05/03/design-create-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-create-model/","excerpt":"摘要\b：设计模式分为三大类 创建型模式 结构型模式 行为型模式","text":"摘要\b：设计模式分为三大类 创建型模式 结构型模式 行为型模式 创建型模式创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对这些对象只需要指定他们共同的接口，而不需要知道具体的实现细节，使整个系统设计更加符合单一职责的原则 简单工厂模式 （simple Factory） 工厂方法模式 （Factory Method） 抽象工厂模式 （Abstract Factory） 建造者模式 （Builder） 原型模式 （Prototype） 单例模式 （Singletion） 结构型模式设计模式的六大原则：1. 开闭原则OCP 开闭原则\b说的是， 对扩展开放、对修改关闭 。在程序需要进行扩展的时候，不全修改原有的代码，这是为了使程序的扩展性更好，更易于升级和维护。 2. 里氏代换原则LSP 在软件开发的时候使用基类替换它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类\b对象的话，那么它一定不能使用基类对象。里氏代换原则的程序表现如下：在程序中尽量使用基类类型来对对象进行定义，而在运行的时候再确定其子类，用子类对象来替换父类。 3. 控制反转原则IOC 针对接口编程，依赖于抽象而不依赖于具体 4. 接口隔离原则ISP 使用多个隔离的接口，比使用单个接口要好 5. 迪米特法则DP 一个实体应当尽量少的与其他实体间发生作用，使得系统功能模块相对独立 6. 合成复用原则 尽量使用组合/聚合的方式，而不是使用继承 关键字1.抽象化在众多的事物中提取出共同的、本质的特征，舍弃非本质的特征，就是抽象化。抽象化的过程就是一个剪裁的过程，抽象的时候同于不同取决于从什么角度上来抽象。抽象的角度取决于分析问题的目的 2.实现化抽象类给出的具体的实现就是实现化一个类的实例就是这个类的实例化，一个具体子类是它的抽象超类的实例化 3.解耦所谓的耦合，就是两个实体的行为的某种强关联。而将它们之间的强关联去掉就是解耦。 解耦是指将抽象化和实现化之间的耦合解开，或者说将它们之间的强关联改为弱关联 所谓强关联，指的是在编译事情就已经确定的，无法再运行时期改变的关联，所谓\b弱关联就是可以动态的确定并且在运行时期动态的改变的关联。从这个定义上看，继承的关系是强关联，聚合的关系是\b弱关联 感谢Java设计模式1：设计模式概论 看懂UML类图和时序图","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式 开篇——读懂UML类图和时序图","slug":"design-model","date":"2018-05-03T09:38:58.000Z","updated":"2018-05-17T09:40:44.000Z","comments":true,"path":"2018/05/03/design-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-model/","excerpt":"摘要： \b日常的编程中我们经常能提到抽象，耦合，聚合，关联，依赖等一些专业词汇，那我们\b通过学习了解了其的词语解释后，我们怎么样能在代码中将它们的关系给表现出来。比如说给你一个UML的图，你能看清楚线条和箭头分别代表着什么吗？你能根据这个UML的图写出对应的代码吗？","text":"摘要： \b日常的编程中我们经常能提到抽象，耦合，聚合，关联，依赖等一些专业词汇，那我们\b通过学习了解了其的词语解释后，我们怎么样能在代码中将它们的关系给表现出来。比如说给你一个UML的图，你能看清楚线条和箭头分别代表着什么吗？你能根据这个UML的图写出对应的代码吗？ 首先从一个实例开始通过下图我们将一一分析类之间的关系 车的类图结构为\\,表示车是一个抽象类; 它有两个继承类：小汽车和自行车； 它们之间的关系为\b实现关系，使用带空心箭头的虚线表示 小汽车和SUV之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示 小汽车和发动机之间属于组合关系，使用带\b实心箭头的实线表示 学生和班级之间属于聚合关系，使用带空心箭头的实线表示 学生和身份证之间是关联关系，使用一根实线表示 学生上学需要自行车，与自行车是一种依赖关系，使用带箭头的虚线表示 类之间的关系泛化关系（generalization） 类的继承结构在UML中表示为：泛化，实现 继承关系表示is-a的关系 表示是的关系 在UML中用时一个空心实线箭头表示 表示（A继承自B） 在最终的代码中，泛化关系表现为继承非抽象 \b实现关系(realize) 实现关系用一条空心箭头的虚线表示 eg:”车”是一个抽象概念，在现实中无法直接用来定义对象，只有指明具体的子类才可以用来定义对象 在最终代码中，实现关系表现为继承抽象类 聚合关系(aggregation) 聚合关系用一条带空心菱形箭头直线表示，表示A聚合到B上，或者说B是由A组成的 聚合关系用于表示实体对象之间的关系，表示整体由部分构成 与组合关系不同的是，整体和部分不是强依赖，即使整体不存在了，部分任然粗壮 在代码中主要体现是也是类中\b的一个实例变量，改实例变量在程序外面可以改变，而且其的创建和销毁\b不是由内部来实现的，只负责使用其中的属性和方法就可以了 组合关系(composition) 组合关系用一条带实心菱形箭头直线表示:如下图表示 A组成B 或者B 由A组成 与聚合关系一样，组合关系表示整体由部分构成的语义 但是组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在 在代码中可以体现为：首先也是一个实体的变量，但是其具体的创建应该是由构造函数来实现的，也就是说其的生命周期来源于\b组合进入的对象进行创建 关联关系(association) 关联关系用一条直线表示 描述不同类的对象之间的结构关系，它是一种\b静态关系，通常与运行的状态无关，一般由常识因素决定；它一般用来定义对象之间静态的，天然的结构；所有关联关系是一种强关联的关系 关联关系默认不强调方向，表示对象件相互知道，如果特别强调方向，如下图表示A知道B,但B不知道A 在最终代码中，关联对象同时是以成员变量的形式实现 依赖关系(dependency) 依赖关系是一套带箭头的虚线表示的，如下图表示A依赖于B ,它描述的是一个对象在运行的时候会用到另一个对象的关系 与关联关系不同的是，他是一种临时性的关系，通常发生在运行期间产生，并且随着运行时的变化，依赖关系也可能发生改变 显然依赖也是有方向的，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生 在最终的代码中，依赖关系体现为类构造方法以及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方还是使用对方的方法和属性 讨论 上面我们讨论了\b类中存在的六种关系，其中也能够看出有些关系比较类似但其实仔细分析还是能看出其中的差异，为了更好的理解，我们可以将他们用来做比较 泛化和实现的对比 相同点：都是一种继承的关系 \b不同点：泛化是继承于非抽象类，而实现是继承于抽象类 关联和依赖的对比 相同点：都\b存在于\b对象中，提供对象所使用 不同点： 依赖是一种\b\b比较弱的关系，两个类都不会增加属性，其中一个类作为另一个类的参数或者返回值，或者某个方法的变量 ，而关联的话，其中被关联的对象会成为关联对象的一个属性\b \b从生命周期来分析，依赖关系仅仅在类的方法被调用的时候产生，伴随着方法的结束而结束。关联关系当类实例化的时候产生，当类销毁的时候关系结束，相比\b依赖，关联关系的生存期更长 一个以属性的方式存在，一个以参数的方式或者返回值的方式\b存在 聚合和组合的对比 相同点： 针对对象来说都是一个属性的使用，都是关联的一种具体的体现 不同点： 聚合关系的类具有不同的生命周期，组合关系的类具有相同的生命\b周期（一个传递的是实例化对象，一个是构造一个实例对象） 信息封装性不同在聚合关系中，客户端可以同时了解两个类，他们是\b独立的在组合关系中，客户端只需要了解一个类就可以了，因为另一个类是被隐藏了 小结依赖，关联，聚合，组合，泛化代表\b类与类之间耦合的程度依次增加。依赖关系实际上是一种比较弱的关系，聚合是一种比较强的关联，组合是一种更强的关联，泛化是一种最强的关系 依赖关系比较好区分，它是一种耦合度最弱的一种，在编码中表现为类成员函数的局部变量，形参，返回值对静态方法的调用 关联、聚合、组合在编码形式上都以类成员变量的形式来表示。所以有时候很难判断出具体是哪个一个关系。 关联表示类之间存在关系，不存在集体和个体，个体与组成部分之间的关系；聚合表示类之间存在集体与个体的关系组合表示个体与组成部分之间的关系 时序图 对象之间交互的图，这些对象是按时间顺序排列的，时序图中显示的是参与交互对象以及对象之间消息交互的顺序 时序图包括对象主要有：对象（actor）生命线（Lifeline）控制焦点（Focus of control）消息（Message）等待 感谢看懂UML类图和时序图","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"AFNetworking-AFURLSessionManager详解","slug":"iOS-AFNetworking-AFURLSessionManager","date":"2018-05-03T07:45:33.000Z","updated":"2018-05-08T06:29:42.000Z","comments":true,"path":"2018/05/03/iOS-AFNetworking-AFURLSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/03/iOS-AFNetworking-AFURLSessionManager/","excerpt":"摘要： 关于\biOS中的网络请求，在上一篇文章中已经大体了解了在网络请求的过程中的一些主要点，比如说一个NSURLRequest,一个NSURLSession，一个Task 等等,在我们的实际项目中我较多使用的是AFNetworking来作为我的网络请求模块，然后再对其进行封装下。个人认为对于第三进行封装是很有必要的，要不然当你切换一个\b新的第三方的时候，你需要在你的工程中找呀找，改呀该。","text":"摘要： 关于\biOS中的网络请求，在上一篇文章中已经大体了解了在网络请求的过程中的一些主要点，比如说一个NSURLRequest,一个NSURLSession，一个Task 等等,在我们的实际项目中我较多使用的是AFNetworking来作为我的网络请求模块，然后再对其进行封装下。个人认为对于第三进行封装是很有必要的，要不然当你切换一个\b新的第三方的时候，你需要在你的工程中找呀找，改呀该。 上面废话有点多了 今天我会通过源代码给大家分享下，AFNetworking的核心，AFURLSessionManager ,其实如果对于NSURLSession比较了解的话，相信用该很请求这个Manager的主体核心的功能就是通过session来创建task ,然后利用代理来做请求的反馈的过程。ok 接下来让我们先了解下吧！ 方法和属性属性//manager的会话 很熟悉吧！ @property (readonly, nonatomic, strong) NSURLSession *session; // 代理调用中用到的操作队列 @property (readonly ,nonatomic ,strong) NSOperationQueue *operationQueue; //接收信息的序列化 @property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer; // 会话的安全策略 @property (nonatomic, strong) AFSecurityPolicy *securityPolicy; /** The data, upload, and download tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks; /** The data tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks; /** The upload tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks; /** The download tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks; // 针对completionBlock的一个队列 如果为null的haul 使用main queue @property (nonatomic, strong, nullable) dispatch_queue_t completionQueue; // 针对\b组请求操作 completionBlock 的操作 @property (nonatomic, strong, nullable) dispatch_group_t completionGroup; //如果后台会话中创建上传任务失败的话 会继续创建 @property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions; 方法 初始化 // 一个配置项就可以初始化一个Manager - (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration{ self = [super init]; if (!self) { return nil; } // 如果有用户没有手动指定的话，就默认使用configuration来初始化 if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } // 赋值给属性 self.sessionConfiguration = configuration; // 初始化NSURLSession的task代理方法执行的队列 // 这里有一个关键的点就是task的代理执行的queue一次只能执行一个task 队列是串行队列 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; // 初始化NSURLSession 对象 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 如果用户没有手动指定的话，默认返回的数据是JSON格式序列化 self.responseSerializer = [AFJSONResponseSerializer serializer]; // 指定https处理的安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH // 初始化网络状态监听属性 self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif // 用于处理task和Delegate代理对象一一对应的关系 这个很关键 self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; // 初始化一个锁对象，关键操作加锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取当前session正在执行的的所有task.同时为每一个Task添加‘Delegate’代理对象 这个代理对象主要用于管理uploadTask和downLoadTask的进度管理，并且在Task执行完毕后调用相对应的Block 同时发送Notification对象，实现Task数据或者状态改变的检测 **/ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self; } 任务的创建： //创建一个dataTask 通过特殊的request - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 创建一个dataTask 并由uploadprogress 和downloadProgress的回调操作 - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过request和 一个文件的路径来创建一个uploadTask - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过一个bodyData和request来创建一个uploadTask - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过一个特殊的请求来创建\bdownLoadTask - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler; // 创建一个断点下载的downloadTask - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler; 其他： // 是否是会话无效 通过取消任务 一个是立即取消 一个是等任务完成后再取消 - (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks{ dispatch_async(dispatch_get_main_queue(), ^{ if (cancelPendingTasks) { //这个就是会话的方法啦 [self.session invalidateAndCancel]; } else { [self.session finishTasksAndInvalidate]; } }); } 各种回调的block: - (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block; - (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block; - (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block; - (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block; - (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block; - (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block; - (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block; - (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block; - (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block; - (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block; - (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block; - (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block; - (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block; - (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block; - (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block; 一看就已经很明白啦！都是针对代理的block 使用流程AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; \bNSURLSessionDataTask *task = [manager dataTaskWithRequest:reques completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) { if (error) { // successBlock(()) }else{ } }]; [task resume]; 下面我们来分析下dataTask创建中的代码： - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { __block NSURLSessionDataTask *dataTask = nil; // 这里是一个同步的操作,当然它的方法也是简单的session场景dataTask的方法 url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); // 给task添加代理 并将uploadProgressBlock 和 download\bProgressBlock 还有 completionHanler 也交给代理进行管理 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } 下面让我们来分析 addDelegateForDataTask 当中的操作这里的主要操作是为Task设置一个代理对象，从而可以实现对进度处理，Block调用、Task完成返回数据的拼装的功能 - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler { // 这里创建一个代理的对象 delegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; // 赋值delegate的manager delegate.manager = self; // 赋值deleget的completionHandler 这个是针对Task的处理的回调 delegate.completionHandler = completionHandler; //添加任务的描述 \b dataTask.taskDescription = self.taskDescriptionForSessionTasks; // 为task 添加代理 [self setDelegate:delegate forTask:dataTask]; //还有uploadblock 和 downloadblock delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock; } // Delegate 设置Task 状态改变的监听 主要是task的挂起或者重启的监听 - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task { NSParameterAssert(task); NSParameterAssert(delegate); // 这里需要用到加锁的处理 [self.lock lock]; // 为task设置与之代理方法关联关系。通过一个字典,便于后续通过task 来进行查找delegate 然后滴啊用deleget的对应的方法来进行操作 self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 添加Task开始，重启，挂起状态的通知的接收 便于控制uploadProgress和downloadProgerss [delegate setupProgressForTask:task]; [self addNotificationObserverForTask:task]; [self.lock unlock]; } 下面来分析下 AFURLSessionManagerTaskDelegate 创建： /* 初始化AFURLSessionManagerTaskDelegate */ - (instancetype)init { self = [super init]; if (!self) { return nil; } // 这个属性用于存储Task下载过程中的数据 self.mutableData = [NSMutableData data]; // 存储Task上传和下载的进度 self.uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; self.uploadProgress.totalUnitCount = NSURLSessionTransferSizeUnknown; self.downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; self.downloadProgress.totalUnitCount = NSURLSessionTransferSizeUnknown; return self; } - (void)setupProgressForTask:(NSURLSessionTask *)task { __weak __typeof__(task) weakTask = task; self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive; [self.uploadProgress setCancellable:YES]; // 当process对象取消的时候，取消task [self.uploadProgress setCancellationHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask cancel]; }]; // 当process暂停的时候，暂停task [self.uploadProgress setPausable:YES]; [self.uploadProgress setPausingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask suspend]; }]; // 重启Task if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) { [self.uploadProgress setResumingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask resume]; }]; } // 针对取消progress的操作也是一样的 [self.downloadProgress setCancellable:YES]; [self.downloadProgress setCancellationHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask cancel]; }]; [self.downloadProgress setPausable:YES]; [self.downloadProgress setPausingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask suspend]; }]; if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) { [self.downloadProgress setResumingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask resume]; }]; } // kvo的操作 会调用 observeValueForKeyPath 的函数的操作 对NSURLSessionTask 的属性进行观察操作 //数据的接收，主要针对downloadTask [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive)) options:NSKeyValueObservingOptionNew context:NULL]; //数据的上传，主要针对uploadTask [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend)) options:NSKeyValueObservingOptionNew context:NULL]; // 为progress 添加kvo 针对 fractiongCompleted [self.downloadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; [self.uploadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; } 这里是针对上面kvo的操作 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context { if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) { self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) { self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) { self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) { self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } } else if ([object isEqual:self.downloadProgress]) { // 更新下载的进度的BLock if (self.downloadProgressBlock) { self.downloadProgressBlock(object); } } else if ([object isEqual:self.uploadProgress]) { // 更新上传进度的Block if (self.uploadProgressBlock) { self.uploadProgressBlock(object); } } } ok,这些前期的工作做完以后，我们就可以开始代理的工作了： 这里的代理主要实现了几个方法： \b当任务完成以后： #pragma mark - NSURLSessionTaskDelegate // 当task完成以后，会调用delegate对象的方法对返回的数据进行封装 - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; // 获取Task对应的Manager对象 __strong AFURLSessionManager *manager = self.manager; // 要封装的responseObject对象 __block id responseObject = nil; // __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //返回的数据 //Performance Improvement from #2672 NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } //如果是downloadTask 就封装downloadFileUrl if (self.downloadFileURL) { userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; } else if (data) { userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; } // 针对请求错误的封装 if (error) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ // 如果task有completionHandler 就调用这个Block if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } // 发送一个指定task结束的通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); } else {//正确数据的封装 dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; // 返回数据的封装 responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; if (self.downloadFileURL) { responseObject = self.downloadFileURL; } if (responseObject) { userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; } if (serializationError) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; } // 如果Task有完成的Blokc，则调用这个Block dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } // 发送Task完成的通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } #pragma clang diagnostic pop } NSURLSessionDataTaskDelegate \b代理的操作 #pragma mark - NSURLSessionDataTaskDelegate - (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { // 这里主要做的是数据的拼接 [self.mutableData appendData:data]; } NSURLSessionDownloadTaskDelegate 代理操作： #pragma mark - NSURLSessionDownloadTaskDelegate - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { NSError *fileManagerError = nil; self.downloadFileURL = nil; // 这里的location是缓存的url的地址 if (self.downloadTaskDidFinishDownloading) { // 将获取文件的存放路径 然后将location的地址放入到存放的地址中进行文件的保存操作 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (self.downloadFileURL) { // 这里是存放的操作 [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]; if (fileManagerError) { [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; } } } } 这里是一个下载的例子，可以好好参考下： NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress *downloadProgress){ NSLog(@&quot;下载进度:%lld&quot;,downloadProgress.completedUnitCount); } destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) { NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; NSURL *fileURL = [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]]; NSLog(@&quot;fileURL:%@&quot;,[fileURL absoluteString]); return fileURL; } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) { self.imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:filePath]]; NSLog(@&quot;File downloaded to: %@&quot;, filePath); }]; 其中有一个destination的block的操作： - (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler { // 根据指定的Task，初始化一个AFURLSessionManagerTaskDelegate 其实这里采用的是MVP模式 AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; delegate.manager = self; // 设置task完成的回调你的BLOCK delegate.completionHandler = completionHandler; if (destination) { // 任务完成以后，调用destination 这个Block delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) { return destination(location, task.response); }; } // 指定Task与taskDescriptionForSessionTasks的关联，方便后面的通知中做出对应的处理 downloadTask.taskDescription = self.taskDescriptionForSessionTasks; // 添加通知 [self setDelegate:delegate forTask:downloadTask]; // 设置一个下载进度的block,以便在后面代理中调用 delegate.downloadProgressBlock = downloadProgressBlock; } 后面有一个destination的操作，我们做的事情就是给它找一个合适的地方来进行存放，然后在completion中主要做的就是将文件的地址给我们的应用就可以了 代理完成任务以后，我们要做什么？ - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 当我们的task完成任务以后： AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) { [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; } if (self.taskDidComplete) { self.taskDidComplete(session, task, error); } } // 当移除Task对应的通知和对应的AFURLSessionManagerTaskDelegate代理对象 - (void)removeDelegateForTask:(NSURLSessionTask *)task { NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; // 移除task对应的kvo [delegate cleanUpProgressForTask:task]; // 移除Task对应的delegate对象 [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock]; } 代理的清除操作： - (void)cleanUpProgressForTask:(NSURLSessionTask *)task { [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]; [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; } 其中的MVP 在AFURLSessionManager中我们可以看到，这里针对每个task 都会有一个addDelegateForTask的方法，这里的针对每一个task 都创建一个AFURLSessionTaskDelegate 的代理，这个代理就是MVP中的Present 它处理View中的一些操作，然后将处理好的操作的数据，同时P中\b对于Manager使用的是Weak的操作 一个弱引用而不是强引用 特殊模块说明AFURLSessionManager 实现了 NSSecureCoding 协议 让Manager可以归档和解档的操作 使用dispatch_semaphore_t信号量来控制对异步处理返回的结果控制// 用dispatch_semaphore_t 来控制对异步处理返回的结果的控制 - (NSArray *)tasksForKeyPath:(NSString *)keyPath { //获取session对应的task列表，通过disptch_semaphore_t来控制访问过程 __block NSArray *tasks = nil; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) { tasks = dataTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) { tasks = uploadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) { tasks = downloadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) { tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;]; } dispatch_semaphore_signal(semaphore); }]; // 这里会一直等待信号量变为1 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 返回Task. 通过信号量控制，避免了方法结束的时候，tasks还没有正常获取的情况 return tasks; } 总结ok,在这里已经将AFURLSessionManager的主要的实现都已经涉及到了。下面来","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"iOS NSURLSession 解析","slug":"NSURLSESSION-Detail","date":"2018-04-24T09:04:38.000Z","updated":"2018-05-03T07:40:45.000Z","comments":true,"path":"2018/04/24/NSURLSESSION-Detail/","link":"","permalink":"http://yoursite.com/2018/04/24/NSURLSESSION-Detail/","excerpt":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。","text":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。 一个简单的例子这里构建一个简单的请求的例子 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:smallPic]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc]init]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request]; [dataTask resume]; 从上的代码中我们可以大体的分析下，一个网络请求的过程中，我们分别需要的角色： NSURLRequest ：一个网络请求 NSURLSession ： 一个会话 NSURLSessionConfiguration ： 会话的配置项 NSURLSessionDataTask : 会话中的任务 一个会话需要会话的配置信息来进行创建，其中还存在着线程队列已经代理的设置一个任务是会话通过请求的信息来进行创建，创建出来的任务只有执行resume后才开始执行任务 下面我们将通过对这个所需的元素进行一一分析，来进一步的了解他们之间的关系，已经各个元素的一些属性和方法。 首先针对AFNetworking的扩展，其实它的核心也是一个最基础的网络请求操作，后续再对这个简单的操作进行扩展，这样就会慢慢的可以通过用户添加一些block来对函数进行一些自定义的一些操作，这些都是后话。后期的话，我会针对AFNetworking进行源码解析，同时也希望自己能够写出实现自己的网络框架。 NSURLRequest在iOS中关于请求的操作，其基类都是NSURLReqeust 当然还有一个可变的NSMutableURLReqeust当然对于可变和不可变的特性相对大家都已经比较理解了。下面我们来创建一个最基础的reqeust [[NSURLRequest alloc] initWithURL:@&quot;url&quot;]; 最简单的组成就是一个url来创建，当然它还有一些特性，这些特性针对URLReqeust更多的是可读的属性但是对可变的URLRequest则是可读可写的 创建实例对象：类方法： //通过url来进行创建 +(instancetype)requestWithURL:(NSURL*)URL; // 通过url 以及缓存策略 还有网络超时时长来进行创建 +(instancetype)requestWithURL:(NSURL*)URL cacehPolicy:(NSURLRequestCachePolicy)cachePolicy timeooutInterval:(NSTimeInterval)timeoutInterval; 实例方法： - (instancetype)initWithURL:(NSURL *)URL; // 通过实例方法创建 - (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval NS_DESIGNATED_INITIALIZER; 属性：@property (nullable, readonly, copy) NSURL *URL;// url @property (readonly) NSURLRequestCachePolicy cachePolicy;//缓存策略 @property (readonly) NSTimeInterval timeoutInterval;//网络请求超时时间 @property (nullable, readonly, copy) NSString *HTTPMethod;//请求的方法 有get post delete put 等等 @property (nullable, readonly, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields; //请求头中的字段所存放的字典 针对这字段有提供专门的方法来实现添加和查询的工作： - (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;//根据字段名字查找对应的信息 - (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//这是直接设置对应的信息 - (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//这里是添加对应的信息 @property (nullable, copy) NSData *HTTPBody;//请求中的数据信息 也就是请求体重的信息 这些是主要用到的信息，如果后期还有的话，会慢慢添加的。 其实很多对网络特别是HTTP协议不是很理解的人，可能看得有点晕，没关系，这里我们贴下http的请求给大家看看就会便于理解了 GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 上面的代码中我们可以知道关于Request中的一些信息： url:img.mukewang.com/562f25980001b1b106000338.jpg HTTPMethod:GET 接下来就是请求头的一些字段： Accept : 表示客户端接受的一些格式 Accept-Encoding：接受的压缩格式 Accept-Language：接受的语言 NSURLSessionConfiguration关于会话的配置有三种模式： //默认模式 @property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration; // 临时会话模式 @property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration; //后台模式 + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0)); 属性// 一个后台会话的标识符 @property (nullable, readonly, copy) NSString *identifier; // 请求缓存策略 @property NSURLRequestCachePolicy requestCachePolicy; // 网络请求超时时长 @property NSTimeInterval timeoutIntervalForRequest; // 网络资源请求操作 @property NSTimeInterval timeoutIntervalForResource; // 网络请求服务类型 @property NSURLRequestNetworkServiceType networkServiceType; // 是否允许用蜂窝 @property BOOL allowsCellularAccess; // 添加额外的请求头 @property (nullable, copy) NSDictionary *HTTPAdditionalHeaders; NSURLSession 这个类是关于会话的创建，会话的使用，会话的调度等等 下面通过源代码来对这个类进一步了解： 创建// 通过会话配置来进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过会话配置 还有代理 已经多线程队列进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue; 生成不同的TaskdataTask/* Creates a data task with the given request. The request may have a body stream. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request; /* Creates a data task to retrieve the contents of the given URL. */ - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url; uploadTask/* Creates an upload task with the given request. The body of the request will be created from the file referenced by fileURL */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL; /* Creates an upload task with the given request. The body of the request is provided from the bodyData. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData; /* Creates an upload task with the given request. The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */ - (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request; downTask/* Creates a download task with the given request. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request; /* Creates a download task to download the contents of the given URL. */ - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url; /* Creates a download task with the resume data. If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */ - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData; 直接带返回回调的task/* * data task convenience methods. These methods create tasks that * bypass the normal delegate calls for response and data delivery, * and provide a simple cancelable asynchronous interface to receiving * data. Errors will be returned in the NSURLErrorDomain, * see &lt;Foundation/NSURLError.h&gt;. The delegate, if any, will still be * called for authentication challenges. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * upload convenience method. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * download task convenience methods. When a download successfully * completes, the NSURL will point to a file that must be read or * copied during the invocation of the completion routine. The file * will be removed automatically. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; 属性和方法属性：@property (readonly ,retain) NSOperationQueue *delegateQueue; @property (nullable,readonly,retain) id &lt;NSURLSessionDelegate&gt; delegate; @property (readonly ,copy) NSURLSessionConfiguration *configuration; //会话的描述 @property (nullable,copy) NSString *sessionDescription; 方法：//完成所有任务后，将会话无效 // returns immediately and existing tasks will be allowed to run to completion. New tasks may not be Created。The Session will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError: has been issued; -(void)finishTasksAndInvalidate; // 会话无效后取消操作 // issues cancel to all outstanding tasks for this session. -(void)invalidateAndCancel; //invoke completionHandler with outstanding data,upload and download tasks -(void)getTasksWithCompletionHandler:(void(^)(NSArray&lt;NSURLNSURLSessionDataTask*&gt;* dataTask,NSArray&lt;NSURLSessionUploadTask*&gt;* uploadTasks,NSArray&lt;NSURLSessionDownloadTask*&gt;*downloadTask))complcompletionHandler; 代理NSURLSessionDelegate// 这是会话接收最后一条消息 当会话遇到系统级的错误 获取当会话无效的时候 -(void)URLSession:(NSUrlSession*)session didBecomeInvalidWithError:(nullable NSError *)error; //当遇到需要用户权限验证的时候，或者HTTPS验证的时候会调用这个代理 -(void)URLSession:(NSURLSession*)session didReceiveChallenge:(NSURLAuthenticationChallenge*)challenge completionHandler:(void(^)(NSURLSessionAuthChallengeDispostion disposition NSURLCredential * _Nullable credential))completionHandler; //当applicaton 接收到application handleEvnetsForBackgroundURLSession:completionHandler 的消息的时候 // 会话的代理会接受到这个消息来 处理后台消息 -(void)URLSessionDidFinisheEventsForBackgroundURLSession:(NSURLSession*)session; NSURLSessionTaskDelegate// 网络请求重定向的时候 执行的操作 我们必须设置一个新的Request 然后传入到comoletionHandler中的request中 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler; // task接受到一个用户认证的请求，如果这个代理没有被实现的话，会话的认证将不会被调用 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler; // 如果task的请求需要一个新的bodyStream的时候会调用 当认证请求失败时候，我们可以通过这个代理重新弄个bodyStream来实现 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream * _Nullable bodyStream))completionHandler; // 当上传数据的时候，会调用这个代理 主要是针对upload的请求的时候，可以获取到上传的进度 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend; // 当一个任务完成后，无论失败或者成功都会调用这个代理 如果成功的话 error 为nil - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error; NSURLSessionDataTaskDelegate//当一个task接受到返回的消息，当所有的信息都接受完毕后completionHanler会被调用。我们可以在这里取消一个请求或者将一个data的任务改为下载的task.如果你没有实现这个dialing，我们可以通过task的response属性获取对应的数据 后台模式中uploadtask不会调用给这个代理 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler; // 一个dataTask 变为downloadTask - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask; //当datatask可以用的时候，我们可以在这里获取data的数据 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data; // 缓存completionHandler缓存data 或者传入nil 不需要缓存 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler; NSURLSessionDownloadTaskDelegate// 当一个\bdownloadTask 任务完成后我们可以通过给的location 的路径值来保存文件或者移动文件 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location; // 获取下载的进度 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite; // 断点下载的操作 NSURLSessionDownloadTaskResumeData 这个字段里会告诉你 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;","categories":[],"tags":[{"name":"iOS  NSURLSession","slug":"iOS-NSURLSession","permalink":"http://yoursite.com/tags/iOS-NSURLSession/"}]},{"title":"iOS性能优化总结","slug":"iOS-youhua-detail","date":"2018-04-17T09:33:47.000Z","updated":"2018-04-23T10:03:10.000Z","comments":true,"path":"2018/04/17/iOS-youhua-detail/","link":"","permalink":"http://yoursite.com/2018/04/17/iOS-youhua-detail/","excerpt":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。","text":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。 首先思考问题： 为什么要性能优化？ 性能优化主要是针对哪些方法的优化？ 发现问题 问题的发现目前主要还是依靠的是工具来进行发现。因为这样比较直观而且也有利于我们能够发现具体问题产生的地方，以便于我们队问题的解决。要不然我们都知道有问题，但是问题具体原因在哪里查不出来的话，这样的意义就小多了。当然最主要的还是用户体验方面能够感受到性能的问题，如果存在卡顿，或者闪退什么的，这样的体验就low了。所以问题一个是来自于用户的反馈还有就是测试人员或者开发人员一些体验的感受。 好了废话不多说：直接上工具 MLeakFinder 内存检测工具FPS性能检测工具 内存检测 内存分为内存泄露和内存开销 FPS监控 解决问题优化业务流程合理的线程分配预处理和延时加载缓存正确API的使用预防问题","categories":[],"tags":[{"name":"iOS 优化","slug":"iOS-优化","permalink":"http://yoursite.com/tags/iOS-优化/"}]},{"title":"iOS RunLoop 深入理解","slug":"iOS-RunLoop-detail","date":"2018-04-09T10:23:53.000Z","updated":"2018-05-21T10:52:30.000Z","comments":true,"path":"2018/04/09/iOS-RunLoop-detail/","link":"","permalink":"http://yoursite.com/2018/04/09/iOS-RunLoop-detail/","excerpt":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关","text":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关 RunLoop 概念正常情况下一个线程只能执行一个任务，当任务完成了，线程也就退出了。那么如何才能确保我们的线程能够随时能够处理事件并且不退出，直到我们主动要求线程退出的时候就退出？ 答案是有的，这就是我们今天的主角：RunLoop 从字面意思上解析这是一个运行着的循环，我们大体实现下它的伪代码： function loop(){ initialize(); do{ var message = getMessage(); processMessage(message); }while{message != quit} } 从伪代码中我们可以大体的了解到其中的一些逻辑处理 RunLoop 的关键点在于：如何管理事件、消息，如何让线程在没有处理消息的时候休眠以避免资源的占用、在有消息的时候到来的时候能够能立即唤醒。 \b所以，RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行\bEvent Loop的逻辑。 线程执行了这个函数后，就会一直处于这个函数的内部“接受消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束，函数返回。 首先由一个入口函数的操作，在这里采用do…while的操作，首先先从消息队列中获取消息，当然如果没有消息的话，这个循环也是会一直发生的，因为我们还没有发送quit的消息。同时在我们有一个消息到来的时候，我们可以获取对应的消息来做处理。 总而言之就是一个一直运行着的事件循环操作 iOS中的RunLoop在 iOS 中为我们提供了两个这样的对象：NSRunLLoop 和 CFRunLoopRef CFRunLoopRef 是在CoreFoundation 框架中的，提供了纯C函数的API,所有的API都是线程安全的 NSRunLoop 是基于CFRunLoopRef 的封装，提供了面向对象的API,但是这些API是线程不安全的 下面我们从源码中来分析RunLoop: 1234567void CFRunLoopRun(void)&#123; int32_t result; do&#123; result = CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125;while(kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result)&#125; 下面再来分析下 CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); 首先回去CurrentMode CFRunLoopModeRef CurrentMode = __CFRunLoopFindMode(r1,modelName,false); 然后对currentMode进行判断 判断其是否存在或者是否为空 if(currentMode == NULL || __CFRunLoopModelIsEmpty){ return finish;//返回完成 就退出了runloop } 这里就是RunLoop结束的一个很重要的因素 下面我们在看看其中最重要的部分： if(currentMode-&gt;observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopEntry); result = __CFRunLoopRun(r1,currentMode,seconds,returnAfterSourceHandled,previousMode); if(currentMode-&gt;observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopExit); 下面借鉴网上的博客资源分析下：（采用伪代码）参照123456789101112131415161718192021222324252627282930313233343536373839404142int32_t __CFRunLoopRun()&#123;//通知即将进入runloop__CFRunLoopDoObservers(kCFRunLoopEntry);do&#123;//通知将要处理timer和source__CFRunLoopDoObservers(kcfrunLoopBeforeTimers);__CFRunLoopDoObservers(kCFRunLoopBeforeSources);//处理非延迟的主线程调用__CFRunLoopDoBlocks();//处理source0事件__CFRunLoopDoSource0();if(sourceHandledThisRoop)&#123; __CFRunLoopDoBlocks();&#125;//如果有Source1 (基于Port) 处于ready状态，直接处理这个Source1 然后跳转去处理消息if(__Source0DidDispatchProtLastTime)&#123; Boolean hasMsg = __CFRunLoopServiceMachPort(); if(hasMsg)&#123; goto handle_msg; &#125;&#125;//通知 Observers 线程即将进入休眠if(!sourceHandledThisRoop)&#123; __CFRunLoopDoObservers(runloop,currentMode,KCFrunLoopBeforeWaiting);&#125;//GCD dispatch main queueCheckIfExistMessagesInMainDispatchQueue();//即将进入休眠__CFRunLoopDoObservers(KCFrunLoopBeforeWaiting);//等待内核mach_msg事件mach_port_t weakUpPort = runloop 的概念一般来说一个线程在执行完后就会退出，如果我们想要一个机制，让线程能随时处理时间但并不退出，通常的代码逻辑是这样的： 12 实现这种模型的关键点在于：如何管理事件、消息，如何让线程在没有处理消息的\b时候休眠以处理消息休眠的时候避免资源占用、在有消息带来的时候立刻被唤醒。 所以RunLoop实际上即使一个对象，这个对象管理了其需要处理的事件和消息，并提供一个入口函数来执行上面的Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数的内部，“接受消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束，函数返回 RunLoop 和线程的关系苹果不允许直接创建 RunLoop ,它值提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunloopGetCurrent(). 这两个函数内部的逻辑大概是下面这样的： 12345678910111213141516171819202122232425262728293031323334353637// 一个全局的Dictionary key是pthread_t ,value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;// 访问 loopsDic \b时候的锁static CFSpinLock_t loopsLock;CFRunLoopRef _CFRunloopGet(pthread_t thread)&#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入的时候，初始化全局的DIC ,并先给主线程创建一个RunLoop loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunloopCreate(); CFDictionarySetValue(loopsDic,pthread_main_thread_np(),mainLoop); &#125; // 直接从 Dictionary 中获取 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic,thread); if (!loop) &#123; // 如果取不到loop 就创建一个 loop = _CFRunloopCreate(); CFDictionarySetValue(loopsDic,thread,loop); // 注册一个回调，当现场销毁的时候，顺便也销毁其对应的RunLoop _CFSetTSD(...,thread,loop,__CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125;CFRunLoopRef CFRunLoopGetMain()&#123; return _CFRunloopGet(pthread_main_thread_np);&#125;CFRunLoopRef CFRunloopGetCurrent()&#123; return _CFRunloopGet(pthread_self);&#125; 从上面的代码逻辑可以看出，线程和\bRunLoop 是一一对应的，其关系保存在全局的Dictionary中，线程在刚刚创建的时候并没有 RunLoop ，如你不主动获取的话，它是一直都不会有。 RunLoop的创建是发生在第一次获取的时候，RunLoop 的销毁是发生在线程结束的时候，你只能在一个线程的内部获取到它的 RunLoop .主线程的RunLoop除外。 RunLoop 对外接口在CoreFoundation 里关于RunLoop的有5个类 CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef 一个RunLoop中包含若干个Mode ,每个Mode又包含若干个Source/Timer/Observer 。每次调用RunLoop 的主函数的时候，只能指定其中一个Mode,这个Mode被称为CurrentMode. 如果要切换这个Mode只能退出Loop，再重新指定一个新的Mode进入，这样做是为了分隔开不同组的Source/Timer/Observer，让其互不影响 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1 . Source0 只包含了一个回调（函数指针），它并不能主动出发事件。使用的时候，需要先调用CFRunLoopSourceSignal(source) ,将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop ，让其处理这个事件。 Source1 包含了一个mach_port 和 一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种Source 能够主动唤醒RunLoop的线程 CFRunLoopTimerRef 是基于定时器的触发器，它和NSTimer 是toll-free bridged的可以混用。其包含一个时间长度和一个回调（函数指针） 。当其加入RunLoop的时候，会在RunLoop中注册对应的时间点，当时间点到了，RunLoop就会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个Observer 都包含了一个回调（函数指针），当RunLoop的状态发生变化的时候，观察者就能通过回调接收到这个变化，可以观测的时间点有以下几个： 123456789&gt; typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;&gt; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop&gt; kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer&gt; kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source&gt; kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠&gt; kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒&gt; kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&gt; &#125;;&gt; 上面的Source/Timer/Observer 被称为Mode item 一个Item 可以被同时加入到多个mode.但是一个item 被重复加入到同一个mode 是不会生效的。如果一个mode 里一个item都没有，则RunLoop 会直接退出，不进入循环。 RunLoop 的Model1234567891011121314struct __CFRunLoopMode&#123; CFStringRef _name; CFMutableSetRef _source0; CFMutableSetRef _source1; CFMutableArrayRef _observers; CFMutableArrayRef _timers;&#125;;struct __CFRunloop&#123; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes;&#125;; 这里有个概念叫“CommonModes” 一个Mode 可以将自己标记为“Common”属性，通过将其ModeName添加到RunLoop的commonModes中，每当RunLoop的内容发生变化的时候将RunLoop会自动将_commonModeItems里的Source/Observer/Timer同步到具有“Common”标记的所有Mode里 CFRunLoop对外提供了管理Mode的接口： 12CFRunLoopAddCommonMode(CFRunLoopRef runloop,CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName,...); Mode暴露的管理Mode item的接口 有下面几个： 1234567891011CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode); 你只能通过\bmode name 来操作内部的 mode,当你传入一个新的mode name但是RunLoop 内部没有对应的mode的时候，RunLoop 会自动帮你创建对用的CFRunLoopModeRef .对于一个RunLoop 来说，其内部的mode 只能增加不能删除 RunLoop 的Source首先先看下官方的RunLoop结构图： 结合RunLoop的核心运行流程可以看出Soucre0(复杂APP内部事件，又APP负责管理出发，例如：UITouch事件)和Timer(又叫Timer Source 基于事件的出发器，上层对应NSTImer)是两个不同的RunLoop事件源。runloop 被这些事件唤醒后，就会处理并调用事件处理方法（CFRunLoopTimerRef 的回调）\u001c ，但是对于RunLoopSoureRef 除了Source0之外还有另一个版本就是Source1 ,Source1 除了包含回调指针外还包含了一个mach port 和Source0 需要手动触发不同，Source1可以监听系统端口和其他线程相互发送消息，它还能够主动唤醒RunLoop RunLoop 的内部逻辑根据苹果文档的说明，RunLoop 内部的逻辑大致如下： 内部代码整理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void CFRunLoopRun(void)&#123; CFRunLoopRunSpecific(CFRunloopGetCurrent(),kCFRunLoopDefaultMode,1.0e10,false);&#125;// 用指定的Mode启动 ，允许设置RunLoop 的超时时间int CFRunLoopRunInMode(CFStringRef modeName,CFTimeInterval seconds,Boolean stopAfterHandle)&#123; return CFRunLoopRunSpecific(CFRunloopGetCurrent(),modeName,seconds,stopAfterHandle);&#125;// RunLoop 的实现int CFRunLoopRunSpecific(runloop,modeName,seconds,stopAfterHandle)&#123; //首先通过mode name 获取mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop,modeName,false);// 如果当前的mode是\b空的，直接退出 if (__CFRunLoopModelIsEmpty(currentMode)) &#123; return; &#125;// 1.通知 Observer： RunLoop 即将进入 loop __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopEntry);// 内部函数 ，进入Loop __CFRunLoopRun(runloop,currentMode,seconds,returnAfterSourceHandled)&#123; Boolean sourceHandledThisRoop = NO; int retVal = 0; do &#123; // 2. 通知Observer : RunLoop 即将触发Timer的回调 __CFRUnLoopDoObservers(RunLoop,currentMode,kCFRunLoopBeforeTimers); // 3. 通知 \bObservers ； RunLoop 即将触发Source0的回调 __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopBeforeSources); // 执行被加入的Block __CFRunLoopDoBlocks(runloop,currentMode); // 4.RunLoop 触发 Source 0的回调 sourceHandledThisRoop = __CFRunLoopDoSource0(runloop,currentMode,stopAfterHandle); // 执行被加入的block __CFRunLoopDoBlocks(runloop , currentMode); // 如果有Source1处于ready的状态，直接处理这个Source1 ,然后调转到处理消息 if (__Source0DidDispatchProtLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort,&amp;msg); 8 &#125; // 通知Observer RunLoop 即将进入休眠 if (!sourceHandledThisRoop) &#123; __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopBeforeWaiting); &#125; // 调用 mach_msg 等待接收mach_port的消息，线程讲江入休眠，直到下面某一个时间唤醒 // 一个基于port 的Source 的事件 // 一个Timer到时间了 // RunLoop 自身的超时时间到了 // 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet,&amp;msg,sizeof(msg_buffer),&amp;livePort)&#123; mach_msg(msg,MACH_RCV_MSG,port); &#125; // 通知 Observers: RunLoop 的线程刚刚被唤醒了 __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopAfterWaiting); // 9 收到消息，处理消息 handle_msg; // 9.1 如果消息是一个Timer ，触发这个timer的回调 if (msg_is_timer) &#123; __CFRUNLoopDoTomers(runloop,currentMode,mach_absoult_time()); &#125; // 9.2 如果有dispatch 到 main_queue 的block ,执行block else if (msg_is_dispatch)&#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; // 9.3 如果一个Source1 (基于port)发出的事件了，处理这个事件。 else&#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceFor马车Port（runloop,currentMode,liveport）; sourceHandledThisRoop = __CFRunLoopDoSource1(runloop , currentMode,source1,msg); if (sourceHandledThisRoop) &#123; mach_msg(reply , MACH_SEND_MSG,reply); &#125; &#125; // 执行加入到Loop 的block __CFRunLoopDoBlocks(runloop , currentMode); if (sourceHandledThisRoop &amp;&amp; stopAfterHandle) &#123; // 进入loop的时候参数说处理完事件就返回 retVal = KCFRunLoopHandledSource; &#125;else if(timeout)&#123; // 超出传入参数标记的\b超时时间 retVal = KCFRunLoopRunTimedOut; &#125;else if(__CFRunLoopIsStopped(runloop))&#123; // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125;else if(__CFRunLoopModelIsEmpty(runloop ,currentMode))&#123; // source、timer/observer 一个都没有 retVal = kCFRunLoopRunFinished; &#125; // 如果没有超时，mode没有为空 loop也没有停止 那就继续loop &#125;while&#123;retVal == 0&#125;; &#125; // 通知Observer RunLoop 即将退出 __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopExit);&#125; 通过上图和\b代码的说明我们可以比较清楚的了解runloop内部的流程操作， RunLoop 休眠其实对于RunLoop 最核心的地方是在于保障了在没有消息的时候休眠以避免占用系统的\b资源，有消息的时候能够及时唤醒处理消息。RunLoop 的这个机制完全依靠系统内核来完成的，具体来时候苹果系统核心组件Drawin中的mach 来完成的。 和其他架构不同的是Mach对象间不能直接调用，只能通过消息传递的方式来进行通信。“消息”是Mach中基础的概念，消息在两个端口之间传递，这就是Mach 的IPC 的核心 Mach 提供了进程间通信，处理器调度等基础服务，在Mach中，进程，线程间的通信以消息的方式来完成，消息在两个port之间进行传递（这也正是Source1之所以称为Port-based Source）的原因，因为它是依靠系统发送消息来指定的Port来出发\b的，消息的发送和接收使用mach/message中的Mach_msg（）函数。 Mach 的消息定义在&lt;mach/message.h&gt; 头文件中： 12345678910111213typedef struct&#123; mach_msg_header_t header; mach_msg_body_t body;&#125;mach_msg_base_t;typedef struct&#123; mach_msg_bits_t\b msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125;mach_msg_header_t； 一条Mach 消息实际上就是一个二进制的包（BLOB）,其头部定义了一个当前端口local_port和目标端口 remote_port 发送和接收消息是通过同一个API进行的，其option标记了传递方向 123456789mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcg_name, mach_msg_timeout_t timeout, mach_port_name_t notifiy); match_msg（）的本质是一个调用mach_msg_trap()，这相当于一个系统调用，会出发内核状态切换，当程序精致的时候，RunLoop 停留在 __CFRunLoopServiceMachPort()的方法中，这个函数就是调用了mach_msg 让程序处于休眠状态 RunLoop 提供的接口这里讲解下NSRunLoop 的API 属性1234567// 获取当前的runloop@property (class, readonly, strong) NSRunLoop *currentRunLoop;// 获取到主线程的 runloop@property (class, readonly, strong) NSRunLoop *mainRunLoop API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 获取到\brunloop 的当前的mode@property (nullable, readonly, copy) NSRunLoopMode currentMode; 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 为mode 添加timer item-(void)addTimer:(NSTImer *)timer forMode:(NSRunLoopMode) mode;// 给mode tianj 一个Port-(void) addPort:(NSPort *)aPort forMode:(NSRunLoopMode )mode;// 从mode 中移除 port-(void)removePort:(NSPort *)aPort forMode:(NSRunLoopMode)mode;//-(nullable NSDate *)limitDateForMode:(NSRunLoopMode)mode;-(void)acceptInputFor\bMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;-(void)run;-(void) runUntilDate:(NSDate *)limitDate;- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate*)limitDate;/// Schedules the execution of a block on the target run loop in given modes./// - parameter: modes An array of input modes for which the block may be executed./// - parameter: block The block to execute- (void)performInModes:(NSArray&lt;NSRunLoopMode&gt; *)modes block:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));/// Schedules the execution of a block on the target run loop./// - parameter: block The block to execute- (void)performBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));/**************** Delayed perform ******************/@interface NSObject (NSDelayedPerforming)- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;@end@interface NSRunLoop (NSOrderedPerform)- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target;@end 实例的运用APP 启动 RunLoop12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061CFRunLoop &#123; current mode = kCFRunLoopDefaultMode; common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0(manual) CFRunLoopSourceRef&#123;order = -1,&#123;callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order = -1,&#123;callout = PurpleEventSignalCallBack&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach_port) CFRunLoopSource &#123;order = 0,&#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order = -1,&#123;callout = PurpleEventCallBack&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;&#125;&#125; // Observers CFRunLoopObserver &#123;order = -2147483674 ,activities = 0x1, callout = _warpRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, callout = _UIGestureRecognizerUpdateObserver &#125; CFRunLoopObserver &#123;order = 1999000,activities = 0xa0,callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000 ,activities = 0xa0 ,callout = _ZN2CA11Transcation17Observer_callbackEP9——CFRunLoopObservermPV&#125; CFRunLoopObserver &#123;order = 2147483647 , activities = 0xa0 , callout = _warpRunLoopWithAUtoreleasepollHandler &#125; // timer CFRunLoopTimer &#123;firing = NO , interval = 3.1536E+09 ,tolerance = 0,next fire date = 453098071 (-4421),callout = _ZN2CAL14Timer_callbackEP16_CFRunLoopTimerPV(!uartZCore.framework)&#125; &#125; modes = &#123; CFRunLoopMode&#123; source0 = &#123;&#125;, source1 = &#123;&#125;, observers = &#123;&#125;, timers = &#123;&#125; &#125;. CFRunLoopMode &#123; source0 = &#123;&#125;, source1 = &#123;&#125;, observers = &#123;&#125;, timers = &#123;&#125; &#125;, CFRunLoopMode &#123; source0 = &#123;CFRunLoopSource &#123;order = 0,&#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, source1 = (null), observers = &#123; CFRUnLoopObserver &#123;activities = 0xa0 , order = 2000000 , callout = _ZN2CA11Transaction17Observer_callbackEP19_CFRunLoopObservermPV&#125; &#125;, timer = (null) &#125; &#125;&#125; 可以看出，系统默认注册了5个Mode1.KCFRunLoopDefaultMode :APP默认的Mode ,通常主线程是在这个Mode先运行的2.UITrackingRunLoopMode :界面追踪Mode ,用于ScrollView 追踪触摸滑动，保证界面滑动的时候不受其他Mode影响 UIInitializationRunLoopMode :在刚启动App的时候\b，进入的第一个Mode ，启动完成后就\b不再使用了 GSWventReceiveRunLoopMode : 接受系统事件内部的Mode,启动完成后就不再使用5.KCFRunLoopCommonMode :这是一个占位的Mode ,没有实际的作用 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; 检测当前runloop的操作AutoRelease 原理APP 启动的时候，苹果在主线程的RunLoop 里会注册两个Observer, 其回调都是_wrapRunLoopWithAutoreleasePoolHanler(). 第一个Observer 监视的时间是Entry ，其回调内部会调用 _objc_autoreleasePoolPush() 创建自动释放池，其order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个Observer 监视两个事件，BeforeWaiting（准备进入休眠）的时候调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新的池 Exit(即将退出Loop)的时候调用 _objc_autoreleasePoolPop() 来释放自耦东释放池，这个Observer 的order 是2147483647 ，优先级最低，保证其释放池发生在其他回调之后 通常在主线程执行的代码，通常\b是写在注入事件回调，Timer 回调中，这些回调会被RunLoop 创建好的AutoReleasePool 环绕着，所以不会出现内存泄露。 事件响应 苹果注册了一个Source1 (基于mach_port)的，用来接收系统事件，其回调函数为_IOHIDEventSystemClientQueueCallback(); 当一个\b硬件事件发生后，首先IOKit。farmwork生成一个IOHIDEvent事件并由SpringBoard接收，这个过程的详细情况可以参考这里。SpringBoard只接收（锁屏/静音）触摸，加速。接近传感器的几种Event,随后使用mach port 转发给App的进程。随后苹果注册的Source1 就会触发回调，并调用_UIApplicationHanleEventQueue() 进行应用内部的分发 _UIApplicationHanleEventQueue() 会把IOHIDEvent 处理并包装成UIEvent进行处理或分发，其中包括事变UIGuest/处理屏幕旋转/发送给UIWindow等，通常事件比如UIButton点击，touchsBeigin/move/end/cache事件都是在这个回调中完成的 GCD和RunLoop的关系 在RunLoop的源代码中可以看到用到了GCD相关的内容，但是RunLoop本身和GCD并没有什么直接的关系，当调用了dispatch_async(dispatch_get_main_queue(),block)的时候，libDispatch会向主线程RunLoop发送消息唤醒RunLoop，RunLoop从消息中获取block,并且在CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE里调用这个block,不过这个操作仅限于主线程，其他线程dispatch操作全部是由libDisoatch驱动的 内存检测工具FPS 工具","categories":[],"tags":[{"name":"iOS RunLoop","slug":"iOS-RunLoop","permalink":"http://yoursite.com/tags/iOS-RunLoop/"}]},{"title":"2018个人计划","slug":"what-to-do-for-2018","date":"2018-04-04T10:29:56.000Z","updated":"2018-04-04T01:23:11.000Z","comments":true,"path":"2018/04/04/what-to-do-for-2018/","link":"","permalink":"http://yoursite.com/2018/04/04/what-to-do-for-2018/","excerpt":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！","text":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！ 组件化的完善","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"iOS中Block的运用","slug":"block-use-method","date":"2018-04-04T02:06:28.000Z","updated":"2018-04-23T10:23:55.000Z","comments":true,"path":"2018/04/04/block-use-method/","link":"","permalink":"http://yoursite.com/2018/04/04/block-use-method/","excerpt":"摘要： 关于block的简单描述和使用概述","text":"摘要： 关于block的简单描述和使用概述 block的概述 Block：带有自动变量的匿名函数匿名函数：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域 语法： 声明： 返回值(^名称)(参数列表) typedef int(^ClickBlock)(NSUInteger); -(void)justAClick(ClickBlock)block{ NSLog(@&quot;Param:%@&quot;,block); } 定义： ^返回值类型(参数列表){表达式} ^(NSUInteger count){ //这里是代码展示区 return count + 1; } 自动变量 Block可以截获所使用的自动变量的值； 截获：保存自动变量的瞬间值 因为是瞬间值，所以Block之后，即便Block外面修改自动变量的值，也不会对Block内部有影响 如果需要对其的改变也会对变量产生影响的话，需要在变量的前面增加 __block block的运用 在我们的代码中，经常会用到block，其中涉及到了很多方面，下面我们将列举一些比较常见的用法和大家分享。分别是链式编程、返回参数、获取信息等。如果后续还有新的会增加。 链式编程这个在我们很多地方我们应该都能够看到（这里针对OC），比如Masonry,还有BabyBluetooth的使用方面都会涉及到链式编程 Masonry: make.top.equalto(self).offset(100); BabyBluetooth: baby.connecttoPeripherals().start(); 这样给人的感觉相对比较流畅和简洁很多。 首先先针对点式操作： 在OC中点语法就是一种语法糖，最终会调用对用属性的getter/setter的方法。 -(NSString*)hello{ return @&quot;hello&quot;; } self.hello; //会报 Property Access result unused; 我们让它的结果利用就来就不会报警告了 OK,针对点语法我们已经大概了解了，下面就针对链式中，为什么能够实现链式呢？ 这就得从返回值上做文章了，首先我们可以肯定返回值肯定是自身，要不然的话，就无法调用后续的函数进行操作了。 -(Test*)hello{ return self; } self.hello.hello; 这时候如果我们需要附带参数要如何实现： 很简单 block 动起来 -(Test*(^)(NSString*))hello{ return ^(NSString* str){ self.hello = str; return self; } } self.hello(@&quot;hello&quot;).hello(@&quot;str&quot;); NSLog(self.hello); 返回参数 参数的返回：很容易理解，就应该是利用返回值，来做判断的操作，或者利用返回值的数据，来进行一些操作。比如我们比较常用的UITabelView中针对Deletege 中的很多 比如rowCount //tableViewItem typedef NSUInteger (^CellCountBlock)(void); -(void)tableViewConfig{ if(self.CellCountBlock){ NSUInteger countNum = self.CellCountBlock(); NSLog(@&quot;the countNum is %d&quot;,countNum); } } //ViewController [tableViewItem tableViewConfig]; tableViewItem.CellCountBlock = ^{ return 10; } 当然这里我们也可以采用链式编程的方式来进行！ 获取信息 信息的获取：我们主要是在文件上传的时候可以看到关于fromData的拼接 - (NSMutableURLRequest*)multipartFormRequestWithMethod:(NSString*)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error { __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (block) { block(formData); } return [formData requestByFinalizingMultipartFormData]; } 这里将重要的代码贴出来： 这里的formData 数据是将数据的拼接防盗调用方进行拼接的，拼接完成后再将数据进行上传操作 所以这里的formData就是我们的重点 -(void)tableViewConfig:(void(^)(NSDictionary *))configBlock{ __block NSMutableDictionary *config = [NSMutableDictionary dictionaryWithCapacity:0]; if (configBlock) { configBlock(config); } NSLog(@&quot;the config is %@&quot;,config); } //使用 [[GYEBleManager shareManager] tableViewConfig:^(NSDictionary *config) { [config setValue:@&quot;hello&quot; forKey:@&quot;key&quot;]; }]; //结果： the config is { key = hello; } 链接： https://www.wangjiawen.com/ios/ios-block-usage-and-implementation https://www.jianshu.com/p/23c1bbe3c99d","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"如何构建一个Github的博客","slug":"how-to-build-github-blog","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-04T01:26:00.000Z","comments":true,"path":"2018/03/29/how-to-build-github-blog/","link":"","permalink":"http://yoursite.com/2018/03/29/how-to-build-github-blog/","excerpt":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你","text":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你 这里先列出大概的要点： Git的安装 Node.js的安装 Hexo 的安装和配置 Hexo 的发布和测试 Git安装 这里暂时没有涉及到后续补充 Node.js的安装Hexo的安装和配置Hexo 的安装npm install -g hexo-cli //全局安装hexo的客户端 如果不成功的话可以加上sudo 当这个执行成功后可以使用 hexo -v //查看是否安装成功 hexo 的初始化hexo init //这里可以针对具体的文件夹进行初始化操作 npm install //安装相对应的依赖包 hexo 框架简介 当hexo init 执行完成后，在当前的文件夹会增加框架的目录结构： _config.yml //网站的配置信息 package.json //项目包信息 scaffolds //模板文件夹，hexo 根据scaffold中的模板来新建文件 source //存放用户资源的地方 _drafts //存放草稿的地方_posts //存放发布的文件 themes //主题文件夹 hexo 简单配置首先我们需要打开_config.yml文件,这里是hexo的主要配置文件： 这里可以参考Hexo配置 title: lmzqm //网站标题 subtitle: iOS 开发者 //网站副标题 description: just do it //网站描述 keywords: //网站的关键字 author: lmzqm //您的名字 language: zh-CN //网站使用的语言 timezone: Asia/Shanghai //网站时区 hexo 命令下面简单介绍下hexo的命令： hexo generate //简写 hexo g 生成静态文件，会在当前的目录下生成一个新的public的文件夹 hexo server // 简写 hexo s 启动本地服务器，通过http://localhost:4000进行访问 hexo deploy // 简写 hexo d 部署到远程，在_config.yml中配置 hexo new post-name //简写 hexo n post-name 新建文章 hexo new page page-name //简写 hexo n page page-name 新建页面 会在Source下新建一个相对应的目录 组合命令： hexo s -g //生成和预览 hexo d -g //生成和部署 草稿命令： hexo new draft &lt;title&gt; //新建草稿，存放在source/_drafts hexo public post &lt;title&gt; //发布操作草稿文章，文章将转移到source/_posts hexo s -g // 可以开始进行预览操作 部署到GitHub pages 部署Hexo到GitHub 指的是将hexo -g生成的静态文件推送到github 对应的仓库中 因此我们需要在我们GitHub中做好相对应的准备 首先需要明确的是： 每一个github的账号都有一个GitHub的pages; 一个账号只能创建一个repository来存放GitHub pages; 仓库的名字必须是username/username.github.io 这是固定的命名约定 然后就可以通过 https://username.github.io 来进行访问 GitHub 创建的个人主页内容是在master分支下的 当你在你的github下创建了这个repository后，就可以在本地 先安装一个扩展： npm install hexo-deployer-git --save 修改 _config.yml中的配置： deploy: type:git repo:https://github.com/username/username.github.io.git branch:master 这样的话就可以通过执行 hexo d -g 将静态网站提交到github网站上 hexo 主题首先关于hexo的主题可以在github中进行查找，很方便就能找到一些主题，然后可以选择你所需要的主题，关于主题内部的具体配置，可以参照具体的网站来进行配置。 hexo clean //clean remove generated files and cache 然后就可以选择你自己想要的主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这个完成后需要在根目录下的_config.yml中将主题变换成我们现在的主题： theme: yilia 这时候在theme的文件夹下就可以就会多出一个文件夹yilia着是主题的文件夹，进入后可以用git来进行操作，切换tag来针对不同的版本，当然对于不同版本的具体要求对应的网站上去查看下详情会比较好理解 后期针对主题的设置，我们需要进入到相对应主题当中的_config.yml文件进行配置 这个可以在网上找到很多信息 后期我们再专门弄个文章来进行阐述，这里就暂时先简单描述","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"MarkDown 的基础使用","slug":"Markdown-leaning","date":"2018-03-29T10:29:56.000Z","updated":"2018-05-09T01:44:18.000Z","comments":true,"path":"2018/03/29/Markdown-leaning/","link":"","permalink":"http://yoursite.com/2018/03/29/Markdown-leaning/","excerpt":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------","text":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------ 使用#来表示字号，可以使用1-6级标题来进行表示 #一级标题##二级标题###三级标题 效果： 一级标题二级标题三级标题四级标题五级标题 段落 段落的前后需要有空行，所谓的空行是指没有文字的内容，使用两个以上的空格加上回车键就可以达到段落的效果 区块的操作在段落的每行或者只要在第一行中使用符号&gt;就可以使用区块，当然还可以使用多个嵌套 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符 void main(){ printf(&quot;hello world&quot;); } 代码区块 需要和普通的段落之间存在空行 强调在强调的内容两侧分别加上*或者_,比如： *斜体* **加粗**_斜体_ __加粗__ 效果： 斜体 _斜体_ 加粗 加粗 列表无序列表使用*、+、-这几个号码来进行列表 第一项 第二项 第三项 有序列表使用数字加上英文的句号eg:121.第一行2.第二行 第一行 第二行 分割线采用三个或者三个以上的*,_,-就可以构建分割线了 链接链接有两种形式生成：行内式和参考式 [链接](http://www.baidu.com) 这就是是链接的使用方式了 图片添加图片的形式和链接的形式相似，值需要在链接的基础上前方加上一个！就可以了 ![alt text](/path/to/img.jpg) 下面阐述下这个： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着是一个普通括号，里面放上图片的网址，左后要用 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其他意义的符号，可以利用反斜杠来显示一些在markdown中存在语法的字符","categories":[],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]}