{"meta":{"title":"lmzqm","subtitle":"iOS 开发者","description":"just do it","author":"lmzqm","url":"http://yoursite.com"},"pages":[{"title":"iOS","date":"2018-04-02T01:49:22.000Z","updated":"2018-04-02T01:49:22.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"Git学习记录","slug":"git-learning-detail","date":"2018-08-15T02:42:34.000Z","updated":"2018-08-25T09:22:50.000Z","comments":true,"path":"2018/08/15/git-learning-detail/","link":"","permalink":"http://yoursite.com/2018/08/15/git-learning-detail/","excerpt":"摘要： 这里针对的是git 命令的一些学习,慢慢深入，慢慢学习","text":"摘要： 这里针对的是git 命令的一些学习,慢慢深入，慢慢学习 分支分支的使用，意味着你可以把你的工作从开发主线程上分离开来，以免影响开发主线。 Git 保存的不是一个文件的的变化或者差异，而是一系列不同时刻的文件快照。 提交对象在进行提交操作的\b时候，git 会保存一个提交\b对象。——这个对象包含一个指定暂存内容的快照\b的指针。同时还包含了作者的姓名和邮箱，提交的时候输入的信息，以及指向它的\b父对象的指针。而由多个分支合并后产生的提交对象有多个父对象。 暂存操作暂存操作会为每一个文件计算校验和，然后把当前版本的\b文件快照保存到git的\b仓库中(git 使用blob对象来保存它们)最终将校验和加入到暂存区域等待提交。 提交操作123$ git add README test.rb LICENSE$ git commit -m &quot;The initial commit of my project&quot; 当使用 \bgit commit 进行提交操作后，Git 会先计算每一个子目录的校验和，然后在Git 仓库中这些校验和保存为树对象，随后创建一个提交对象，它处理包含上面提到的信息外，还包含这个树对象的指针。如此一来，Git 就可以在需要的时候重现\b这次保存的快照。 现在Git仓库中有5个对象。三个blob对象（保存文件快照），一个树对象（记录目录结构和blob对象索引），一个提交对象（包含着执行前述树对象和所提交的信息） 如果在这个提交的基础上，做了些修改，那么这次提交对象就会包含上次提交对象（父对象）的指针。 分支操作Git 的分支就是指向提交对象的可变指针。Git 的默认分支的名称是master 。在对此提交操作后，你其实已经有一个指定最后那个提交对象的master 分支了，它会在每一次你提交的时候自动的向前移动。 note: Git 的 “master” 分支不是一个特殊的分支。它只是和其他分支没有任何的区别。之所以每一个仓库都有master 的分支，是因为 git init 的时候默认创建它，并且大多数都懒得去改动。 分支创建既然有了分支的概念，那么我们如何新建\b一个分支，新建一个分支后，在git 又是如何体现的呢？ 12git brach testing // 在当前的基础上，创建一个testing 的分支 这样的话，我要做代码的修改，那是在那个分支上做了修改呢？有一个名为HEAD 的特殊指针，他是一个指向当前所在的本地分支。git branch 命令仅仅创建一个新的分支，并不会自动切换到新的分支中去。 分支切换要切换一个已有的分支，你需要通过 git checkout testing 这样 HEAD 就指向了 testing 分支了 HEAD 指向当前所在的分支 通过再次提交后，能够更清楚的看清楚 12$ vim test.rb$ git commit -a -m 'made a change' HEAD 分支随着提交操作自动的向前移动 如图所示：你的testing分支向前移动，当时你的 master分支并没有。它仍然指向当时\bcheckout 时候所指的对象 然后我们切换回master 分支看看 1$ git checkout master 可以看到 HEAD 又回到的 Master 上。 这条命令做了两件事情：\b一是使HEAD \b回到了Master 分支上，二是将工作目录恢复成 master分支所执行的快照内容。也即使所你现在做修改的话，项目将开始于一个比较旧的版本。本质上来说，这是忽略testing 分支所做的修改，便于你向另一个方向开发。 如果这时候我们做一个修改并提交 123$ vim test.rb$ git commit -a -m 'made other changes' 可以看到这时候产生了分叉，你可以在不同的分支上进行来回的切换和工作，并在时机成熟的时候，将他们合并起来，而这所有的工作，你需要的命令就是 branch checkout commit 可以使用 git log --oneline --decorate --graph --all 来进行查看分支的操作 12345678910111213141516171819* 5f8b11d Merge branch 'master'|\\| * f07063c fix bug| * ddd1f1b 提示语更新* | 2ffb4c7 修改AP接入界面和操作流程* | c1f3ae6 (V1.0.1) 增加AP模式设备连接wifi的界面* | c51e321 增加ca.cer文件|/* 4945881 (V1.0.0) 处理加载提示无法退去的bug* 7af7fd1 Merge branch 'master'|\\| * 397d653 更新了服务协议| * f77b0ee fix bug| * a724eeb UI调整* | fbc89b4 增加消除查看历史数据中一直加载的操作* | a9c2b0b 修改相关提示语句|/* 92df303 修改没有的提示语 打标签 打标签，在我的开发过程中主要是针对于 比如说版本发布了，然后记录下该版本的在 git 中是的时期，也就是将当时的打包的代码进行一个标定 。比如我V1.0 版本的提交，这时候的代码就是V1.0的代码，所以我需要针对这个版本放一个tag ，当然用分支处理也是可以的。tag \b能更好的和分支做区分操作。 列出标签 在 Git 中列出已有的标签非常简单直观。只需要输入 git tag: 12git tagV1.0 这个命令以字母的顺序列出标签；但是他们出现的顺序并不重要 也可以使用特定的模式来查找标签：git tag -l ‘V1.*’ 创建标签 Git 有两种重要类型的标签，轻量标签和附注标签 一个轻量标签很像是一个不会改变的分支 - 它只是一个特定提交的引用 然而，附注标签是存储在Git 数据库中一个完整的对象，他们是可以被校验的。其中包含打标签的名字、电子邮件地址、日期时间。还有一个标签信息。通常建议创建附注标签，这样可以拥有以上信息，但是如果你只想用一个临时的标签或者因为某种原因不想保持那些信息，轻量标签也可以用的。 附注标签 在Git 中创建一个附注标签很简单，最简单的方式是运行 tag命令的时候指定 -a选项 123$ git tag -a V1.0.1 -m \"Apple Store 1.0.1 版本发布代码\"$ git tagV1.0.1 -m 选项是指定一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入 通过使用 git show命令可以查找到标签信息 123456$ git show V1.0.1tag V1.0Tagger: xxxxxxx &lt;xxxxxxxxxx@xxxxxx.com&gt;Date: Wed Aug 15 10:13:08 2018 +0800Apple Store 发布V1.0.1 轻量标签 另一种给提交打标签的方式是使用轻量标签，轻量标签的本质是将提交校验和存储到一个文件中-没有保存任何其他信息。创建轻量标签，不需要使用 -a,-s或 -m 选项，只需要提供标签的名字： 1$ git tag V1.0.1 后期打标签 你可以对\b过去的提交打标签，假设提交历史是这样的： 1234567891011$ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在假设你需要对 \badded a commit function 提交打标签，你可以在命令的尾部加上提交的校验和 12$ git tag -a V1.0.2 0b7434d86 -m \"备注信息\"$ git tag -l 共享标签 默认情况下，\bgit push命令并不会传送标签到\b远程仓库服务器上。在创建完标签后你必须显示的推送标签到共享服务器上，这个过程就像共享远程分支一样 _ 你可以用git push orign [tagname]. 1234567$ git push origin V1.0Counting objects: 1, done.Writing objects: 100% (1/1), 180 bytes | 180.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To xxxx.xxxxx.com:apps/xxxxxxx.git* [new tag] V1.0 -&gt; V1.0 当然如果你\b想要一次性推送\b很多标签，可以使用 --tags选项的git push 命令,这将会把所有的不在远程仓库上的标签都全部传送到那里； 1$ git push origin --tags 检出标签 在Git 中你并不能真的检出一个标签，因为他们并不能像分支一样来回移动。如果你想要工作目录与长裤中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个分支 123456789101112131415 ➜ XXXXX git:(master) ✗ git checkout -b V1.0Verson V1.0 M XXXXX.xcworkspace/xcuserdata/lmzqm.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist M XXXXX/AppDelegate/AppDelegate.m M XXXXX/Login/Model/GYEExprortModel.m M XXXXX/Supporting Files/Info.plist M XXXXX/Supporting Files/en.lproj/Localizable.strings Switched to a new branch 'V1.0Verson' ➜ XXXXX git:(V1.0Verson) ✗ git branch V1.0.0 V1.0.1* V1.0Verson V1.1.0(english) master 当然了，如果你在之后又进行了一次提交 那么V1.0Verson 分支会因为改动先前移动了，那么V1.0Verson 就会和 V1.0 标签有些不同了 总结 关于git tag 的总结按照顺序： 首先我们要打个tag 但是tag 是不能重名的，所以可以先看下我们当前的tag git tag -l 可以查看到当前本地的tag ,然后我们可以通过 git tag -a tagname -m &#39;message&#39; \b这样就是打一个附注标签。 你可以通过 git show tagname来查找具体的情况。这里我们已经在本地打了一个tag ，所以我们当然也需要将我们的tag 推送到 远程服务器。可以使用git push origin [tagname] 这时候就可以将本地的tag 给传给远程服务。当然如果远程服务器有tag,本地没有的时候，这时候你需要检出tag,可以使用git checkout -b [bachName] [tagName]通过针对该tag 在本地创建一个分支 ，然后可以使用 git brach 来查看到新建的分支了.","categories":[],"tags":[{"name":"git 命令","slug":"git-命令","permalink":"http://yoursite.com/tags/git-命令/"}]},{"title":"iOS CoreGraphis","slug":"iOS-Core-Graph-Learning","date":"2018-08-14T06:38:09.000Z","updated":"2018-08-25T09:17:13.000Z","comments":true,"path":"2018/08/14/iOS-Core-Graph-Learning/","link":"","permalink":"http://yoursite.com/2018/08/14/iOS-Core-Graph-Learning/","excerpt":"摘要： 在iOS 系统中，关于绘画的操作主要是通过UIKit 和 CoreGraphics 来进行的。UIKit 是针对 CoreGraphics 来进行封装的。\b","text":"摘要： 在iOS 系统中，关于绘画的操作主要是通过UIKit 和 CoreGraphics 来进行的。UIKit 是针对 CoreGraphics 来进行封装的。\b 概述iOS的绘图系统 iOS 中的绘图框架有多种，平时我们\b最常用的是UIKit 这是经过对CoreGraphics 封装实现的，所以这样就比较容易使用，相对简洁，所以绝大多数图形界面都可以由UIkit 来进行完成。\b比如 123456789101112131415// 图片绘制操作 UIImage *image = [UIImage imageNamed:@\"\"]; [image drawInRect:CGRectMake(0, 0, 300, 100)];// 文字绘制操作 NSString *str = @\"hello world\"; UIFont *font = [UIFont systemFontOfSize:18]; NSDictionary *dict = @&#123;NSFontAttributeName:font,NSForegroundColorAttributeName:[UIColor whiteColor]&#125;; // 给字体添加 其他描述信息 [str drawInRect:CGRectMake(0, 0, 100, 20) withAttributes:dict]; 除了UIKit 还有CoreGraphics 和 CoreAnimation,Core Image,OpenGL ES 等多种框架，可以满足不同的绘画需求。 UIKit: 使用频率最高，高级版的OC图形接口，它能够访问绘图、动画、字体、图片等内容 缩写前缀为UI CoreAnimation:使用频率较高，提供了强大的2D和3D动画 缩写前缀为CA coreGraphics:使用频率中 ，基于C实现的 iOS 和 MAC OS X 的2D绘图引擎 缩写前缀为CG CoreImage:使用频率较低，图片的滤镜处理，比如高斯模糊，锐化等 缩写为前缀CI OpenGL ES:使用频率低，OpenGL 针对嵌入式设备的简化版本 用于绘制高性能的2D 和 3D 图形 说明： 图像的滤镜效果建议用优秀的第三方库GPUImage ，iOS 支持两套图形API族，Core Graphics和 OpenGL ES 他们都是基于C的API 框架 视图的绘制 和 视图的布局iOS 在RunLoop 中为图形的绘制 在BeforeWaiting 和 Exit\b的时候添加了Observer 12CFRunLoopObserver &#123;order = 2000000 ,activities = 0xa0 ,callout = _ZN2CA11Transcation17Observer_callbackEP9——CFRunLoopObservermPV&#125; 这个回调会遍历所有待处理的UIView/CALayer 以执行实际的绘制和调整任务，并更新UI 界面 12345678910111213_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 可以看到对当进入到BeforeWaiting 或者 Exit 的时候，会将所有的CA的操作进行一个提交的操作。这时候会调用 UIView drawRect 和 UIView layoutSubViews 所以这里就涉及到了：视图绘制 和 视图布局的操作 视图绘制调用UIView的 drawRect 方法；如果一个视图调用 12345UIView *graphView = [[UIView alloc] init];[self.view addSubview:graphView];[graphView setNeedsDisplay];[graphView setNeedsDisplayInRect:CGRectMake(0, 0, 100, 100)]; \b那么就会告诉系统该视图需要被重新绘制，真正的绘制会在下一次绘图周期的中调用drawRect的方法进行更新视图； 视图布局调用 UIView 中的layoutSubvies 方法。手动的触发可以使用 setNeedsLayout，但是如果视图中的子视图布局发生变化，需要重新排列的时候，UIKit 也会自动调用Set\bNeedsLayout 方法。也就是说 对于发生变化的视图 UIKit 相关绘图API 填充、描边、\b路径 123UIRectFill(&lt;#CGRect rect#&gt;)// 填充矩形函数UIRectFrame(&lt;#CGRect rect#&gt;)// 矩形描边函数UIBezierPath //绘制常见的路径类 UIImage 类中的绘制图像的主要方法 123456UIImage *image =[UIImage imageNamed:@\"\"];[image drawInRect:&lt;#(CGRect)#&gt;] ;// 图片绘制在指定的矩形里[image drawAtPoint:&lt;#(CGPoint)#&gt;];// 设置绘制的定点[image drawAsPatternInRect:&lt;#(CGRect)#&gt;];// 指定的区域中平铺绘制图片 NSString 类中绘制文本的主要方法 123456NSString *str = @\"helloworld\";UIFont *font = [UIFont systemFontOfSize:14.0f];NSDictionary *attributeDic = @&#123;NSFontAttributeName:font,NSForegroundColorAttributeName:[UIColor redColor]&#125;;[str drawInRect:CGRectMake(0, 0, 100, 100) withAttributes:attributeDic]; Core Graphics 绘图Core Graphics 中的绘图操作都是在一个上下文中操作的，也是是我们俗称的画布，在\b，所以在绘图之前的时候，必须获取该上下文，这是绘图任务的第一步； 概述Core Graphics 的图形上下文是CGContextRef 对象，相当于一块画布，以堆栈的形式存放，只有在栈顶的图形上下文上面绘制才有效果，图形上下文复制存储绘图状态(如 画笔颜色CGContextSetStrokeColorWithColor ,线条粗细CGContextSetLineWidth)和 绘制内容所存放的区域，获取上下文的方式有： 1234567891011121314151617181920212223// 根据指定的参数 获取图片上下文 UIGraphicsBeginImageContextWithOptions(CGSizeMake(100, 100), YES, [UIScreen mainScreen].scale); //获取当前的图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 从图片上下文中获取图片 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); //结束图片上下文的操作 UIGraphicsEndImageContext()： 下面提供一个将View 转变为 Image的操作 - (UIImage *)snapshotImage &#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, 0); [self.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *snap = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return snap; &#125; UIGraphicsBeginImageContextWithOptions 将旧的上下文入栈，为新的上下文分配内存，创建新的上下文，翻转坐标系统，并将其\b设置为当前上下文。（简洁的说：创建一个图形上下文，并将其设置为当前的上下文） 参数说明：size :新创建位图的尺寸opaque: 代表透明通道的开关，指定所生产的图片背景是否为不透明，YES 表示为不透明，图片背景是黑色。NO 表示透明；scale 表示缩放比例。传0 表示让图片的缩放因子等于屏幕的分辨率 UIGraphicsBeginImageContext(CGSize size) 创建一个基于位图的上下文，并将其设置为当前的上下文。效果相当于UIGraphicsBeginImageContextWithOptions(size,NO,0); UIGraphicsGetImageFromCurrentImageContext(void) 从当前上下中获取一个UIImage 对象，一般用于获取最终的绘制结果 UIGraphicsEndImageContext(void) 关闭图形上下文，一般在调用UIGraphicsGetImageFormCurrentImageContext之后\b调用 UIGraphicsGetCurrentContext 获得当前的图形上下文，可以在UIGraphicsBeginImageContextWithOptions/UIGraphicsBeginImageContext 或者在 UIView 的 drawRect：使用，以获取当前的图形上下文 iOS \b的绘图必须再一个上下文中绘制，所以在绘图之前一定要获取一个上下文，如果是绘制图片，就要获取一个图片的上下文，如果是绘制其他视图，就需要一个非图片上下文。对于上下文的理解，可以认为即使一个\b画布，然后在上面进行绘图操作 context:图形上下文，可以通过UIGraphicsGetCurrentContext 获取当前的视图上下文 imageContext：图片上下文，可以通过UIGraphicsBeginImgeContextWithOptions:获取一个图形上下文，然后绘制完成后，调用UIGrapahicsGetImageFromCurrentImageContext获取绘制的图片，最后要记得关闭上下文UIGraphicsEndImageContext; 绘图状态切换 和 上下文切换在绘图的过程中，有绘图状态的切换和上下文的切换，对应两组不同的函数 绘图状态切换1234CGContextSaveGState(ctc); // 存储当前上下文的绘图状态CGContextRestoreGState(ctc);// 返回之前上下文的绘图状态 在创建Core Graphics 图形上下文的时候，图形上下文中持有一个绘图状态的堆栈，这时候绘图状态堆栈是空的。通过 CGContextSaveGState 与 CGContextRestoreGState可以推入和弹出绘图的状态，实现绘图状态的切换，但是没有改变其图形上下文。 CGContextSaveGState将当前上下文的绘图状态，压入绘图状态堆栈中，而CGContextReStoreGState 是将绘图状态堆栈顶部的状态弹出，返回到之前的状态 那么这就有疑问了，那我这样做有什么用呢？ 首先需要看清楚，这里只是对绘图状态进行了压栈，但是并没有对上下文进行压栈，所以上下文还是可以用的，所以照样你还可以绘制操作，并不会有影响，只是出来这个状态后，绘制的状态变成了\b原来的\b入栈之前的状态而已 123456// \b绘图状态ACGContextSaveGState(ctc); // 存储当前上下文的绘图状态//绘图状态BCGContextRestoreGState(ctc);// 返回之前上下文的绘图状态//绘图状态A 这种推入和弹出的方式是回到之前状态的快速方法。避免\b一个一个撤销\b所有的\b状态。 上下文切换1234UIGraphicsPushContext(&lt;#CGContextRef _Nonnull context#&gt;)UIGraphicsPopContext() 通过上面的两个方法可以实现图形\b上下文的切换 UIGraphicsPushContext 将图形上下文压入图形上下文堆栈；当需要新建一个上下文做绘制工作的话，使用UIGraphicdPushContext 保存当前的图形上下文，在新的绘制图形上下文完成绘制工作后，私用UIGraphicsPopContext 恢复之前的图形上下文。 push: 将Context 压入栈中，并把context 设置为\b当前绘图上下文pop: 将栈顶的上下文弹出，恢复先前的上下文，但是绘图状态不变 123456789-(void)drawRect:(CGRect)rect&#123; // 这时候绘制出来的是蓝色的 [[UIColor redColor] setFill]; UIGraphicsPushContext(UIGraphicsGetCurrentContext()); [[UIColor blueColor] setFill]; UIGraphicsPopContext(); UIRectFill(CGRectMake(0, 0, 100, 100));&#125; 总结：1234567891011121314151617181920CGContextRef ctc = UIGraphicsGetCurrentContext();[[UIColor redColor] setFill];UIGraphicsPushContext(ctc);[[UIColor blueColor] setFill]; // 这里绘制出来的是蓝色的方块UIGraphicsPopContext();// 这时候是保留了上下文的状态UIRectFill(CGRectMake(0, 200, 100, 100));// 压入当前的绘画状态，仅仅是绘画状态不是绘图上下文CGContextSaveGState(ctc);[[UIColor yellowColor] setFill];UIRectFill(CGRectMake(150, 200, 100, 100)); // 这里绘制出来的是黄色的方块CGContextRestoreGState(ctc);UIRectFill(CGRectMake(300, 200, 100, 100)); // 这里绘制出来的是蓝色的方块 下面添加一个绘制圆形头像的操作 这是一个针对UIImage 的 Category 1234567891011121314151617181920UIGraphicsBeginImageContextWithOptions(CGSizeMake(100, 100), NO, 0);CGContextRef ctx = UIGraphicsGetCurrentContext();CGContextScaleCTM(ctx, 1, -1);CGContextTranslateCTM(ctx, 0, self.height);UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect: byRoundingCorners:UIRectCornerAllCorners cornerRadii:];// 绘制一个圆形[path closePath];CGContextSaveGState(ctx);[path addClip];CGContextDrawImage(ctx, rect, self.CGImage);CGContextRestoreGState(ctx);UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); iOS 绘图基础在绘图之前，\b需要先来了解下几个基本的概念 context 上下文 ，iOS 绘图的方法都乣传一个上下文 Context ,这个Context 在重写UIView 的drawRect的方法里面调用UIGraphicsGetCurrentContext()获取 path 路径，iOS 绘图可以想象为你拿着一支\b笔去画图，画几条线或者几个点从而形成一个路径，之后可以利用路径去填充或者描边 stroke,fill 描边 和 填充。每个路径都需要填充或者描边 才能在视图中看见，他们都各自有很多样式可以设置，常见的有颜色、粗细、渐变、连接样式等等； 画图可以使用默认的路径来话，也可以单独创建path 画图，对应画图的API 并不完全相同，是两组名称相似的API,两组api 常用的方法如下： 1CGContextMoveToPoint // 画图的一般步骤 获取上下文 绘制路径 \b描写或者填充路径 获取上下文 上下文 分为图片上下文，图形上下文 图片上下文，主要是针对图片进行处理的，图形上下文，中可以\b进行绘制，这样我们需要分开处理 路径绘制 这里需要调用针对路径的获取的操作 画线 画圆形 画\b弧线 画曲线 描写和填充路径 填充的方案 参考iOS绘图框架CoreGraphics分析iOS 札记2：Core Graphics小记iOS开发——Core Graphics绘图","categories":[],"tags":[{"name":"iOS CoreGraphics","slug":"iOS-CoreGraphics","permalink":"http://yoursite.com/tags/iOS-CoreGraphics/"}]},{"title":"iOS RunTime 详解","slug":"ios-runtime-detail","date":"2018-08-10T02:43:11.000Z","updated":"2018-08-10T03:00:25.000Z","comments":true,"path":"2018/08/10/ios-runtime-detail/","link":"","permalink":"http://yoursite.com/2018/08/10/ios-runtime-detail/","excerpt":"摘要： RunTime 在开发中经常会被使用到。首先针对OC 语言是一门动态的语言也称为运行时语言，所以很多东西都是在运行的时候才进行确认的。所以我们可以动态的给我们的类做一些操作。具体可以做什么操作呢？看看文章","text":"摘要： RunTime 在开发中经常会被使用到。首先针对OC 语言是一门动态的语言也称为运行时语言，所以很多东西都是在运行的时候才进行确认的。所以我们可以动态的给我们的类做一些操作。具体可以做什么操作呢？看看文章 概念 RunTime 简称运行时，就是系统在运行的时候的一些机制，其中最主要的是消息机制。 OC的函数调用称为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数。 只有真正运行的时候才会根据函数的名称找到对应的函数来调用。 类和对象在Objc中id 代表的是一个对象，根据上面的声明，凡是首地址是*isa 的struct 指针，都可以认为是\bobjc 对象，运行时通过isa指针，\b可以查找到对象属于什么类？ 运行时的实现方式 通过对类进行反编译后我们可以更加深入的了解类的内部结构，已经元类的结构有更加深入的了解 在类中是一个全局的变量，其中记录了类名，成员变量，属性变量，方法列表，协议\b列表等信息 在类中isa 指向了\b全局对象 meta-class ,只记录了类名和类的方法 NSObject 类在iOS 开发中，我们所有的都是对象 ，那我们的对象里面包含了哪些东西呢？或者说我们的对象有什么可以提供给我们操作的呢？ 123456typedef struct objc_class *Class;@interface NSObject &lt;NSObject&gt;&#123; Class isa OBJC_ISA_AVALIABILITY;&#125; 在面向对象的过程中都会有 类 和 对象 的概念，对象\b就是类的实例。通过上面的代码中我们可以看出在对象中包含了一个 Class isa。 那我们接下来分析下Class 123456789101112131415struct objc_class&#123; Class isa OBJC_ISA_AVALIABILITY; Class super_class OBJC2_UNAVALIABLE;//父类 \bconst char *name OBJC2_UNAVALIABLE;//类名 long version OBJC2_UNAVALIABLE;//类的版本信息 long info OBJC2_UNAVALIABLE;// 类的信息 long instance_size OBJC2_UNAVALIABLE;//类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVALIABLE;//类的成员变量列表 struct objc_method_list *methodLists OBJC2_UNAVALIABLE;//方法定义列表 struct objc_cache *cache OBJC2_UNAVALIABLE;// 方法缓存列表 struct objc_protocol_list *protocols OBJC2_UNAVALIABLE; // 协议列表&#125; 字段解释： isa 在\bOC中类的本身也是一个对象，类作为对象的时isa指向的是元类（\bMeta Class）。 super_class : 指向该类的父类，如果该类已经是根类，则super_class 为NULL cache ，用于缓存最近使用的方法。用于缓存最近使用的方法，从而避免每次调用方法都去查找对象的整个方法列表。 API在objc/runtime.h的文件中定义了RunTime使用的API 通过对这些API的学习，可以使我们更加了解和后期使用。 类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 返回方法的名称class_getName(Class _Nullable cls)// 判断是否是元类,通过返回一个BOOL值class_isMetaClass(Class _Nullable cls);// 返回该类的父类class_getSuperClass(class _Nullable cls)// 返回类的版本信息class_getVersion(class _Nullable cls)class_setVersion(Class _Nullable cls,int version)// 获取类的实例的大小class_getInstanceSize(Class _Nullable cls)// 根据指定的类 和 变量名称 返回实例的变量class_getInstanceVariable(class _Nullable cls,const char *_Nullable name)//class_getClassVariable(class _Nullable cls, const char * _Nullable name);// 描述由类声明的变量class_copyIvarList(Class _Nullable cls ,unsigned int * _Nullable outCount);// 通过类 和 SEL 来获取方法class_getInstanceMethod(Class _Nullable cls , SEL _Nonnull name);class_getClassMethod(Class _Nullable cls , SEL _Nonnull name);// 返回函数指针 这个函数指针是在想类发送特定的SEL的时候会调用的class_getMethodImplementation(Class _Nullable cls,SEL _Nonnull name);// 判断是否类的实例能能够响应一个特殊的SELclass_responseTOSelector(Class _Nullable cls,SEL _Nonnull sel);// 拷贝类中的方法列表class_copyMethodList(Class _Nullable cls , unsigned int *_Nullable outcount);// 判断一个类\b是否已经符合\b执行的协议class_conformsToProtocol(Class _Nullable cls , Protocol * _Nullable protocol);// 拷贝一个协议列表class_copyProtocolList(Class _Nullable cls , unsigned int * _Nullable outCount);// 通过给定的类 和 名称 返回对应的属性class_getProperty(Class _Nullable cls , const char * _Nonnull name);// 描述类所定义的属性class_copyPropertyList(Class _Nullable cls , unsigned int * _Nullable outCount); 属性123456789101112// 获取实例变量的名称 这是带_ivar_getName（Ivar _Nonnull v);//ivar_getTypeEncoding(Ivar _Nonnull v);ivar_getOffset(Ivar _Nonnull v);property_getName(objc_property_t _Nonnull property);property_getAttributes(objc_property_t _Nonnull property); 方法123456789101112131415161718192021222324struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; char * _Nullable method_types OBJC2_UNAVAILABLE; IMP _Nonnull method_imp OBJC2_UNAVAILABLE;&#125;// 返回方法的名字 SELmethod_getName(Method _Nonnull m);// 返回\b方法的实现method_getImplementation(Method _Nonnull m)；// 返回方法的返回的类型 包含参数method_getTypeEncoding(Method _Nonnull m);// 返回方法参数的个数method_getNumberOfArguments(Method _Nonnull m);// 返回方法的返回类型method_copyReturnType(Method _Nonnull m);// 两个方法实现的交换method_exchangeImplementations(Method _Nonnull m1,\bMethod _Nonnull m2); 运用方法\b交换1234567891011121314151617+（\bvo\bid）load&#123; SEL selOne = @selector(sendAction:to:forEvent); SEL selTwo = @selector(mySendAction:to:forEvent); Method methodOne = class_getInstanceMethod(self,selOne); Method methodTwo = class_getInstanceMethod(self,selTwo); BOOL isAdd = class_addMethod(self,selOne,method_getImplementation(methodTwo)，method_getTypeEncoding(methodTwo)); if (isAdd) &#123; class_replaceMethod(self , selTwo , method_getImplementation(methodOne),method_getTypeEncoding(methodOne)); &#125;else&#123; method_exchangeImplementations(methodOne,methodTwo); &#125;&#125; 自动归档解档12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma mark EnCoding-(void)encodeWithCoder:(NSCoder *)aCoder&#123; //编码 unsigned int count; Ivar *vars = class_copyIvarList([self class], &amp;count); for (int i = 0; i&lt; count; i++) &#123; Ivar var = vars[i]; NSString *key = [NSString stringWithUTF8String:ivar_getName(var)]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125;&#125;-(id)initWithCoder:(NSCoder *)aDecoder&#123; // 解码 self = [super init]; if (! self) &#123; return nil; &#125; unsigned int count = 0; Ivar *vars = class_copyIvarList([self class], &amp;count); for (int i = 0; i&lt; count; i++) &#123; Ivar var = vars[i]; NSString *key = [NSString stringWithUTF8String:ivar_getName(var)]; id Value = [aDecoder decodeObjectForKey:key]; [self setValue:Value forKey:key]; &#125; return self;&#125;后续的使用 可以结合 NSKeyedArchiver[NSKeyedArchiver archiveRootObject:books toFile:@\"FilePath\"];[NSKeyedArchiver unarchiveObjectWithFile:@\"FilePath\"]; 参考IOS开发之NSCoding协议（使用runtime） 字典 转 Model\b在和后台交互中经常会碰到这个问题，就是后天给我们的基本都是json的数据，然后我们通过将json的数据转换为数组或者字典的类型 ，然后\b与我们所\b构建的模块要进行匹配。 最初比较少的时候可能可以通过一一匹配的方法，来进行模型的构建，但是如果随着模块的增加，这样的方法，显然是不行的，比较耗费。 这里采用runTime的方法来进行实现 首先我们先构建我们的模块： 12345678910111213141516171819202122232425262728293031323334+(instancetype)GYE_objectWithDic:(NSDictionary *)dic&#123; id objc = [[self alloc] init]; // 首先需要获取属性 unsigned int count = 0; Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar var = ivarList[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(var)]; //因为获取的属性是带有有一个_value 的 key = [key substringFromIndex:1]; id value = dic[key]; NSString *propertyType = [NSString stringWithUTF8String:ivar_getTypeEncoding(var)]; if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![propertyType containsString:@\"NS\"]) &#123; NSRange range = [propertyType rangeOfString:@\"\\\"\"]; Class modelClass = NSClassFromString(propertyType); if (modelClass) &#123; value = [modelClass GYE_objectWithDic:value]; &#125; &#125; if(value)&#123; [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125; 动态的添加属性1234567objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy);objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)objc_removeAssociatedObjects(id _Nonnull object) 消息转发当一个对象能接收到一个消息的时候，会走正常的流程。但是如果一个对象无法接收到指定的消息的时候，会发生什么呢？ 动态方法解析 备用接受者 完整转发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 动态方法解析+(BOOL)resolveInstanceMethod:(SEL)sel&#123; // 这个处理的操作主要是在现有的方法中添加一个Method 将这个Selector 映射到处理的IMP 中 NSLog(@\"sel is %@\",NSStringFromSelector(sel)); if (sel == @selector(setName:)) &#123; class_addMethod([self class],sel,(IMP)dynamicMethodIMP,\"v@:\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void dynamicMethodIMP(id self,SEL _cmd)&#123; NSLog(@\"执行了这个代替的方法\");&#125;// 消息转发 备用接收者-(id)forwardingTargetForSelector:(SEL)aSelector&#123; // 该方法返回一个对象 也就说这个selector 交由这个对象来进行处理// 这个对象必须要实现对于的方法 要不然还是会报错的 NSString *selStr = NSStringFromSelector(aSelector); if ([selStr isEqualToString:@\"unknowMethod2\"]) &#123; return //返回一个对象就可以进行操作了; &#125; return [super forwardingTargetForSelector:aSelector];&#125;// 完整转发// 如果备用接收者还是不能处理好消息，那么接下来只有启动完整的消息转发机制// 这里需要进行对象的返回，如果采用ViewController 的话，可能会有影响// 就是这个方法获取的信息来创建NSInvocation 对象 因此必须重写这个方法-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;// 这里可以构建你的selector 操作 NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) &#123; if ([GYERunTimeMethodHelper instanceMethodForSelector:aSelector]) &#123; signature = [GYERunTimeMethodHelper instanceMethodSignatureForSelector:aSelector]; &#125; &#125; return signature;&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; //一个表示消息的NSInvocation 对象 将所有以尚未处理的消息细节封装在里面 包括：selector target 和参数 可以选择将消息转发给其他对象 // if ([GYERunTimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123; // [anInvocation invokeWithTarget:[[GYERunTimeMethodHelper alloc]init]]; // &#125; [anInvocation setSelector:@selector(selectorName)]; [anInvocation setArgument:&amp;debugInfo atIndex:2]; [anInvocation invokeWithTarget:[Object new]];&#125; 感谢Objective-C 的 Runtime","categories":[],"tags":[{"name":"iOS RunTime","slug":"iOS-RunTime","permalink":"http://yoursite.com/tags/iOS-RunTime/"}]},{"title":"iOS设计模式1:简单工厂方法模式","slug":"design-simple-factor-module","date":"2018-08-06T06:46:10.000Z","updated":"2018-08-25T09:23:16.000Z","comments":true,"path":"2018/08/06/design-simple-factor-module/","link":"","permalink":"http://yoursite.com/2018/08/06/design-simple-factor-module/","excerpt":"摘要： 设计模式 简单工厂 这个的用途还是很\b广的。它将生产和消费 进行了隔离，用户不需要关系它是如何生产的，只负责从工厂从获取就可以了，然后执行其消费的操作。这样将两者进行了解耦操作。工厂服务生产具体的产品，用户只需要提供产品的名称就能获取对应的产品来提供使用。","text":"摘要： 设计模式 简单工厂 这个的用途还是很\b广的。它将生产和消费 进行了隔离，用户不需要关系它是如何生产的，只负责从工厂从获取就可以了，然后执行其消费的操作。这样将两者进行了解耦操作。工厂服务生产具体的产品，用户只需要提供产品的名称就能获取对应的产品来提供使用。 简单工厂模式简单工厂模式是类的创建模式，又叫静态工厂\b方法模式。简单工厂模式由一个工厂对象决定生成哪一种\b产品类的实例 为什么使用简单工厂模式原因很简单：解耦 A对象如果要调用B 对象，最简单的做法就是直接new 一个B 出来，这么做有一个问题，假如C类和B类实现\b了同一个接口/继承自同一个类，系统需要把B类修改成C类，程序不得不重写A类的代码，如果程序中有100个地方new了B的对象，那么久要修改100处了 这就是典型的代码耦合度太高导致了”牵一发而动全身”，所以有一个方法就是写一个工厂IFactory ,A与iFactory 耦合，\b修改一下，让所有的类都实现C类的接口并IFactory 生成出C的实例就可以了 简单工厂模式实例首先由一个抽象的类 12345678910@interface Fruit-(void)grow;-(void)harverset;-(void)plan;@end 具体的类 12345678910111213141516171819// 苹果@interface Apple : Fruit@end@implementation Apple-(void)grow&#123; NSLog(@\"Apple grow\");&#125;-(void)harverset&#123; NSLog(@\"Apple harverset\");&#125;-(void)plan&#123; NSLog(@\"Apple plan\");&#125;@end 12345678910111213141516171819// 香蕉@interface Banana : Fruit@end@implementation Banana-(void)grow&#123; NSLog(@\"Banana grow\");&#125;-(void)harverset&#123; NSLog(@\"Banana harverset\");&#125;-(void)plan&#123; NSLog(@\"Banana plan\");&#125;@end 有一个园丁，专门服务生产出各种水果 12345678910111213@implementation Gardener+(Fruit*)getFruit:(NSString *)frultName&#123; if([frultName isEqualToString:@\"Apple\"])&#123; return [Apple new]; &#125;else if([frultName isEqualToString:@\"Banana\"])&#123; return [Banana new]; &#125;else&#123; return nil; &#125;&#125; 需要什么水果就可以找园丁拿就可以了。 1234567Fruit *fruit = [ Gardener getFurit:@\"Apple\"];[fruit grow];Fruit *fruit1 = [ Gardener getFurit:@\"Banana\"];[fruit1 grow]; 不足：在这里我们可以看到，\b工厂类中每次新增加一个类就需要用到if…else 来增加一次判断，这样持续下去的话，只会使其经常变动，不是很灵活，可以采用反射的机制来实现 1234567891011@implementation Gardener+(Fruit*)getFruit:(NSString *)frultName&#123; Class class = NSClassFromString(frultName); if ([class isKindOfClass:[Fruit class]]) &#123; return [[class alloc] init]; &#125; return nil;&#125; 总结1、用户不需要自己去生成产品，只需要\b去找对用的对象去拿需要的东西就可以了，这样用户-&gt; 产品之间的耦合就降低了 2、代码模块职责更明确了，有专门\b消费的模块，有专门生产的模块，用户只需要关系消费，而不用关系如何创建对象","categories":[],"tags":[{"name":"iOS 设计模式 简单工厂","slug":"iOS-设计模式-简单工厂","permalink":"http://yoursite.com/tags/iOS-设计模式-简单工厂/"}]},{"title":"iOS KVO 底层实现原理","slug":"ios-kvo-detail","date":"2018-08-03T09:33:23.000Z","updated":"2018-08-03T10:44:55.000Z","comments":true,"path":"2018/08/03/ios-kvo-detail/","link":"","permalink":"http://yoursite.com/2018/08/03/ios-kvo-detail/","excerpt":"摘要： KVO 的原理就是通过运行时，替换了对象的isa 指针对象，并重写set的方法","text":"摘要： KVO 的原理就是通过运行时，替换了对象的isa 指针对象，并重写set的方法 KVO 是OC 观察者设计模式的一种KVO 的实现依赖于OC 强大的RunTimeKVO 是cocoa 提供了一种基于KVC的机制 允许一个对象去监听另一个对象的某个属性，当该属性改变的时候，系统会通知监听的对象 KVO 的基本使用流程123456789101.添加监听-(void)addObserver:(NSObject *)object forKeyPath:(NSString *)keypath options:(NSKeyValueObserveringOptions)options context:(nullable void*)context;2.接收通知-(void)observerValueForKeyPath:(nullable NSString *)keypath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey,id&gt;*)change context:(nullable void *)context;3.移除监听-(void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keypath context:(nullable void*)context; KVO的触发观察的属性发生改变的时候，就会调用observerValueForKeyPath的方法会被调用，根据其中的keypath 可以对其做区分 12345678910111213141516171819202122@property (nonatomic ,strong) Person *p;Person *p = [Person new];_p = p;// 添加对p的name 属性的观察[p addObserver:self forKeyPath:@\"name\" options:NSKeyValueObserveringOptionNew context:nil];#pargma mark - 点击改变 name 的属性-(void)touchesBegan:(NSSet&lt;UITouch *&gt;*)touches withEvnet:(UIEvnet *)event&#123; static int = 0; i++; _p.name = [NSStirng stirngWithFormat:@\"%d\",i];&#125; KVO 原理，通过实现自定义的KVO来理解KVO系统的处理是通过运行时，替换了对象的isa指针对象，并重写了set等方法 流程： 1.创建一个person 的类2.写一个NSObject+RRKVO.h 分类 1.Person123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject/** name */@property (nonatomic,copy) NSString *name;@end#import \"Person.h\"@implementation Person//不影响重写set方法-(void)setName:(NSString *)name&#123; _name = [NSString stringWithFormat:@\"在不影响重写set方法的情况下加上这句%@\",name];&#125;@end 2.参考系统KVO12345678#import &lt;Foundation/Foundation.h&gt;@interface NSObject (RRKVO)-(void)rr_addObserver:(NSObject *)observer forKeyPaht:(NSString *)keypath options:(NSKeyValueObserveringOptions)options context：(nullable void*)context;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#import \"NSObject+RRKVO.h\"#import &lt;objc/message.h&gt;@implementation NSObject (RRKVO)-(void)rr_addObserver:(NSObject *)observer forKeyPaht:(NSString *)keypath options:(NSKeyValueObserveringOptions)options context：(nullable void*)context&#123; 自定义子类对象 重现setName的方法，调用super 通知观察者 修改当前对象的isa指针，指向自定义的子类 // 动态的生成一个类 // 创建self 的子类 NSString *oldClassName = NSStringFormClass([self class]); NSString *newClassName = [@\"rrKVO_\" stringByAppendingString:oldClassName]; const char *newName = [newClassName UTF8String]; //创建一个类的class Class myClass = objc_allocateClassPair([self calss],newName,0); // 注册类 // 就可以加入到内存中，就可以用来allocinit objc_registerClassPair(myclass); // 添加 setter 的方法 class_addMethod(myclass,@selector(setName:),(IMP)setName ,\"v@:@\");查看官方文档得到CMD // 修改isa 指针 objc_setClass(self,myClass); // 保存观察者对象 objc_setAssociatedObject(self ,@\"objc\", OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; void setName(id self,SEL _cmd,NSString *newName)&#123; NSLog(@\"运行\"); // 保存子类类型 id class = [self class]; // 改变self的isa 指针 objc_setClass(self,class_getSuperClass(class)); //调用父类方法的setter objc_msgSend(self,@selector(setName:),newName); //拿到观察者 id objc = objc_getAssociatedObject:(self,@\"object\"); // 通知观察者 objc_msgSend(objc，@selector(observerValueForKeyPath:ofOBject:change:context:),self,@\"name\",nil,nil); //改回子类\b类型 object_setClass(self,class); &#125; 3.应用参考iOS KVO的底层实现原理","categories":[],"tags":[{"name":"iOS KVO","slug":"iOS-KVO","permalink":"http://yoursite.com/tags/iOS-KVO/"}]},{"title":"iOS 事件传递和响应","slug":"ios-evnet-detail","date":"2018-08-03T06:29:28.000Z","updated":"2018-08-03T09:34:19.000Z","comments":true,"path":"2018/08/03/ios-evnet-detail/","link":"","permalink":"http://yoursite.com/2018/08/03/ios-evnet-detail/","excerpt":"摘要： 按照事件的顺序，事件的生命周期： 事件的产生和传递(事件如何从父控件传递到子控件并寻找合适的View,寻找合适View的底层实现，拦截事件的处理)——&gt; 找到最合适的View 后的事件的处理(touches 方法的重写，也就是事件\b的响应) 重点和难点：1.如何寻找最合适的View2.寻找最合适的View的底层实现(hitTest:withEvent:底层实现)","text":"摘要： 按照事件的顺序，事件的生命周期： 事件的产生和传递(事件如何从父控件传递到子控件并寻找合适的View,寻找合适View的底层实现，拦截事件的处理)——&gt; 找到最合适的View 后的事件的处理(touches 方法的重写，也就是事件\b的响应) 重点和难点：1.如何寻找最合适的View2.寻找最合适的View的底层实现(hitTest:withEvent:底层实现) iOS 中的事件iOS 中的事件分为3大类 事件产生和传递事件的产生 发生触摸事件后，系统会将事件加入到一个由UIApplication 管理的时间的队列中 UIApplication 会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先将事件发送给程序的主窗口 主窗口会在视图层次结构找\b找到一个最适合的视图来处理触摸事件，这也是整个事件处理过程中的第一步 在找到合适的视图控件后，就会调用视图控件的touchs 方法来做具体的事件处理 事件的传递1.触摸事件的传递是由父控件传递到子控件2.也就是UIApplication-&gt;UIWindow -&gt; 寻找处理事件最合适的view 注意：如果父控件不能接受触摸事件，那么子控件也不可能\b接收触摸事件 应用如何找到最合适的控件来处理事件 首先判断能够接收触摸事件 判断触摸点是否在自己身上 子控件数组中从下往上遍历子控件，重复前面两个步骤(所谓的从后往前遍历子控件就是首先查找子控件数组中的最后一个元素，然后执行1，2步骤) view 比如说testView ，那么会把这个事件交个testView ，再遍历这个testView的子控件，直到没有更合适的View 为止 如果没有符合的子控件，那么就认为自己最合适这个事件，也就是自己是哪个最合适的View UIView 不能接受触摸事件的三种情况： 1.不允许交互 userInteractionEnabled = NO;2.隐藏：如果父控件隐藏，那么子控件也隐藏，隐藏的控件不能接受事件3.透明度：如果设置一个控件的透明度 小于 0.01 会直接影响子控件的透明度 注意：UIImageView 不能接受触摸事件，因为不允许交互，也即使 userInteractionEnabled = NO,所以希望UIImageView 可以交互，需要设置 UIImageView 的 userInteractionEnabled = YES; 如何寻找最合适的View两个重要的方法： hitTest:withEvent: 方法pointInside 方法 hitTest:withEvent: 方法什么时候调用： 只要事件一传递给一个控件，这个控件就会调用他自己的hitTest:withEvnet方法 作用： 寻找并返回最合适的view，(能够响应事件的那个最合适的View) 注意：不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会传递给这个控件，随后调用 hitTest：withEvnet 方法 拦截事件处理： 正是因为hitTest：withEvnet：方法返回的是最合适的view，所以可以重写hitTest：withEvnet 方法，返回指定的view作为最合适的view 不管点击那里，最合适的view都是hitTest\b:withEvent 方法中返回的那个View 通过重写hitTest:withEvent 就可以拦截事件的传递过程，想让谁处理事件谁就处理事件 事件传递给谁就会调用谁的hitTest:withEvnet方法 注意：如果hitTest:withEvnet 返回的是nil ,那么调用该方法的控件本身和子控件都不是最合适的View ,也就是\b在自己身上没有找到更合适的View，那么最合适的view就是该控件的父控件 所以事件的传递顺序就是： 产生触摸事件-》 UIApplication 的事件队列 -》 [UIWIndow hitTest:withEvent] -》返回更适合的View -》[子控件 hitTest:withEvnet] -&gt; 返回最适合的view hitTest:withEvnet 方法底层实现 123456789101112131415161718192021222324-(UIView *)hitTest:(CGPoint)point withEvnet:(UIEvent *)event&#123; // 判断当前窗口能够接收事件 if(self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // 判断点是否在窗口上 if(self pointInside:point withEvnet:event ] == NO) return nil; // 从后 往前遍历子控件数组 int count = (int)self.subviews.count; for(int i = count-1,i&gt;=0 ;i--)&#123; //获取子控件 UIView *childView = self.subviews[i]; CGPoint childP = [self converPoint:point toView：\bchildView]； UIView *fitView = [childView hitTest:childP withEvent:event]; if(fitView)&#123; return fitView； &#125; &#125; return self;&#125; pointInSide：WithEvent: 方法 pointInside:withEvent 方法判断点在不在view 上，如果返回YES，代码点的方法调用者在坐标系上，返回NO,代表不在\b方法调用者坐标系上，那么方法调用者就不能处理事件。 事件响应触摸事件处理的整体过程 用户点击屏幕后产生一个触摸事件，讲过一系列的传递后，会找到最合适的View 来处理这个事件 找到最合适的View后就会调用控件的 touches方法\b来做具体的事件处理 touchsBegin touchsMoved touchedEnd 这些touches方法默认做法是将事件顺着响应者链表向上传递也就是touche 方法默认不处理事件，值能传递事件，将事件交给上一个响应者进行处理 响应者链条在iOS \b程序中无论是最前面的UIWindow 还是最前面的缪戈按钮，他们的摆放都是有前后的关系的，一个控件可以放到另一个控件上面或者下面，那么用户点击控件的时候出发的上面的控件还是下面的\b控件呢？这种先后关系构成了一个链条叫做响应者链，也可以说，响应者链式由多个响应者对象连接起来的链条，在iOS 中响应者链的关系 响应者对象：能处理事件的对象，也就是记性UIResponse 的对象作用： 能看清楚\b每一个响应者这年的联系，并且可以让一个事件多个\b对象处理 touches 的默认做法是把事件顺着响应者链条向上抛 123456-(void)touchesBegin:(NSSet *)touches withEvent:(UIEvnet *)event&#123; [super touchesBegin:touches withEvnet:event];&#125; 总结事件的传递和响应的区别事件的传递是从上到下(父控件到子控件)，事件的响应式从下到上(顺着响应者链表向上传递)子控件到父控件 参考史上最详细的iOS之事件的传递和响应机制-原理篇","categories":[],"tags":[{"name":"iOS 事件","slug":"iOS-事件","permalink":"http://yoursite.com/tags/iOS-事件/"}]},{"title":"iOS 崩溃捕获和分析","slug":"ios-crash-detail","date":"2018-07-30T11:45:37.000Z","updated":"2018-08-10T10:14:03.000Z","comments":true,"path":"2018/07/30/ios-crash-detail/","link":"","permalink":"http://yoursite.com/2018/07/30/ios-crash-detail/","excerpt":"摘要： 在开发中经常会遇到崩溃，这时候你知道崩溃的\b文件存放在哪里？你有什么方法来获取崩溃的日志文件？崩溃日志获取到了，你知道如何查看它吗？\b本文将带着以上的文件，对崩溃进行分析。","text":"摘要： 在开发中经常会遇到崩溃，这时候你知道崩溃的\b文件存放在哪里？你有什么方法来获取崩溃的日志文件？崩溃日志获取到了，你知道如何查看它吗？\b本文将带着以上的文件，对崩溃进行分析。 \b崩溃日志1.什么是崩溃日志iOS \b设备上的应用程序在闪退的时候，操作系统会声称一个崩溃日志，保存在设备上 123路径：\b设置-&gt; 隐私 -&gt; 诊断与用量 -&gt; 诊断与用量数据在诊断与用量的界面中 有发送和不发送的操作，在这里如果选择发送的话，会自动将\b诊断和用量数据发送到iTunes 来帮助开发者进行崩溃日志的分析 崩溃日志的获取1.连接设备获取崩溃日志设备与电脑上的ITunes Stores 同步后，会将崩溃日志保存在电脑上，崩溃日志保存在一下位置 123MAC OS X ： ~/Library/Logs/CrashReporter/MobileDevice/然后可以看到你的设备名称的文件夹,然后继续往下找 2.通过XCode 连接来导出崩溃日志首先将XCode 和电脑连接，然后 window-&gt; Devices and Simulators 然后进入查看View Device Logs 这时候可以查看到所有的日志文件，可以查看到右边窗口看到对应的 3.通过\biTunes 获取崩溃日志通过Itunes Connect 获取使用者上传的崩溃日志，登录iTunes Connect 选中APP ，点击可供销售的APP 在额外信息中可以查看到所有iOS 版本下的崩溃日志 崩溃日志的分析 这里我们来分析下对用字段的解析： incident Identifier:崩溃日志的唯一标识符 CrashReporter Key:是与设备标识相对应的唯一键值。 Hardware Model：标识设备类型 Process :是应用的名称 Version:APP的版本号 最重要的两个： Exception Type:崩溃的类型\bLast Exception Backtrace:发生崩溃的时候的堆栈 XCode 会自动符号化代码，翻译成明文： 将.crash 文件反编译得到\b明文的crash 文件 首先在桌面新建一个文件夹 DebugTest 然后将 MyApp.app ,MyApp.app.dYSM 还有 崩溃文件 .crash 文件放入到这个文件夹中 找到Symbolicatecrash 这个文件，将\b其拷贝到DebugTest 这个文件夹中 1cd /Applications/Xcode.app/Contents/SharedFrameworks/DTDeviceKitBase.framework/Versions/A/Resources 在终端中运行命令，符号化崩溃日志 12345cd /User/younmae/Desktop/DebugTestexport DEVELOP_DIR = \"/Applications/Xcode.app/Contents/Developer\"./Symbolicatecrash -v crashfile \bMyApp.app.dYSM 然后再打开就看到了\b符号化后的明文的崩溃日志文件 注意： 构建版本的时候会自动生成dSYM 文件，但是debug 的时候，是没有的，需要我们手动开启，在build Setting 中搜索debug 这两个就可以产生dsym 了 手动捕获崩溃日志首先Apple 提供了一个NSSetUncaughtExceptionHandler 12345678910111213-(void)catchCrashLogs&#123; NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);&#125;void UncaughtExceptionHandler(NSException *exception)&#123; if(exception == nil) return; NSArray *array = [exception callStacksSymbols]; NSString *reason = [exception reason]; NSString *name = [exception name]; //然后将崩溃日志文件进行保存&#125; 解决崩溃收集冲突问题在进行崩溃日志处理的时候，可能会遇到一些冲突的操作：首先因为收集崩溃日志的操作是有些第三方操作也需要\b实现的，所以这里我们需要先确定下处理这个冲突的流程 首先先通过 NSGetUncaughtExceptionHandler() 拿到之前日志库处理exception 的handler ,然后通过 NSSetUncaughtExceptionHandler(),设置自己处理的exception 的hanler ,在自己的handler 处理异常完之后，再将异常\b塞给之前的hanler 初始化使用第三方的工具的时候，首先需要先初始化第三方的操作，然后才能初始化我们自己的日志收集工具 获取第三方的handler 和 设置自己的handlerstatic NSUncaughtExceptionHandler *_previousHandler; _perviousHandler = NSGetUncaughtExceptionHandler(); //设置自己处理异常的handlerNSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler); 处理自己的异常12345void UncaughtExceptionHanlder(NSException *exception)&#123; // 取出exception 的 name reason 和 callStacksSymbols 计算出\b崩溃是的\b偏移量把这些信息以\b字段存储到本地上&#125; 将exception 塞给第三方处理完自己的逻辑后就需要将exception 赋值给我们之前保存的handler ,否则第三方就无法统计崩溃的数据 1_previousHandler(exception); 不足和改进并不是所有的\b程序崩溃都是可以捕获的异常，有些时候引起异常的大多数原因：比如说内存错误，重复是否等错误信息就可能无能为力。这时候需要通过signal 来做处理 参考iOS崩溃捕捉和分析iOS友盟和其他崩溃收集库共存时的冲突问题iOS崩溃异常处理(使用篇)IOS崩溃 异常处理","categories":[],"tags":[{"name":"iOS 崩溃 分析","slug":"iOS-崩溃-分析","permalink":"http://yoursite.com/tags/iOS-崩溃-分析/"}]},{"title":"ios_sql_detail","slug":"ios-sql-detail","date":"2018-07-26T10:07:03.000Z","updated":"2018-07-26T10:07:03.000Z","comments":true,"path":"2018/07/26/ios-sql-detail/","link":"","permalink":"http://yoursite.com/2018/07/26/ios-sql-detail/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS 界面优化","slug":"ios-jiemian-youhua","date":"2018-07-24T07:47:59.000Z","updated":"2018-08-25T09:17:17.000Z","comments":true,"path":"2018/07/24/ios-jiemian-youhua/","link":"","permalink":"http://yoursite.com/2018/07/24/ios-jiemian-youhua/","excerpt":"摘要： 在我们正常的开发过程中，优化是一个比较\b\b技术的活，这里只针对界面的优化，首先从屏幕的显示原理处理，然后告诉我们一般界面出现卡顿是如何产生的。然后从CPU 和GPU 的角度来分析如何更好的避免卡顿的手段。\b后面介绍一个开源的框架ASDK 来处理我们之前针对CPU 和 GPU 优化所做的事情。","text":"摘要： 在我们正常的开发过程中，优化是一个比较\b\b技术的活，这里只针对界面的优化，首先从屏幕的显示原理处理，然后告诉我们一般界面出现卡顿是如何产生的。然后从CPU 和GPU 的角度来分析如何更好的避免卡顿的手段。\b后面介绍一个开源的框架ASDK 来处理我们之前针对CPU 和 GPU 优化所做的事情。 屏幕显示图像的原理 首先从 CRT 显示器 的原理说起。 CRT 的电子枪按照上面的方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪就回到初始位置继续下一次扫描。为了把显示器的显示过程和\b系统的视频控制器进行同步，\b显示器会用硬件的时钟产生一系列的定时信号。当电子枪换到新的一行的时候，准备进行扫描的时候，显示器会发出一个水平同步信号 HSync ，而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号，简称 VSync ,通常显示器是以固定频率进行刷新，这个刷新频率就是 VSync 信号产生的频率。 计算机系统中CPU、GPU、显示器 是\b以上面这种方式协同工作的。CPU 计算好要显示的内容提交到GPU ,GPU 渲染完成后将渲染的结果放入帧缓冲区，随后视频控制器会按照VSync 信号\b一行行的读取缓冲区的数据，经过可能的数模转换传递给显示器 在最简单的情况下，一个缓冲区，这时候缓冲区的读取和刷新都会有比较大的效率问题。为了解决效率问题，可以引入双缓冲机制。这种情况下，GPU会预先渲染好的一帧放入一个缓冲区中，让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲区。如此一来效率将\b会有很大的提升。 双缓冲虽然能解决效率的问题，但会引入一个新的问题。当视频控制器还未读取完成的时候，也就是屏幕内容显示到一半的时候，GPU 将新的一帧内容提交到帧缓冲去进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象： 为了解决这个问题，GPU 通常\b有一个机制叫做 垂直同步 V-Sync ，当开启垂直同步后，GPU 会等待显示器VSync 信号后发出，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消耗更多的计算资源。也会带来部分延迟。 卡顿产生的原因和解决方案 在 VSync 信号到来后，系统图像服务会通过 CADisplayLink 等机制通知 APP ,APP 的主线程开始在 CPU 中计算显示的内容，比如：视图的创建、布局计算、图片解码、文本绘制等随后CPU 将计算好的内容提交到 GPU 中，由 GPU 进行 \b变换 、合成、渲染。随后GPU 把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来的时候显示到屏幕上。由于垂直同步的机制，如果在一个VSync \b时间中，CPU 或者 GPU 没有完成提交的内容，则那一帧将被丢弃。等待下一次机会再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因 从上面的图中看出，\bCPU 和 GPU 无论哪个阻碍了显示的流程，都会造成掉帧的现象。所以开发的时候，也需要对CPU和GPU 压力进行评估和优化 CPU 资源消耗原因和解决方案对象创建对象的创建会 分配\b\b内存，调整属性，甚至会读取文件 等操作，\b比较消耗 CPU 的资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如CALayer 比 UIView 要轻很多，那么不需要响应触摸事件的控件,用CALayer 显示会更加合适。 如果对象不涉及到UI操作，则尽量放到后台线程去创建，但可惜的是包含有CALayer的控件，都只能在主线程创建和操作。通过StoryBoard 创建视图对象的时候，其资源消耗会比\b直接通过代码创建对象要大非常多，在性能敏感的界面里，StoryBoard 并不是一个好的技术选择 尽量推迟对象的创建的时间，并把对象的创建分散到多个任务中去，尽管这实现起来比较麻烦，并且带来的优势并不多，但是如果有能力做还是要尽量尝试下，如果对象可以复用，并且复用的代价比释放，创建新的对象要小，那么这个类对象应当尽量放到一个缓存池里复用 对象调整对象的调整也经常是消耗 CPU 的资源的地方。这里特别说明下CALayer ,CALayer 内部并没有属性，当你调用属性方法的时候，它内部是通过resolveInstanceMethod为对象临时添加一个方法，并把对应属性的值保存在Dictionay 里面的，同时还会创建delegate 、创建动画等等。非常消耗资源。 UIView 的关于显示相关的属性比如(frame、bound、transform) 等实际上都是CALayer 映射出来的，所以对UIView 的这些属性\b进行调整的时候，资源的消耗要\b远大于一般的属性，对此你在应用中，应该尽量减少不必要的属性修改 当视图层次调整的时候，UIView 和 CALayer 之间会出现很多方法调用和通知，所以在优化性能的时候，应该尽量\b避免视图层次、添加和移除操作。 对象的销毁对象的销毁虽然消耗的资源不多，但是积累起来你也是不容忽视的。通常当容器类持有大量对象的时候，其销毁的资源就非常明显。同样的，如果对象可以放到后台去是释放，那就挪到后台线程去。\b 这里有个小Tip: 把对象捕获到 block 中，然后扔到后台队列中去随便发送一个消息1️⃣避免编译器警告，就可以让对象\b在后台线程销毁了 12345678NSArray *tmp = self.array;self.array = nil;dispatch_async(queue,^()&#123; [tmp class];&#125;); 布局计算视图布局的计算是APP 中最为常见的消耗 CPU 的资源的地方，如果能在后台线程提前计算好\b视图布局、并对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。 不论通过何种技术对视图进行布局，其最终都会落到对UIView.frame/bounds/centers等熟悉的调整上。上面也说过，对这些属性的调整是非常消耗资源的，所以尽量提前计算好布局，在需要的时候一次性调整好对应的属性，而不是多次、平凡的就算和调整这些属性。 AutolayoutAutolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率。但是Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout \b带来的CPU 消耗会呈指数级的上升。如果你不想手动调整frame 等属性，你可以用到一些工具方法替代(比如常见的left/right/top/bottom/width/height 快捷属性)或者使用ComponentKit,AsyncDisplayKit等框架 文本计算如果一个界面里包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊的要求可以参考UIlabel 内部实现的方式 用[NSAttrubuteString boundingRectWithSize:options:context];[NSAttributeString drawWithRect:options:context]; 来绘制文本，尽管这两个方法的性能不错，但是仍然需要放到后台线程进行以避免阻塞主线程 如果你用coreText 绘制文本，那就可以先生成CoreText 排版对象，然后自己计算了，并且CoreText 对象还保留以供稍后绘制使用 文本渲染屏幕\b上可以看到d的\b所有文本内容控件，包括UIWebView 在底层都是通过CoreText 排版的，绘制为Bitmap 显示的。常见的文本控件(UILable ，UITextView等)其排版和绘制都是在主线程进行的，当\b显示大量文本的时候，CPU 的压力会比较大，对此解决方案只有一个，那就是自定义文本控件。用TextKit 或者最底层的CoreText 对文本异步绘制，尽管这个实现起来非常麻烦，但是其带来的优势非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免多次计算(调整 UILabel 大小算一遍，UILabel 绘制的时候内部算一遍);CoreText 对象占用的内存较小，可以缓存下来已被稍后多次渲染。 图片的解码当你用UIImage 或 CGImageSource 的那几个方法创建图片的时候，图片数据不会立刻解码。 图片设置到 UIImageView 或者 CALayer.Contents 中去并且CALayer 被提交到GPU 前，CGImage 中的数据才会得到解码。这是一个发生在主线程的，并且不可避免。如果要绕开这个机制，常见的做法就是在后台线程先把图片绘制到CGBitmapContext 中，然后从Bitmap 直接创建图片。目前常见的网络库都自带这个功能 图片的绘制图像的绘制通常是指用哪些以CG 开头的方法把图像绘制到画布中，然后从画布中创建图片并显示这样一个过程。这个最\b常见的地方就是[UIView drawRect]里面，由于CoreGraphic 方法是线程安全的，所以可以放到后台中期。一个简单的异步绘制的过程大致如下：12345678910111213141516-(void)display&#123; dispatch_async(backgroundQueue,^()&#123; CGContextRef ctx = CGBitmapContextCreate() // draw in context CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue,^&#123; layer.contents = img; &#125;); &#125;)&#125; GPU 资源消耗原因和解决方案相对于CPU \b来说，GPU 能干的事情就比较单一；接收提交的纹理（Texture）和 顶点描述(三角形) ,应用变换(transform)，混合并渲染，然后输出到屏幕上。通常你所能看到的内容也就是纹理和形状两类 纹理的\b渲染所有的Bitmap ，包括图片、文本、栅格化的内容，最终都要由内存提交到显存中，绑定为GPU Texture ，不论是提交到显存的过程还是GPU 调整和渲染 Texture 的过程，都需要消耗GPU 的资源。当在较短时间显示大量图片的时候，CPU占用率很低，GPU占用率非常高，界面仍然会掉帧，避免这种情况的方法只能是尽量减少在短时间中大量图片的展示，尽可能将多张图片合成一张进行显示 当图片过大的时候，超过GPU 的最大纹理尺寸,图片先由CPU 进行预处理，这对CPU和GPU 都会带来额外的资源消耗， 1234567891011// 将视图转换为图片的操作-(UIImage*)snapshotImage&#123; UIGraphicBeginImageContextWithOptions(self.bounds.size,self.opaque,0); [self.layer renderInContext:UIGtaphicsGetCurrentContext()]; UIImage *snap = UIGraphicGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return snap;&#125; 视图的混合当多个视图重叠在一起显示的时候，GPU 会首先把他们混合在一起。如果视图结构复杂，混合的过程也会消耗很多GPU 的资源，为了减轻这种情况的GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里表明 opaque 属性来避免无用的Alpha通道喝茶。当然这也可以用上面的方法，把多个\b视图预先渲染为一张图片来显示。 图片的生成CALyaer 的border 、圆角、阴影，遮罩，CASharpLayer 的矢量图型显示，通常都会出发离屏渲染 ，而离屏渲染通常会发生在GPU 中，当一个列表视图中出现大量圆角\b的CALyaer 的时候，并且快速滑动的时候，可以观察到GPU 的资源以及占满了，而CPU的资源消耗比较少，这时候界面任然可以正常的滑动，但是平均的帧数会降低，为了避免这种情况，可以尝试开启CALayer.shouldRasterize 属性，但是这样会把原本离屏渲染的操作\b转嫁到\bCPU 上去对于只需要圆角绘制的谋陷场合，也可以用一张已经绘制好的圆角图片覆盖视图来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图像在后台绘制为图片，避免使用圆角、阴影，遮罩等属性 12 AsyncDisplayKitUIView 和 CALayer 的关系： View 持有Layer 用于显示，View 中大部分显示属性实际是从 CALayer 中映射出来的，Layer 的 delegate 是View，其属性的\b改变，动画的产生时，View \b可以得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。 ASDK 为此创建了ASDisplayNode 类，包装了常见的\b视图属性，然后用UIView-&gt;CALayer 的方法实现了 ASNode -&gt; UIView 这样一个关系 当不需要响应触摸事件的时候，ASDisplayNode 可以被设置为layer backed 也就是ASDisplayNode 充当了原来UIView 的功能，节省了资源 。 与UIView 和 CAlayer 不同的是，ASDisplayNode 是线程安全的。它可以在后台线程创建和修改。Node 刚创建时，它的内部\b并不会新建UIView 和 CALayer ，直到第一次在主线程访问View 或者 layer 属性的时候，它才会在内部生产对用的对象，当它的属性改变后，它并不会立刻同步到其持有的view 或layer ,而是把被改变的属性保存到内部\b的一个中间变量，稍后在需要的时候，再通过某个机制一次性设置到内部的view 或 layer上去 通过模拟和封装 UIView /CALayer 开发者可以把代码中的UIView 替换成ASNode ，很大的降低了开发和学习的成本，同时获得ASDK 底层大量的性能优化，为了方便使用，ASDK 把大量常用控件都封装成了ASNode 的子类，比如 Button,Control，Cell,Image，ImageView,Text，TableView collectionView等，利用这些控件，开发者可以尽量避免直接使用UIKit 相关的控件以及获得更加完整的性能提升 ASDK 的图层预合成有时候一个layer 会包含很多的sub-layer ，而这些sub-layer 并不需要响应触摸时间，也不需要进行动画和位置调整，ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些sub-layer 合成渲染为一张图片，开发的时候 ，ASNode 已经替代料UIView 和 CALayer ;直接使用\b各种Node 控件并设置为layer backed 后，ASNode 设置可以通过预合成来避免创建内部的UIView 和 CALayer 通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图片上，性能会获得很大的提升。CPU 避免了创建UIKit 对象的资源消耗，GPU 避免多张texture 合成和渲染的消耗，更少的bitmap 也意味着更少的内存\b占有。 ASDK 异步并发操作充分利用多核的优势，并发执行任务对界面\b流畅有很大的作用.ASDK 把布局计算、\b文本排版、图片绘制、图片渲染等操作都封装成较小的任务，并利用GCD异步并发执行，如果\b开发者使用了ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多的配置。 RunLoop 任务分发 iOS 的\b显示系统是由VSync 信号驱动的，VSync 信号是有硬件时钟生成的，每秒钟发出60次\b，iOS 的图形服务器收到VSync 信号后，会通过IPC 通知APP 内部，APP的 runloop 在启动后会注册 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后Source 的回调会驱动整个APP 的动画与显示。 Core Animation 在 RunLoop 中注册了一个Oberver ,监听了BeforeWaiting 和 Exit 事件，这个Observer 的优先级是200000 低于其他的Observer ,当一个触摸事件到来的\b时候，RunLoop 会被唤醒APP 中的代码会执行\b一些操作，比如创建和调整视图层级，设置UIVIE 的frame 修改CALayer 的透明度 ，为视图添加一个动画，这些操作最终都会\b被CALayer 捕获，并通过Transaction 提交到一个中间状态去，CATransaction的文档\b有粗劣的提到这些内容，当上面的操作结束后，RunLoop 即将进入休眠的时候，关注该事件的Observer 都会得到通知，这时候CA注册的那个Observer 就会在回调中，把所有中间状态合并提交到GPU 去显示；如果此处有动画，CA 会通过DisplayLink 等机制多次出发相关流程 ASDK 在此处模拟了Core Animation 的这个机制，所有针对ASNode 的修改和提交，总有些任务是必须放入主线程中执行的，当出现这种任务的时候，ASNode 会把任务用ASAsyncTransaction（group）封装并提交到一个全局的容器去，ASDK \b也在RunLoop 中注册一个Observer ，监视的时间和CA 一样，但是优先级比CA 要低。当RunLoop 进入休眠前，CA处理完事件后，ASDK 就会执行该Loop 中提交的\b所有任务， 12345678910111213141516171819202122232425262728293031在这里添加了\b一个ObserverCFRunLoopRef runloop = CFRunLoopGetCurrent();CFOptionFlags activities = (kCFRunLoopBeforeWaiting | kCFRunLoopExit);CFRunLoopObserverContext context = &#123; 0,//version (__bridge void*)transactionGroup,//info &amp;CFRetain,// retain &amp;CFRelease,// release NULL// copyDescription&#125;;CFRunLoopObserverRef *observer = CFRunLoopObserverCreate(NULL, activities, YES, INT_MAX, &amp;_transactionGroupRunLoopObserverCallback, context);CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);// callbackstatic void _transactionGroupRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; ASDisplayNodeCAssertMainThread(); _ASAsyncTransactionGroup *group = (__bridge _ASAsyncTransactionGroup *)info; [group commit];&#125; 微博 Demo 性能优化技巧预排版当获取到API \bJSON 数据后，将每条Cell 需要的数据都放在后台线程计算并封装为一个布局对象 CellLayout 。CellLayout 包含了所有文本的CoreText 排版结果 ，Cell 内部每个控件的高度，Cell的整体高度。\b每个CellLayout 的内存占用并不多，随意生成后可以全部缓存到内存，以供稍后使用。这样TabelView 在请求各个高度函数的时候，不会消耗任何多余的计算量，当CellLayout 设置到Cell 内部的时候，cell 的内部就不会再计算布局了。 对于通常的TableView 来说，提前在后台计算好布局结构是非常重要的一个性能优化点，为了达到最高性能，你可能需要牺牲一些开发速度，不要用AutoLayout 等技术，少用UILabel 等文本控件，但是如果你对性能的要求不是很高，那么尝试用TableView 的预估高度功能，并把每个Cell的高度缓存下来，这里有个百度知道团队的开源项目开源很方便实现这一点 预渲染例如针对圆形头像，在后台线程讲头像预先渲染为圆形并单独保存到一个ImageCache中去 对于TableView 来说Cell 内容的离屏渲染会带来\b较大的GPU\b 消耗。 为了避免离屏渲染你应当尽量避免使用layer 的border、Corner、shadow,mask等技术。而是尽量在后台线程预先绘制好对应的内容 异步绘制YYAsyncLayer YYAsyncLayer 是 CALayer 的子类，当它需要显示内容的时候，会向他的delegate 也就是UIView 请求一个异步绘制的任务，在异步绘制的时候，layer 会传递一个BOOL^(isCancelled)这样的Block ,绘制代码可以随时调用该block判断绘制任务是否已经被取消。 当TableView 快速滑动的时候，会有大量的异步绘制任务提交哦到后台线程去执行。但是有时候滑动速度过快的时候，绘制任务还没完成就可能已经被取消了，这时候任务继续绘制，就会造成大量 CPU 资源的浪费，甚至阻塞线程并造成后续的绘制任务\b迟迟无法完成。可以采用快速，提前判断当前绘制任务是否已经取消；在绘制每一行前，\b调用isCancelled() 来进行判断，保证被取消的任务能能够即使退出，不至于影响后续的操作。 原理：当滑动的时候，松开手指后，立刻计算出滑动\b停止的时候Cell 的位置，并预先绘制那个位置附近的Cell，而忽略当前滑动中的Cell,这个方法比较有技巧性，并且对滑动性能来时候提升很大，唯一的缺点就是快速滑动中会有大量的空白内容，如果你不想实现比较麻烦的异步绘制但是又想保证滑动的流畅性，这个技巧是不错的选择； 全局并发控制大量的任务提交到后台队列的时候，某些任务会因为某些原因被锁住导致线程休眠或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务，当这种情况变多了或者APP 中是用来大量Concurrent Queue 来执行较多任务的时候，APP在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管Concurrentqueue能控制线性的优先级，但是当大量线程同时创建运行销毁的时候，这些操作任然hi机战主线程CPU的资源， 使用Concurrent queue 的时候，不可避免会遇到这个问题，但是使用Serial queue 又不能充分利用多核CPU 的资源， YYDispatchQueuePool 为不同优先级创建和CPU 数量相同的Serial queue ,每次从pool 中获取 queue 的时候，都会轮询并返回其中一个queue ,将APP 中的图像解码，对象释放，异步绘制等都按照优先级不同放入全局的serai queue 中执行，这样尽量避免了过多线程导致性能问题 更高效的异步图片加载在SDWebImage 中显示简单的单张图片的时候，使用的是UIImageView 来进行显示 这时候可以利用UIView.layer。contents就可以足够了。 如何评测界面的流畅度YYFPSLabel 123456789101112131415161718192021222324252627282930 _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)]; [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];// 实现 -(void)tick:(CADisplayLink*)link&#123; if(_lastTime == 0)&#123; lastTime = link.timestamp; return; &#125; _count++; NSTimerInterval delta = link.timestamp - _lastTime; if (details &lt; 1) return; // 当details &gt; 1 的时候 count 一般都是在 60 _lastTime = link.timestamp; float fp = _count/delta; _count = 0; CGFloat progress = fps /60; &#125;","categories":[],"tags":[{"name":"iOS 界面优化","slug":"iOS-界面优化","permalink":"http://yoursite.com/tags/iOS-界面优化/"}]},{"title":"iOS_block_detail","slug":"iOS-block-detail","date":"2018-07-23T03:48:36.000Z","updated":"2018-07-23T03:48:36.000Z","comments":true,"path":"2018/07/23/iOS-block-detail/","link":"","permalink":"http://yoursite.com/2018/07/23/iOS-block-detail/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用Atom 打造MarkDowm 编辑器","slug":"atom-build","date":"2018-07-20T02:23:29.000Z","updated":"2018-07-20T03:11:20.000Z","comments":true,"path":"2018/07/20/atom-build/","link":"","permalink":"http://yoursite.com/2018/07/20/atom-build/","excerpt":"摘要：","text":"摘要： 安装Atom下载的连接 https://atom.io/ 增强预览Atom 自带的MarkDowm 预览插件 markdowm-preview 功能比较简单，所以可以在Setting 中 Install 添加 markdown-preview-plus 对其进行功能的扩展和增强。 快捷键： ctrl+shift+m 注意：在使用这个插件的时候要先禁用markdown-preview 同步滚动(MarkDown-scroll-sync)同步滚动的插件 代码增强(language-markdown)一般的MarkDown 编辑器提供了代码着色的基本功能，language-markdown 除了能改代码找色还提供了代码片段的生成功能 1#import \"\" 图片粘贴(markdown-image-paste)这个编辑器还是很好用的，但是最近出问题了，ctrl+v 的时候总是变成一个空格，重新安装后还是这样，表示不理解呀！如果有朋友知道，麻烦告知下 步骤： 首先使用截图工具进行截图 （ctrl+shift+cmd+4 ） 然后找个空行 输入你想要保存的名字 然后使用快捷键 Ctrl+v 就可以保存起来了 PDF 导出(markdown-themeable-pdf 和 pdf-view)这两个要配合使用 快捷键：shift+ctrl+E 针对头部和尾部可以去除，在setting 中将勾选给去掉就可以了 完全\b删除atom 首先将atom 移出应用程序 然后执行以下命令1234567rm -fr ~/.atomrm /user/local/bin/atomrm /usr/local/bin/apmrm ~/Library/preferences/com.github.atom.plistrm ~/Library/Application Support/com.github.atom.ShipItrm -rf ~/Library/Application Support/Atom/ 如果有新的功能发现会继续补上…. 参考： mac 上彻底卸载atom 使用Atom打造无懈可击的Markdown编辑器","categories":[],"tags":[{"name":"Atom MarkDowm","slug":"Atom-MarkDowm","permalink":"http://yoursite.com/tags/Atom-MarkDowm/"}]},{"title":"系统知识集合","slug":"newworking-kenowledge","date":"2018-07-17T02:32:17.000Z","updated":"2018-07-17T03:32:06.000Z","comments":true,"path":"2018/07/17/newworking-kenowledge/","link":"","permalink":"http://yoursite.com/2018/07/17/newworking-kenowledge/","excerpt":"摘要：","text":"摘要： 1.进程和线程以及他们之间的区别？ 进程是对运行时程序的封装，是系统进行资源调度和分配的基本单元，实现了操作系统的并发 线程是进程的子任务，是CPU调度和分派的基本单元，用于保证程序的实时性，实现进程内部的并发 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在 进程在执行过程中拥有独立的内存单元，而多个线程共享进行的内存 2.数据库索引索引对数据库表中的一个或多个列的值进行排序的数据结构。以协助快速查询、更新数据库表中数据。索引的实现通车使用B_TREE 及其变种，索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据，相反它会从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据 优点 大大加快数据的索引速度，这也是创建索引的最主要的原因； 加速表和表之间的链接 在使用分组和排序子句进行数据检索的时候，同样可以显著减少查询中分组和排序的时间 通过创建唯一索引，可以保证数据库表中的每一行数据的唯一性 缺点 时间方面：创建索引和维护索引要耗费时间，具体的，当对表中的数据进行增加、删除和修改的时候索引也要动态的维护，这样就降低了数据的维护的速度 空间方面：索引需要占用物理空间 3.数据库事务事务是一种不可分割的数据库操作序列，也就是数据库并发控制的基本单元，其执行结果从一种一致性状态变到另一种一致性状态 特征 原子性：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚； 一致性：事务的执行结果必须是数据库从一个一致性状态到里一个一致性状态； 隔离线：并发执行的事务之间不能互相影响 持久性： 事务一旦提交，对数据库中的数据的改变是永久性的 什么是存储过程？有哪些优缺点存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，进一步说，存储过程就是由一些T-SQL 语句组成的代码块，这些T-SQL 语句代码像一个方法一样事先一些功能，(对表单和多表进行增删改查)然后再给这个代码块取一个名字，在用到这个功能的时候调用它就行了，存储过程具有以下的特点： 存储过程只在创建的时候进行编译，以后每次只需过程都不需要翻译，而一般SQL 语句每执行一次就编译一次，所以使用存储过程可提供数据库的执行效率 当SQL 语句中有变动的时候，值需要修改数据库中的存储过程而不必修改代码 减少网络传输，在客户端调用一个存储过程比执行一串SQL传输的数据量要小 通过存储过程能够使用没有权限的用户在控制之下间接存取数据库，从而确保数据的安全 参考： 面试/笔试第三弹 —— 数据库面试问题集锦","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/系统/"}]},{"title":"ReactiveCocoa_learning","slug":"ReactiveCocoa-learning","date":"2018-07-16T03:03:56.000Z","updated":"2018-08-25T09:16:03.000Z","comments":true,"path":"2018/07/16/ReactiveCocoa-learning/","link":"","permalink":"http://yoursite.com/2018/07/16/ReactiveCocoa-learning/","excerpt":"摘要：","text":"摘要： 简介ReactiveCocoa 结合了几种编程风格： 函数式编程：使用高阶函数，例如函数用其他函数来作为参数 响应式编程：关注数据流和变化的传播 所以你可能会听过ReactiveCocoa被描述为函数响应式编程(FRP) 1.首先需要导入Pod 2.然后引用头文件 接下来介绍一些常用的方法： 123456[_phoneNumberTextField.rac_textSignal subscribeNext:^(NSString * _Nullable x) &#123; // 这里实时的获取数据 NSLog(@\"the phone number is %@\",x); &#125;]; RACSignal 发送事件流给它的subscriber 目前总共有三种类型的事件：next、error、completed 一个signal 在因error 终止或者完成前，可以发送任意的next 事件。 RACSignal 有很多方法可以来订阅不同的事件类型。每个方法都需要至少一个block,当事件发生的时候就会执行block 中的逻辑，当上面的例子中可以看出，每次next事件发生的时候，subscribeNext 方法提供的block 就会执行。 ReactiveCocoa 框架提供Category 来为很多基本的UIKIT 控制添加signal，这样就能给控件添加订阅了。text field 的rac_textSignal就是这么来的 ReactiveCocoa 有很多操作来控制事件流，假设你只关心超过3个字符长度的用户名，那么你可以使用filter 操作来实现这个目的，把之前加在ViewDidLoad 的代码更新成下面的： 123456789[[_phoneNumberTextField.rac_textSignal filter:^BOOL(NSString * _Nullable value) &#123; return value.length &gt; 3; &#125;] subscribeNext:^(NSString * _Nullable x) &#123; // 这里实时的获取数据 NSLog(@\"the phone number is %@\",x); &#125;]; 刚才就是一个简单的管道，这就是响应式编程的本质，根据数据流来表达应用的功能， 从上面的图中可以看出，rac_textSignal 是起始事件，然后数据通过一个filter,r如果这个事件包含长度超过3个字符，那么该事件就通过，管道的最后一步就是subscribeNext,block 在这里打印出事件的值。 12345678910RACSignal *phoneSignal = self.phoneNumberTextField.rac_textSignal;RACSignal *filteredUserName = [phoneSignal filter:^BOOL(id _Nullable value) &#123; NSString *text = value; return text.length &gt;3;&#125;];[filteredUserName subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\",x);&#125;]; RACSignal 的每个操作都会返回一个RACSignal 这在术语上叫做连贯接口，这个功能让你直接构建管道，而不是每一步都使用本地变量 类型转换如果之前把代码分成了多个步骤，现在再把它改回来 12345678910111213[[[_phoneNumberTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @(value.length); &#125;] filter:^BOOL(NSNumber * length) &#123; return [length integerValue] &gt; 3; &#125;] subscribeNext:^(NSString * _Nullable x) &#123; // 这里实时的获取数据 NSLog(@\"the phone number is %@\",x);&#125;]; 新加的MAP 操作通过Block 改变了事件的数据，从字符串变成了NSNumbermap 从上一个next 事件接收数据，通过执行block 把返回的值传给下一个next 事件，在上面的\b代码中，map 以NSString 为输入，取字符串的长度，返回一个NSNumber 创建有效的状态信号首先要做的就是创建一些信号，然后通过这些信号来做相对应的处理 123456789101112131415RACSignal *phoneSignal = [_phoneNumberTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @([self isValidUserName:value]); &#125;]; RACSignal *captchaSignal = [_captchaTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return @([self isValidPassowrd:value]); &#125;]; [[phoneSignal map:^id _Nullable(id _Nullable value) &#123; return [value boolValue] ? [UIColor clearColor] :[UIColor yellowColor]; &#125;] subscribeNext:^(UIColor *color) &#123; self.passwordTextField.backgroundColor = color; &#125;]; 这里首先创建了信号，phoneSignal 在里面有一个map 主要是做\b校验，判断是否有效，然后返回了一个NSNumber 的值，提供给后续的next 进行操作 在第二步的时候，利用提供的值再进行map 来返回一个UIColor 的值，来对后续的subScribeNext 进行赋值的操作，然后对其进行backgroundColor的操作 所以上面的代码主要的实现就是，把之前的信号的输出应用到输入框的backgroundColor属性上，但是上面的用法不是很好。 幸运的是，ReactiveCocoa 提供了一个\b宏来帮助我们更好的完成上面的任务，把下面的代直接接到ViewDidLoad之后 123456/* RAC 宏 */ RAC(self.phoneNumberTextField,backgroundColor) = [phoneSignal map:^id _Nullable(NSNumber *passwordValid) &#123; return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor]; &#125;]; RAC 宏运行直接把信号的输出应用到对象的属性上，RAC宏有两个参数，第一个是需要设置的属性值对象，第二个数属性名，每次信号产生一个next事件，传递过来的\b值就会应用到属性上。 通过上面我们可以知道，如果我们有两个TextField 都需要实现相同的判断然后在进行颜色的设置。 聚合信号在例子中登录按钮是在用户名和密码校验完成后，才可以工作的。所以我们需要将两个信号进行聚合起来，然后共同满足后再做其他事情 \b1234RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[phoneSignal,captchaSignal] reduce:^id(NSNumber *userNameValid,NSNumber *passwordValid)&#123; return @([userNameValid boolValue] &amp;&amp; [passwordValid boolValue] );&#125;]; 上面的代码使用combineLatest:reduce:方法将ValidUserNameSignal 和 PassowrdValidSignal 产生最新的值聚合在一起，然后生成一个新的信号，每次这两个源信号的任何一个产生新值的时候，reduce block都会执行，Block 返回一个值会发送给下一个信号 现在已经有了合适的信号，然后我们需要的是\b让登录按钮是否有效 1234[signUpActiveSignal subscribeNext:^(NSNumber *signUpActive) &#123; self.signInButton.enable = [signUpActive boolValue];&#125;]; 上面展示了一些重要的概念，你可以使用ReactiveCocoa 来完成一些重量级的任务 分割 信号可以有很多subscriber ,也就是作为很多后续步骤的源， 聚合 多个信号可以聚合成一个新的信号 响应式的登录当我们的点击按钮可以用的时候，我们要做的事情就是点击登录按钮，执行登录的操作了 12345[[loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123; NSLog(@\"button clicked\"); &#125;]; 在这里点击的目的是为了实现能够进行网络登录的操作 我们来看看网络请求的函数： 12 我们看到，其中需要参数还设有就是返回的\bblock 创建信号在RAC 中将已有的异步API\b用信号来表示相当简单，首先添加下面的方法： 123456789-(RACSignal *)signInSignal&#123; return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@(YES)]; [subscriber sendCompleted]; return nil; &#125;];&#125; 上面的方法创建了一个信号 RACSignal 使用crateSignal 方法来创建一个信号，方法的入参是一个Block ,这个block 描述了这个信号，当这个信号有subscribers的时候，block里面的代码就会执行 block的入参是一个subscriber 的实例，它遵循RacSubScriber协议，协议有一些方法来参数时间，你可以发送人员数量的next事件，或者用error\\complete时间来终止， 这个Block的返回值是一个RACDispoable对象，它允许你在一个定义被取消的时候，执行一些清理操作，当前的信号不需要执行清理操作，所以返回nil就可以了 可以看到将一个异步的API进行封装是多么简单的事情 这时候就会出现了一种叫做信号中的信号的说法，也就是说一个外部信号里面还有一个内部信号，你可以在外部信号的subscribeNext:block里面订阅内部信号，不过这样\b且套太混乱了，还好RAC已经为我们解决了这个问题 信号中的信号解决的方法很简单，就是将map操作改为flattenMap 就可以了1234567[self loginButton rac_signalForControlEvents:UIControlEventTouchUpInside]flattenMap:^id(id x )&#123; return [self signInSignal];&#125;]subScribeNext:^(id x)&#123; NSLog(@\" Sign in result :\")&#125; 这里都已经差不多了，接下就就是将登录成后，调整的逻辑给加上就可以了，只需要在成功中添加对应的页面\b调整流程就可以了。 在这里我们需要注意以下，当登录的时候，登录按钮是不可点击的，这会防止用户多次执行登录操作，还有就是登录失败的话，用户再次尝试的时候，应该隐藏错误信息 添加附加操作不会改变事件本身的操作 DoNext 1234567891011[[[[checkButton rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(__kindof UIControl * _Nullable x) &#123; self.signInButton.enabled =NO; self.signInFailureText.hidden =YES; &#125;] flattenMap:^__kindof RACSignal * _Nullable(__kindof UIControl * _Nullable value) &#123; return [self signInSignal]; &#125;] subscribeNext:^(__kindof UIControl * _Nullable x) &#123; NSLog(@\"button clicked\");&#125;]; 从中可以看到doNext是直接跟在按钮点击事件的后面，而且doNext:block 是没有返回值的返回值的，因为它是附加的操作，并不改变事件本身。 上面的doNext:block Twitter Instant在这里我们要做的是通过搜索栏来进行搜索信息，然后将搜索出来的信息进行显示出来 验证搜索文本12345678@weakify(self);[[self.phoneNumberTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return [self isValidSearchText:value] ? [UIColor clearColor]: [UIColor redColor] ;&#125;] subscribeNext:^(id _Nullable x) &#123; @strongify(self); self.phoneNumberTextField.background = x;&#125;]; 上面的代码逻辑： 取走搜索文本框的信号量 把它转换为一下，用背景色来预示内容是否可用 然后设置backgroundColor属性在subscribeNext：block里面 Formatting of PipeLines当你正在专研格式化的ReactiveCocoa\b代码的时候，普遍接受的惯例就是：每一个操作在一个新航，和所有步骤都是垂直对齐的 这样就能够更清楚的看到该组成管道的操作，另外在block中用最少的代码，任何超过几行的都应该查分出一个私有方法 Memory Management如果有一个或者多个subscribers ，信号就会变成活跃。如果所有的订阅者都移除了，信号就会被释放 当一个completed或者error事件之后，订阅会自动移除，手工的移除将会通过RACDispoable 所有的RacSignal的订阅方法都会返回一个RACDispoable实例，它允许你通过处置方法手动移除订阅。 12345678910@weakify(self); RACDisposable *subscription = [[self.phoneNumberTextField.rac_textSignal map:^id _Nullable(NSString * _Nullable value) &#123; return [self isValidSearchText:value] ? [UIColor clearColor]: [UIColor redColor] ; &#125;] subscribeNext:^(id _Nullable x) &#123; @strongify(self); self.phoneNumberTextField.background = x; &#125;]; [subscription dispose]; 避免循环引用当ReactiveCocoa 在场景背后做了很多聪明的事情，这就意味着你不必担心太多信号量的内存管理 在RAC中可以使用@\bweakify 和 @strongify 来避免循环引用的操作 \b获取请求操作1234567891011121314151617-(RacSignal*)requestAccessToTwitterSignal&#123; @weakify(self) return [RacSignal createSignal:^RACDispoable *(id subscriber)&#123; @strongify(self) [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType option:nil completion:^(BOOL granted,NSError *error)&#123; if(!granted)&#123; [subscriber sendError:accessError]; &#125;else&#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; &#125; &#125;]; return nil; &#125;];&#125; 1.类方法createSignal 返回一个RACSignal 的实例 一个信号可以发出三种不同的事件：next completed error 超过了signal 的生命周期，它将不会\b发出任何信号事件 1234567[[self requestAccessToTwitterSignal] subScribeNext:^(id x)&#123; NSLog(@\"access granted\"); &#125;error:^(NSError *error)&#123; NSLog(An Error occuount ); &#125;]; Chaining signal这时候，如果请求的结果成功返回了以后，我们肯定需要做一些其他的操作来执行后续的操作。 下面的操作是 在请求访问Twitter 后发出completed 事件，然后订阅TextField 的信号。不同信号连续的链，有一个共有的问题，但是ReactiveCocoa 处理起来非常的 这里通过then 的方式来讲信号进行转换成另外一个链进行操作，当然这里then 会一直等待到complete的返回，然后再进行相关的操作 12345678910111213141516171819@weakify(self)[[[[self requestAccess] then:^RACSignal * _Nonnull&#123; // 这个方法会一直等待，直到completed 事件发出 return [[RACSignal alloc] init]; &#125;] filter:^BOOL(NSString *text) &#123; // 这里的信号是 新创建的信号 @strongify(self) // 在这里做判断的操作 [self getUserInfo]; return YES; &#125;] subscribeNext:^(id _Nullable x) &#123; // 这里是针对正确的操作 &#125;error:^(NSError * _Nullable error) &#123; // 这里是针对错误的操作 &#125;]; Threading在上面的操作过程中，我们的执行都是在非主线程进行工作的，如果需要在更新UI进行工作，我们需要将线程切换到主线程才能进行更新UI的操作 在RAC 中提供了一个方法可以让我们切换到主线程中12345678910111213141516@weakify(self)[[[[[[self signalForSearchWithText:searchText] then:^RACSignal * _Nonnull&#123; return [[RACSignal alloc] init]; &#125;]filter:^BOOL(id _Nullable value) &#123;// @strongify(self) return YES; &#125;]flattenMap:^__kindof RACSignal * _Nullable(NSString *text) &#123; @strongify(self) return [self requestAccess]; &#125;]deliverOn:[RACScheduler mainThreadScheduler]// 这是将其添加到主线程的操作 ]subscribeNext:^(id _Nullable x) &#123; // 正确的选项 &#125;error:^(NSError * _Nullable error) &#123; // 错误的选项的操作 &#125;]; Asynchronous Loading of Images1234567891011121314151617181920212223-(RACSignal*)loadingImage:(NSString *)url&#123; // 这是后台的线程 RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityBackground]; return [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:[UIImage new]]; [subscriber sendCompleted]; return nil; &#125;] subscribeOn:scheduler];// 将其进行调度&#125;// 运用操作-(void)userAsyncLoadImage&#123; [[[self loadingImage:@\"imageUrl\"] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(UIImage *image) &#123; // 这里针对的是UIImage 的运用 &#125;];&#125; Throttling你可能注意到这个问题：每次输入一个字符串都会立即执行然后导致刷新太快，导致每秒都会显示几次搜索结果，这不是理想的状态 一个好的解决方案就是如果搜索的内容不变之后的时候，间隔后在\b搜索 比如 500 毫秒 123456789101112131415161718@weakify(self)[[[[[[[self signalForSearchWithText:searchText] then:^RACSignal * _Nonnull&#123; return [[RACSignal alloc] init]; &#125;]filter:^BOOL(id _Nullable value) &#123;// @strongify(self) return YES; &#125;]throttle:0.5] // 这是一个延时的操作 500ms 只有在这段时间没有接受到next 才会发送next flattenMap:^__kindof RACSignal * _Nullable(NSString *text) &#123; @strongify(self) return [self requestAccess]; &#125;]deliverOn:[RACScheduler mainThreadScheduler]// 这是将其添加到主线程的操作 ]subscribeNext:^(id _Nullable x) &#123; // 正确的选项 &#125;error:^(NSError * _Nullable error) &#123; // 错误的选项的操作 &#125;]; RAC 组件RACSubject是一个可变的信号，或者说是自定义的信号。它是嫁接非RAC 的代码到signal 世界的桥梁。 Flattening 12345678910111213141516171819202122232425&#123; RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:letters]; [subscriber sendNext:numbers]; [subscriber sendCompleted]; return nil; &#125;]; // RACSignal *flatendSignal = [signalOfSignals flatten]; // Output:A 1 B C 2 [flatendSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\",x); &#125;]; [letters sendNext:@\"A\"]; [numbers sendNext:@\"1\"]; [letters sendNext:@\"B\"]; [letters sendNext:@\"C\"]; [letters sendNext:@\"2\"]; &#125; Merging 12345678910111213141516171819&#123; RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; RACSignal *mergedSignal = [RACSignal merge:@[letters,numbers]]; // outputs :A 1 B C 2 [mergedSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\",x); &#125;]; [letters sendNext:@\"A\"]; [numbers sendNext:@\"1\"]; [letters sendNext:@\"B\"]; [letters sendNext:@\"C\"]; [numbers sendNext:@\"2\"]; &#125; combining Lastes values +combineLastest :任何时刻只取出最后的那个玻璃球 123456789101112131415161718192021&#123; RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; RACSignal *combined = [RACSignal combineLatest:@[letters,numbers] reduce:^(NSString *letter,NSString *number)&#123; return [letter stringByAppendingString:number]; &#125;]; // OutPut: B1 B2 C2 C3 [combined subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\",x); &#125;]; [letters sendNext:@\"A\"]; [letters sendNext:@\"B\"]; [numbers sendNext:@\"1\"]; [numbers sendNext:@\"2\"]; [letters sendNext:@\"C\"]; [numbers sendNext:@\"3\"]; &#125; Switching -switchToLatest: 取指定的那个水龙头的吐出的玻璃球 123456789101112131415161718192021222324&#123; RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; RACSubject *signalOfSignals = [RACSubject subject]; RACSignal *switched = [signalOfSignals switchToLatest]; [switched subscribeNext:^(id _Nullable x) &#123; NSLog(@\"%@\",x); &#125;]; [signalOfSignals sendNext:letters]; [letters sendNext:@\"A\"]; [letters sendNext:@\"B\"]; [signalOfSignals sendNext:numbers]; [letters sendNext:@\"C\"]; [numbers sendNext:@\"1\"]; [signalOfSignals sendNext:letters]; [numbers sendNext:@\"2\"]; [letters sendNext:@\"D\"]; &#125; 参考ReactiveCocoa 学习之路(史上最全攻略)ReactiveCocoa入门教程：第一部分ReactiveCocoa入门教程：第二部分","categories":[],"tags":[]},{"title":"","slug":"iOS 面试","date":"2018-07-10T02:54:55.000Z","updated":"2018-07-26T10:48:15.000Z","comments":true,"path":"2018/07/10/iOS 面试/","link":"","permalink":"http://yoursite.com/2018/07/10/iOS 面试/","excerpt":"","text":"iOS 面试1.希望其分析其做过的一个APP的页面结构，以便了解其对页面的构造和布局和数据处理能力。(考察业务能力)2.考察一个面试者基础咋样，基本上问一个 @property 就够了：(基础问题) @property 后面可以有哪些修饰符？ 什么情况使用 weak 关键字，相比 assign 有什么不同？ 怎么用 copy 关键字？ 这个写法会出什么问题： @property (copy) NSMutableArray *array; 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的： @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @protocol 和 category 中如何使用 @property 3.你是如何实现网络请求操作的，可以描述下其流程吗？如果有使用过一些框架也可以让其对框架的流程进行讲解， 4.对多线程了解多少？针对多线程分别讲述下，你对他们的认识(优缺点)？主要针对 NSTimer 和 NSOprationQueue 以及 GCD 的认识和了解 5.UIView和CALayer是啥关系?平时是否有一些图形化操作？能答出UIView是CALayer的delegate就及格了，能说出UIView主要处理事件，CALayer负责绘制就更好 6.描述一个你遇到过的retain cycle例子。(肯定遇到过)说没遇到过的我很难相信你有过成熟项目的经历。这题答不出了会扣很多很多分。用过block，写过delegate的肯定都踩过坑。 7.你有使用过runtime吗？如何使用？如果有使用过，可以追加： 7.1：什么是method swizzling? 7.2：+(void)load; +(void)initialize；有什么用处？ 8.runloop和线程之间的关系？你有使用过吗？如何使用？主要判断其是否对runloop\b有所了解 9.麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的）主要考察逻辑： 10.程序架构和一些设计模式如果面试者自己觉得还不错的话也可以聊聊；架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解。(加分题)","categories":[],"tags":[]},{"title":"网络基础知识","slug":"ios-http-review","date":"2018-07-09T03:48:17.000Z","updated":"2018-07-26T10:48:43.000Z","comments":true,"path":"2018/07/09/ios-http-review/","link":"","permalink":"http://yoursite.com/2018/07/09/ios-http-review/","excerpt":"摘要： 在开发过程中很多看到关于TCP/IP 还有就是HTTP 和 HTTPS 的连接过程等操作，同时也面试的过程中也会经常问到关于他们的地方，这里简单的做一个总结。","text":"摘要： 在开发过程中很多看到关于TCP/IP 还有就是HTTP 和 HTTPS 的连接过程等操作，同时也面试的过程中也会经常问到关于他们的地方，这里简单的做一个总结。 HTTP 和 HTTPS 的区别http协议运行在TCP之上，明文传输，客户端和服务器端都无法进行验证对方的身份，HTTPS是身披SSL外壳的HTTP\b运行在SSL之上，SSL运行在TCP之上，是添加了加密和认证机制的HTTP，两者之间存在了如下不同： 端口不同：HTTP与HTTPS使用不同的连接方式，用的端口分别是80和443 资源消耗不同：和HTTP通信相比，HTTPS通信会由于加减密的处理消耗更多的CPU和内存的资源。 开销：HTTPS 通信需要\b证书 TCP的三次握手(我想要和你连接，你确定要和我连接， 是的，我要和你连接(成功)) 第一次握手：Client 将标志位SYN置为1，随机产生一个值seq=0 \b然后将数据发送给Server,Client进入到SYN_SENT的状态 等待Server的确认 第二次握手：Server 收到数据包后由于标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=0+1 随机产出一个随机数seq=k 并将该数据包发送给Client 以确认连接的请求，Server进入到SYN_RCVD 第三次握手：Client 收到却后，检查ack是否为0+1 ACK是否为1，如果正确则将标志位ACK置为1，ack为k+1 \b并将该数据包发送给Server ,Server检查ACK 下面说说ACK 和 SEQ 中的关联：如果我发送一个请求seq是4 那么下次返回的ACK 就必须是这个，这样我们才能确认你是针对我的这次请求的返回的操作 TCP的四次挥手(我要和你断开连接，好的断吧，我也要和你断开连接，好的断吧) 第一次挥手：Client 发送一个FIN 用来关闭Client 到 Server的数据传送，Client 进入 FIN_WAIT_1的状态第二次挥手：Server 收到FIN 后，发送一个ACK给Client ,Server 进入到CLOSE_WAIT 状态，此时TCP的连接处于半关闭的状态也\b就是客户端已经没有要发送的数据了，但是服务器如果有数据发送的话，客户端仍要接收、第三次挥手：Server 发送一个FIN 后，\b用来关闭Server到Client 的数据传送，Server进入到LAST_ACK 状态第四次挥手：Client 收到FIN 后，Client 进入到TIME_WAIT状态，接着发送一个ACK 给Server 确认序号，这时候Server进入Close的状态，完成四次挥手 为什么TCP连接需要三次握手，两次不可以吗？为什么？为了防止已经失效的连接请求突然又传到服务器，因而产生错误 客户端发出的连接请求报文并未\b丢失，而是在某个网络节点长时间的滞留，从而导致延误到连接释放后的某个事件才到\bServer 。这是Server 误认为这是Client的一个\b连接请求，于是就向客户端发送一个确认请求的数据包，同意建立连接。如果不采用“三次握手的话”，那么只要Server 发出连接请求报包后，服务器就会建立一个新的连接。但是这时候Client 并没有发出请求\b连接的请求，所以不会理睬Server的确认，也就\b不会与Server进行通信了，在这个时候Server一直等待Client的请求，这样Server就白白的浪费了一定的资源，如果采用\b三次握手的话，服务器\b没有收到客户端的确认，就会知道Client 没有建立请求，就不会建立\b连接。 TCP和UDP的区别TCP 是连接状态的，而UDP 是非连接状态的 TCP 对数据的传输有保障，而UDP 不会对数据传输有保障 TCP 是一对一的，UDP 可以\b一对多，多对多传输 HTTPS的流程 接下来看看其流程： 然后我们再通过WireShake来进行分析： 这图中显示了Https的\b连接的流程 1.首先客户端发送一个Client Hello.先来看看Client Hello 中SSL层 接下来我们分析下： 在这里主要是将客户端中的支持的TLS的版本(Version ：TLS 1.2)，生成的随机数(Random)，还有就是支持的加密的算法（Cipher Suites），已经支持的压缩方式(Compressiong Methods)，还有一些扩展，发送给服务器 当服务器收到客户端的请求的时候，就会向客户端发送server Hello 2. 服务端发送一个Server Hello 在这个阶段，服务主要做的事情是： 确认使用的加密通信协议，比如：TLS 1.2 ,如果浏览器和服务器支持的版本不同，服务器将关闭加密通信 一个服务器生成的随机数random2 ,稍后用于生成\b“对话秘钥” 确认使用加密的方法 服务器的证书 展开SSL的数据段，可以看到服务器支持的TLS版本为1.2.也可以看到服务器生成的随机数用于生成对话的秘钥。下面还有加密套件的信息，这里的加密套件表示使用RSA公钥算法来验证证书已经交换秘钥，用AES加密算法对数据进行加密，使用SHA算法来校验消息内容 3.客户端发送一个clent key exchangeclient_key_exchange 客户端收到证书之后会首先验证 验证流程 客户端收到服务器的相应后，首先验证服务器的证书，如果证书不是由可信任的机构颁发的，或者证书中的域名与实际的域名不一致，或者证书已经过期，就会向访问者显示一个警告，\b由访问者选择是否还要继续通信，如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后向服务器发送一条信息，包括用服务器公钥加密的随机数，编码改变通知和客户端握手结束通知 生成随机数 验证通过之后，客户端会生成一个随机数pre-master secret ,然后使用证书中的公钥进行加密，然后传递给\b服务器端 4.服务端发送一个 change Cipher Specchange_cipher_Spec 在服务器端收到公钥加密的内容，在服务端使用功能私钥进行解密随后会获得随机数pre-master secret 然后根据random1,random2，pre-master\b secret 通过一定的算法得出session key和 MAC 算法秘钥，作为后面交互过程中使用的对称秘钥，同时客户端也会使用random1,random2，pre-master secret ，和同样的算法生成session key 和Mac 算法的信息 然后结束会话。 5. 然后在后续的交互中使用session key 和MAC 算法的秘钥对传输的内容进行加密和解密 具体的步骤是先使用MAC 秘钥对内容进行摘要，然后把摘要放在内容的后面使用sessionKey 再进行加密。对于客户端发送的数据，服务端收到之后，需要先使用client_write_key进行解密，然后使用Client_write_MAC_key对数据完整性进行校验。服务端发送的数据客户端会使用Server_write_key和Server_write_MAC_key进行相同的操作 对称加密和非对称加密对称加密: 就是加密和解密都是用一个秘钥，这种方式优点就是速度快，缺点就是在管理和分配秘钥的时候不安全。 非对称加密： 非对称加密就是一个秘钥对，叫做公钥和私钥，私钥自己持有，公钥可以发送给其他人使用，使用公钥进行加密的信息，只有何其配对的私钥可以解开。目前常见的非对称加密算法是RSA，非对称加密的优点是安全，因为它不需要把私钥暴露出去。 在正式的使用场景中一般都是对称加密和非对称加密结合使用，使用非对称加密完成秘钥的传输，然后使用对称秘钥进行数据加密和解密 参考：Https流程和原理wireshark学习笔记(四)——HTTPS协议分析","categories":[],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/tags/网络基础/"}]},{"title":"Block 原理分析详解","slug":"block-detail-configure","date":"2018-06-11T06:53:40.000Z","updated":"2018-08-03T10:45:10.000Z","comments":true,"path":"2018/06/11/block-detail-configure/","link":"","permalink":"http://yoursite.com/2018/06/11/block-detail-configure/","excerpt":"摘要： 这里主要是通过反编译的方式，来对Block进行阐述。针对不同的Block中的处理中Block是如何体现在我们的代码中的。这里\b我们先从使用的角度来入手，然后我们通过反编译来对block 进行一步一步的解析","text":"摘要： 这里主要是通过反编译的方式，来对Block进行阐述。针对不同的Block中的处理中Block是如何体现在我们的代码中的。这里\b我们先从使用的角度来入手，然后我们通过反编译来对block 进行一步一步的解析 1.基本说明在iOS4.0 以后，Block 横空出世，它本身封装了一段代码并将代码作为变量，通过block()的方式进行回调，不免让我们想到C函数 block和函数指针的区别： block 的代码是内联的，效率高于函数 block 对外部变量\b默认是只有只读属性,如果需要读取的话就需要使用__block 来进行实现 block 被 Objective-C 看成是对象处理 2.block的特性 认识block 先从block的声明和定义说起，便于我们更好的理解block 1234int (^sumOfNumbers)(int a, int b) = ^(int a, int b)&#123; return a + b;&#125; 在这段代码中，我们定义了一个block 名字叫做 sumOfNumbers，名称前面的^ 表示后面的是block 的名称，最左侧的 int 表示的是返回值，然后在名称的后面两个int 分别表示的是参数 用括号包起来 。在等号的右侧 表示的是block 的定义，其中返回值是可以省略的，编译器会根据上下文自动补充返回值的类型。使用^ 衔接这一个参数列表，使用括号起来，\b告诉编译器这是一个 block ,然后使用大括号将 block 的代码封装起来 这个block 如果经过一个反编译的话，会出现 12345struct __block_impl; 这是一个结构体，用来存放一些isa 和 FuncPtrstatic __main_block_func_0 这个就是具体实现的函数了struct __main_block_impl_0 这个就是实现的操作，其中有两个变量 分别是DESC 和 impl 还有就是它的初始化函数struct __main_block_desc_0 这里主要是用来描述block 的内存大小的 这个在后续有详细介绍，接着往下看… 捕获外界变量 block 可以访问外部的局部变量，但这里只能是读的属性，如果需要修改局部变量的话会导致错误的产生，当然如果你真的是需要修改 block 的话，那么你需要用到 __block 修饰符来修改你需要修改的变量 当然 block 在使用变量的时候，是保存期当时的变量值，即使后面对变量发生修改了以后也不会对block 里面的结果产生改变的 123456789CGPoint center = CGPointzero();CGPoint (^poingAddHandler)(CGPoint addPoint) = ^(CGPoint addPoint)&#123; return CGPointMake(center.x+addPoint.x,center.y+addPoint.y);&#125;center = CGPointMake(100,100);poingAddHandler(CGPointMake(10,10)); 这时候产生的结果是 10，10 使用__block 后的操作 123456789101112 __block CGPoint center = CGPointZero;CGPoint (^pointAddHandler)(CGPoint addPoint) = ^(CGPoint addPoint)&#123; CGPoint point = CGPointMake(center.x+addPoint.x,center.y+addPoint.y); return point;&#125;;center = CGPointMake(100,100);pointAddHandler(CGPointMake(10,10)); 这时候的结果是 110，110 循环引用 在iOS 中block 被当做一个对象一样存在，因此其生命周期会一直等到持有者生命周期结束才结束，另一方面，由于 block 捕获变量的机制，使得持有 block 的对象也可能被 block 持有，从而形成循环引用 遇到这种情况，需要使用__weak 来进行一个弱引用的操作 12__weak typeof(self) weakSelf = self; 3.block 的使用block的回调 通过关键字来声明block 1234567typedef void(^handlerBlock)(NSData *data,NSerror *error);typedef void(^progressHanler)(CGFloat progress);-(void)downLoadWithUrl:(NSURL *)url params:(id)params complete:(handlerBlock)hanler progress:(progressHanler)progress;这个我们在网络请求的过程中，经常可以看到，通过放入url 和参数 然后我们获取返回的结果。 链式编程 也就是我们\b常见的.编程,这样的话可以使得可读性更强，同时针对编程来说也比较简洁方便很多。 这种编程方式的条件之一就是：\b\b每次函数调用必须有返回值 可以返回自己也可以返回其他的都可以，只要后续还能保证其继续的操作就可以。 _baby.having(self.currPeripheral).and.channel(channelOnDetailView).then; 12345678910111213141516171819202122232425262728//持有对象- (BabyBluetooth *(^)(id obj)) having &#123; return ^(id obj) &#123; [babyCentralManager-&gt;pocket setObject:obj forKey:NSStringFromClass([obj class])]; return self; &#125;;&#125;//切换委托频道- (BabyBluetooth *(^)(NSString *channel)) channel &#123; return ^BabyBluetooth *(NSString *channel) &#123; //先缓存数据，到begin方法统一处理 [babyCentralManager-&gt;pocket setValue:channel forKey:@\"channel\"]; return self; &#125;;&#125;- (BabyBluetooth *) and &#123; return self;&#125;- (BabyBluetooth *) then &#123; return self;&#125;- (BabyBluetooth *) with &#123; return self;&#125; 这样就会对链式编程有更好的理解，其中他们的返回值都是 self ,然后继续通过链式的方法进行编辑就可以了。 4.block 的解析下面我们将通过对objctive-c 的进行反编译来查看其内部的实现 比如：我们定义一个block ,并且值对其进行简单的赋值操作 void (^blk)(void) 解析12345678910int main&#123; void (^blk)(void) = ^()&#123; int i = 1; &#125; blk(); return 0;&#125; 下面是转换后的代码： 1234567891011121314151617181920212223242526272829303132333435struct __block_impl&#123; void *isa; // 从这个可以表明这是一个\b对象 int flags; int reserved;// 保留的 void *FuncPtr;// 对应的函数实现&#125;static void __main_block_func_0(struct __main_block_imp_0 *__cself)&#123; int i = 1;&#125;static strict __main_block_desc_0&#123; size_t reserved; size_t Block_size; // 反应block 的大小&#125;struct __main_block_imp_0&#123; struct __block_impl impl; struct __main_block_desc_0 *Desc; __main_block_imp_0(void *fp,sturct __main_block_desc_0 *desc ,int flags = 0)&#123; impl.isa = &amp;_NSConcreteStackblock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;int main()&#123; void (*blk)(void) = (void(*)()) &amp; __main_block_imp_0((void*)__main_block_func_0,&amp;__main_block_desc_0.) ; (void(*)(__block_impl *))(__block_impl)blk)-&gt;FuncPtr(__block_impl*)blk);&#125; main 函数入口。我们可以发现这个函数里面主要初始化一个__main_block_imp_0的结构体，并且调用结构体中的FuncPtr方法 main_block_imp_0 结构体 。这个结构体有一个block_impl 和 __main_block_desc_0 结构体，以及一个初始化函数 __block_impl 结构体。这个结构体有四个变量，其中我们可以发现有两个很关键的isa 和 FuncPtr __main_block_desc_0 结构体。这个结构体包含了两个size_t类型的属性，用于记录Block 内存的大小 __main_block_func_0 静态方法。我们发现这个方法就是Block的具体实现 从上面我们可以大体的分析下block 的内存结构\b: 首先需要一个实现，一个描述，还有一个函数\b来进行操作 在实现中有一个初始化的函数，其中需要用到block_impl 和 \bmain_block_desc_0 这两个参数来进行构建，其中在__block_impl 中包含了isa 和 FuncPtr 这两个变量，都是在初始化的过程中进行实现的 然后需要一个具体的实现函数：main_block_func_0 这个函数的参数就是\bmain_block_imp_0 4.1 具体流程分析首先是main 函数的代码： 简化后：12345struct __main_block_imp_0 tmp = __main_block_imp_0((void)__main_block_func_0,&amp;__main_block_desc_0);struct __main_block_imp_0 *blk = &amp;tmp;(blk-&gt;impl.FuncPtr)(blk) 1.首先初始化一个main_block_impl_0 结构体变量，并传入的参数是main_block_func_0指向结构体的具体实现。 main_block_desc_0_DATA 是 main_block_desc_0结构体的一个变量，主要是指定结构体的大小。 2.将tmp的地址赋值给blk指针 3.通过blk 找到他的impl 属性，然后通过impl这个_block_impl 变量获取FuncPtr 函数的地址，然后传入\bblk 的指针作为参数，从而实现OC中的blk() 接下来再分析下 __main_block_impl_0 这个结构体 1234567891011struct __main_block_imp_0 &#123; struct __block_impl impl; struct __main_block_desc_0 *Desc; __main_block_imp_0(void *fp , __main_block_desc_0 *desc ,int flags = 0)&#123; impl.isa = &amp;_NSConcreteStackblock; impl.FuncPtr = fp; impl.flags = flags' Desc = desc; &#125;&#125; 这个结构体主要有一个初始化的函数，通过传入结构体具体的实现的函数指针fp,记录大小秒速信息的参数desc 和一个标记的flags .通过他来初始化block_impl和main_block_desc_0. __block_impl 这个结构体我们从他的结构发现和OC的类结构体优点像，它的\bisa属性其实即使OC的isa属性有异曲同工的作用，用于指向结构体的具体类型，FuncPtr 函数指针即使指向Bloc具体实现的函数 int (*block) (int)类型解析这时候和上面的区分主要是在__main_block_func_0 的实现上 123456789static int __main_block_func_0(struct *__main_block_imp_0 *__cself,int i)&#123; int resutl = i+1; return result;&#125;然后在main函数里面添加一个参数就可以了(*blk-impl.FuncPtr)(blk,3); 其他都是一模一样的 带__block 变量的void (*block)(void)类型解析通过代码来解析： 1234567891011121314151617typedef void(^Block)();int main()&#123; @autoreleasepool&#123; __block int i= 1; Block block = ^()&#123; int i = 2; prinf(\"%d\",i); &#125; block(); &#125; return 0;&#125; 转换后的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394在这里主要针对之前的进行区分，便于理解typedef void (*Block)();struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;//这个结构体是专门为了__block 变量i 直接生成的struct __Block_byref_i_0&#123; void *__isa; __Block_byref_i_0 *__forwarding; int __flags; int __size; int i;&#125;// 多了一个__Block_byref_i_0变量struct __main_block_imp_0&#123; struct __block_impl impl; struct __main_block_desc_0 Desc; __Block_byref_i_0 *i;// 多了一个i的属性。block 变量 __main_block_imp_0(void *fp,struct __main_block_desc_0 *desc ,__Block_byref_i_0 *_i,int flags = 0):i(_i-&gt;__forwarding)&#123; impl.isa = &amp;_NSConcreteStackblock; impl.flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;// Block 的具体实现，从这里我们发现为啥i的值的猫腻static void __main_block_func_0 (struct __main_block_imp_0 *__cself)&#123; __Block_byref_i_0 *i = __cself-&gt;i; (i-&gt;__forwarding-&gt;i ) = 2; printf(\"%d\",(i-&gt;__forwarding-&gt;i));&#125;// 这里是管理变量i 的声明周期的地方，分别是copy 和销毁的时候的操作static void __main_block_copy_0(struct __main_block_imp_0 *dst,struct __main_block_imp_0 *src)&#123; __Block_object_assign((void*)&amp;dst-&gt;i,(void*)&amp;src-&gt;i,8);&#125;static void __main_block_dispose_0(struct __main_block_imp_0 *src)&#123; __Block_object_dispose((void*)&amp;src-&gt;i,8);&#125;// 在desc 中也多了两个指针函数static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size; void(*copy)(struct __main_block_imp_0 *,struct __main_block_imp_0 *); void(*dispose)(strict __main_block_impl_0 *);&#125;// 实例变量struct __main_block_desc_0 __main= &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;_block_desc_0_DATAint main()&#123; // 自动释放出 &#123;__AtAutoreleasePool __AtAutoreleasePool; // 定义一个__Block_byref_i_0 结构变量，并且初始化 __Block_byref_i_0 i; i = &#123;(void*)0,(__Block_byref_i_0*)&amp;i,0,sizeof(__Block_byref_i_0),1&#125; // 定义一个__main_block_impl_0的结构体变量，同时传入i的指针 __main_block_impl_0 tmp = __main_block_imp_0((void*)__main_block_func_0,&amp;__main_block_desc_0_Data,(__Block_byref_i_0)i,flag); Block block1 = &amp;tmp; ((block1-&gt;imp)-&gt;FuncPtr)(block1); &#125;&#125; 我们发现加入了一个__block 之后，代码变得多了下，同时也多原来的函数也添加了一下变量 多了一个针对block 变量的结构体 Block_byref_i_0 .这个结构体就是__block 变量直接生成的 多了两个静态函数 main_block_copy_0 和 main_block_dispose_0 .这两个函数主要用于处理block 复制的时候，对应的___block 变量i的处理 main_block_impl_0 里面多了一个Block_byref_i_0 类型的属性 i,这个I 就是对应Block里面的变量 __main_block_desc_0 多了两个函数，copy 和 dispose .在初始化结构体的时候，传入上面新增的两个函数作为参数。 每个block 变量都会生成一个新的结构体，并且作为main_block_impl_0结构体的属性 通过对结构体main_block_impl_0 的初始化函数和main_block_func_0方法的分析结构体的属性 block 变量i在转换为C语言后直接转换为一个Block_byref_i_0 类型的结构体 main_block_imp_0 结构体中的i指针用于存储 block 结构体中的变量，也就是\b block里面的那个i对象 block 外面的那个i 其实就是block 里面的i变\b量通过 i-&gt;forwarding-&gt;i 来获取的。当我们在block 里面要改变i的值的时候，其实就是间接的通过 i-&gt;forwarding-&gt;i 来改变的。其中第一个i是block 里面的变量，第二个i 是block 外面的变量。这样就解释了为什么block 里面改变的i 的值block 外面也会发生改变 \b带全局变量、静态全局变量、局部全局变量的类型Block解析直接上代码然后再分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112int global_val = 1;static int static_global_val = 2;int main()&#123; @autoreleasepool&#123; __block int one = 1; static int static_val = 1; Block block1 = ^()&#123; one = 2; global_val = global_val +1; static_global_val = static_global_val +1; static_val = static_val +1; &#125; block1(); &#125;&#125;// ======== 反编译后的代码 ==========typedef void (*Block)();// 全局变量和静态全局变量的用法没有任何转变int global_val = 1;static_global_val = 2;strict __block_impl&#123; void *isa; int flags; int Reserved; void *FuncPtr;&#125;// 接下来是变量onestruct __Block_byref_one_0&#123; void *__isa; __Block_byref_one_0 *__forwarding; int __flags; int __size; int one;&#125;// 接下来是具体的impl的实现struct __main_block_impl_0&#123; // 需要用到 desc ，impl 还有一个变量，已经初始化的操作 struct __block_impl impl; struct __main_block_desc_0 desc; int *static_val ;//局部静态变量的指针作为结构体的一个属性 __Block_byref_one_0 *one// by ref __main_block_impl_0(void *fp ,struct __main_block_desc_0__main_block_desc_0_DATA,int *static_val,__Block_byref_one_0 *one,int flags = 0):static_val(_static_val),one(_one-&gt;__forwarding)&#123; impl.isa = &amp;_NSConcreteStackblock; impl.Flags = flag; impl.FuncPtr = fp; Desc = desc; &#125;&#125;// 具体实现的函数static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; __Block_byref_one_0 *one = __cself.one; int *static_val = __cself-&gt;static_val; (one-&gt;__forwarding-&gt;one) = 2; global_val = global_val +1; static_global_val = static_global_val; (*static_val) = (*static_val) +1;&#125;// 然后是针对变量one 的声明周期的 copy 和 disposestatic void __main_block_copy_0(struct __main_block_im *dst, struct __main_block_impl_0 *src)&#123; __Block_object_assign(()) &#125;static void __main_block_dispose_0(struct __main_block_impl_0 *src)&#123; __Block_object_dispose((void*)src-&gt;one ,8);&#125;static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0* ,struct __main_block_impl_0 *); void (*dispose)(struct __main_block_impl_0 *);&#125; __main_block_desc_0_DATA = &#123; 0,ziseof(struct __main_block_impl_0),__main_block_copy_0,__main_block_dispose_0&#125;int main()&#123; &#123; __AtAutoreleasePool __autoreleasepool; static int static_val = 2; __main_block_impl_0 tmp = __main_block_impl_0((void *)__) Block block = (void(*)())tmp; block-&gt;(__block_impl)impl-&gt;Funcptr(block); &#125;&#125; 感谢Block原理分析详解 objc 中的 block","categories":[],"tags":[{"name":"iOS Block","slug":"iOS-Block","permalink":"http://yoursite.com/tags/iOS-Block/"}]},{"title":"AFNetworking-AFSecurityPolity","slug":"AFNetworking-AFSecurityPolity","date":"2018-06-11T03:42:25.000Z","updated":"2018-06-11T03:42:25.000Z","comments":true,"path":"2018/06/11/AFNetworking-AFSecurityPolity/","link":"","permalink":"http://yoursite.com/2018/06/11/AFNetworking-AFSecurityPolity/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS 多线程","slug":"ios-threads-detail","date":"2018-06-08T03:19:22.000Z","updated":"2018-06-08T08:32:30.000Z","comments":true,"path":"2018/06/08/ios-threads-detail/","link":"","permalink":"http://yoursite.com/2018/06/08/ios-threads-detail/","excerpt":"摘要： 关于多线程的操作，更多是为了提高运行的效率，同时也是为了给主线程减轻负担，避免将所有的操作都归主线程来进行操作，可以将其他一些不需要界面的操作交给其他线程来进行操作。同时在针对线程进行管理的时候，不同的线程对象有不同的操作。针对不同的操作，我们还需要根据需求来进行选取正确的线程\b对象来进行操作。这个文章将通过对\b现有的线程对象进行分析，然后总结在\b其的用途和其提供的接口。以便在遇到需求的时候更加方便的知道应该使用那些线程来进行操作。","text":"摘要： 关于多线程的操作，更多是为了提高运行的效率，同时也是为了给主线程减轻负担，避免将所有的操作都归主线程来进行操作，可以将其他一些不需要界面的操作交给其他线程来进行操作。同时在针对线程进行管理的时候，不同的线程对象有不同的操作。针对不同的操作，我们还需要根据需求来进行选取正确的线程\b对象来进行操作。这个文章将通过对\b现有的线程对象进行分析，然后总结在\b其的用途和其提供的接口。以便在遇到需求的时候更加方便的知道应该使用那些线程来进行操作。 基本概念在进行开发之前我们先了解一些基本术语，方便更好的理解文章的内容。 进程：一个具有独立功能的程序，可以理解为一个\b运行中的应用程序线程：程序执行的最小单元，线程是进程中的一个实体 (一个进程会存在一个主线程(UI线程))同步：\b操作是按照先后顺序执行的异步：操作的执行顺序是不分先后的队列：控制线程的执行顺序 （FIFO）并发：线程的执行顺序可以同时一起进行执行串行：线程执行职能依次按照先后顺序执行的 注意： 一个进行有多个线程 一个进行可以有多个队列 多线程的对比1.NSThread每个NSThread对象对应一个线程，真正最原始的线程。 优点：NSThread 轻量级最低，相对简单缺点：手动管理所有的线程活动，如生命周期、线程同步、睡眠。 2.NSOperation自带线程管理的抽象类 优点：自带线程周期管理，操作上可以更加注重自己的逻辑缺点：面向对象的抽象类，只能使用它或者它定义好的两个子类：NSInovactionOperation 和 NSBlockOperation 3.GCDGCD是Apple \b开发的一个多核编程的解决方法。 优点： 最高效，避免并发陷阱缺点: 基于C实现 4.选择小结 简单而且安全的选择 NSOperation 实现多线程就可以 处理大量并发数据，又追求性能效率的选择GCD NSThread本人选择基本上\b就是啊在做一些小测试的时候使用 NSThread现在我们讨论下这个对象，NSThread 从属性和方法来进一步解析这个对象，便于我们后续的使用 属性线程的获取 主要分为当前线程和主线程 12345678// 获取当前的线程@property (class, readonly, strong) NSThread *currentThread;// 获取主线程@property (class, readonly, strong) NSThread *mainThread API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 判断线程是否是主线程@property (readonly) BOOL isMainThread; 线程的状态 123456// 是否在执行@property (readonly, getter=isExecuting) BOOL executing API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 是否已经完成@property (readonly, getter=isFinished) BOOL finished API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 是否取消@property (readonly, getter=isCancelled) BOOL cancelled API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); 其他的属性 12345// 线程的优先级 0-1 越大优先级越高@property double threadPriority ;// 线程的名字@property (nullable, copy) NSString *name ; 方法初始化 123456789101112131415#类方法+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;#实例方法// 直接初始化 不带参数- (instancetype)init API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) NS_DESIGNATED_INITIALIZER;// 线程执行回调操作和参数的携带- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 直接返回回调操作- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)); 延迟操作 1234// 这里是延迟知道某个时间+ (void)sleepUntilDate:(NSDate*)date;// 延迟多长时间+ (void) sleepForTimeInterval:(NSTimeInterval)ti; 线程管理方法 123456789101112131415// 取消操作- (void)cancel API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 开始操作- (void)start API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 退出操作+ (void)exit;// 获取优先级+ (double)threadPriority;// 设置优先级+ (BOOL)setThreadPriority:(double)p; 扩展方法： 12345678910111213141516// 在主线程中执行- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;// 在主线程中执行- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait; // equivalent to the first method with kCFRunLoopCommonModes// 在某个线程中执行- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 在某个线程中执行- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); // equivalent to the first method with kCFRunLoopCommonModes// 在后台线程中执行- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); NSOperationNSOperation 属性123456789101112131415161718192021222324// 是否已经取消@property (readonly,getting=isCancelled) BOOL cancelled;// 是否已经执行@property (readonly,getting=isExecuting) BOOL executing;// 是否已经完成@property (readonly,getting=isFinished) BOOL finished;// 判断队列中的任务是否是同步执行@property (readonly,getting=isConcurrent) BOOL concurrent;// 判断队列中的人员是否异步执行@property (readonly,getting=isAsynchronous) BOOL asynchronous;// 判断队列能够被执行@property (readonly,getter=isReady) BOOL ready;// 队列的优先级@property NSOperationQueuePriority queuePriority;// 操作的名字@property (nullable, copy) NSString *name 方法12345678910111213// 开始执行-(void)start;// 取消执行-(void)cancel;// 添加和移除依赖- (void)addDependency:(NSOperation *)op;- (void)removeDependency:(NSOperation *)op;// 直到线程中的操作全部执行完成- (void)waitUntilFinished ; NSBlockOperation 这个对象继承 NSOperation 属性12@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks; 方法123456// 类方法+ (instancetype)blockOperationWithBlock:(void (^)(void))block;// 添加执行的 block 如果正在执行或者已经执行完毕后报一个异常- (void)addExecutionBlock:(void (^)(void))block; NSInvocation 属性1234// 执行@property (readonly, retain) NSInvocation *invocation;// 结果@property (nullable, readonly, retain) id result; 方法1234-(nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;-(instancetype)initWithInvocation:(NSInvocation *)inv NS_DESIGNATED_INITIALIZER; NSOperationQueue队列就是我们执行操作的容器，操作只有进入队列后就\b会被执行 属性1234567891011121314151617// 获取当前的队列@property (class, readonly, strong, nullable) NSOperationQueue *currentQueue;// 获取主队列@property (class, readonly, strong) NSOperationQueue *mainQueue;// 队列中的\b操作数组@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;// 队列中的操作数@property (readonly) NSUInteger operationCount;// \b最大同步操作数目@property NSInteger maxConcurrentOperationCount;// 是否已经暂停@property (getter=isSuspended) BOOL suspended;// 队列的名字@property (nullable, copy) NSString *name; 方法12345678910111213// 添加操作对象- (void)addOperation:(NSOperation *)op;// 添加多个操作对象- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));// 直接操作对象的回调- (void)addOperationWithBlock:(void (^)(void))block;// 取消所有的操作- (void)cancelAllOperations;// 等所有操作完成后- (void)waitUntilAllOperationsAreFinished; 知识点和疑问找到其对应的方法实现，这样才能在后期更好的查找对象的方法","categories":[],"tags":[{"name":"iOS 多线程","slug":"iOS-多线程","permalink":"http://yoursite.com/tags/iOS-多线程/"}]},{"title":"知识点","slug":"ios-knowlege-items","date":"2018-06-07T09:21:03.000Z","updated":"2018-08-10T06:57:42.000Z","comments":true,"path":"2018/06/07/ios-knowlege-items/","link":"","permalink":"http://yoursite.com/2018/06/07/ios-knowlege-items/","excerpt":"摘要： 对于一些基础知识的积累，便于后续的查阅和知识的储备","text":"摘要： 对于一些基础知识的积累，便于后续的查阅和知识的储备 内存的几大区域在内存中存在几大存储区域分别是：栈 堆 BSS段 数据段/常量区 代码区； 栈栈 是编译器自动分配的并释放的，存放函数的参数值，和局部变量等，栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。[先进后出] 栈\b空间分静态分配和动态分配两种： 静态分配是编译器完成的，比如自动变量的分配 动态分配是由alloca函数完成的 栈的动态分配无效释放，也就是没有释放函数 为可移植的程序期间，栈的动态分配操作是不被鼓励的 堆堆 是由程序员分配和释放的，如果程序员不释放，程序结束的时候，可能会由操作系统进行回收，比如在iOS 中alloc 是存放在堆中 优点：灵活方便，数据适用面广泛，但是效率有一定降低 虽然程序结束的时候所有的数据空间都会被释放回系统，但是精确的\b申请内存和释放内存匹配是良好的程序的基本要素。 全局区全局区（静态区)(static) 全局\b变量和静态变量的存储是放在一起的。初始化的全局变量和静态变量存储在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后\b由系统释放 注意：全局区\b可以分为未初始化全局区 bss段 和初始化全局区 data段 文字常量区存放常量字符串 程序结束后由系统释放 const 代码区存放函数的二进制代码其中define 存放的是在代码去中存在的 参考：关于#define与C的内存 12int a = 10;//全局初始化char * p;// 全局未初始化 申请后\b的系统是如何响应的栈： 存储每一个函数在执行的时候都会想操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放是由系统自动完成的。 注意：只有栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。 堆： 首先应该知道操作系统有\b一个记录空闲内存地址的链表。 当系统收到程序的申请的时候，会遍历链表，寻找第一个\b空间大于所申请的空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的 解决上传app store卡在正在通过iTunes Store鉴定最近在上传的时候，发现一直卡在这个地方。 第一开始认为可能是网络的原因，所以开启了VPN 结果还是不OK 然后在网上查找了下答案： 1234cd ~mv .itmstransporter/ .old_itmstransporter/ //将文件重新命名// \b然后执行\"/Application/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporter\" 在第三步的时候会做一些更新的操作，等执行完成后，再次上传，确实有效果 ##### iOS 中的锁机制OC 和 JS 的交互UIView 和 CALayer 关系 这是常见的UIView 和 CALayer 的关系，View 持有Layer 用于显示，View 中大部分显示属性从Layer 映射过来，Layer 的delegate 在这里是View ,其属性改变动画的产生，View 能够得到通知。 Xcode 4.0 开始","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"二叉查找树","slug":"binary-search-tree","date":"2018-06-07T01:22:15.000Z","updated":"2018-06-08T02:30:36.000Z","comments":true,"path":"2018/06/07/binary-search-tree/","link":"","permalink":"http://yoursite.com/2018/06/07/binary-search-tree/","excerpt":"摘要：","text":"摘要： 树的介绍1.树的定义树是一种数据结构，它是由n(n&gt;=1)个有限节点组成的一个具有层次关系的集合 把它叫做’树’是因为它看起来像是一颗倒挂的树，也就是说它的根朝上，而叶子朝下。它具有以下特点： 每个节点有零个或多个子节点 没有父节点的节点称为根节点 每一个非\b根节点有且只有一个父节点 除了根节点外，每个子节点可分为多个不相交的子树 二叉查找树介绍二叉查找树：又称为二叉搜索树。 它是特殊的二叉树：假设x为二叉树中任意一个节点，x的节点包含关键字key,节点x的可以记为key[x]如果y是x的一个左子树的一个节点，那么key[y]&lt;= key[x],如果y是x的右子树的一个节点，则key[y]&gt;=key[x]。那么这棵树就是二叉树查找树； 在二叉查找树中： 如果任意的节点的左子树不空，则左子树上所有的节点的值均小于它的根节点的值； 如果任意的节点的右子树不空，则右子树上的所有\b节点的值均大于它的根节点的值； 任意节点的左右子树也分别是二叉查找树； 没有键值相等的节点 代码实现首先需要定义节点，节点中需要包含了 key leftNode rideNode parentNode 注意：这里的key是需要能够进行大小比较的，要不然就无法知道具体是放在左边还是在右边了。 首先我们需要定义节点：就是构成我们树的节点 1234567891011121314@interface GYEBSNode : NSObject//这是可以比较大小的值@property (nonatomic ,strong) id key;//父节点@property (nonatomic ,strong) GYEBSNode *parent;// 左节点@property (nonatomic ,strong) GYEBSNode *left;// 右节点@property (nonatomic ,strong) GYEBSNode *right;@end 有了节点我们就可以构造我们的树了： 123456@interface GYEBSTree()// 根节点@property (nonatomic ,strong) GYEBSNode *rootNode;@end 定义好后我们就可以实现其中的一些方法。针对遍历分为前序遍历，中序遍历 后序遍历 前序遍历如果二叉树非空则执行以下操作： 访问根节点 先遍历左子树 后遍历右子树 // 采用的是递归的方法进行遍历12345678910111213141516// 前序遍历-(void)preOrder&#123; // 从根节点出发那就是遍历整个树 [self preOrder:_rootNode];&#125;-(void)preOrder:(GYEBSNode*)tree&#123; if(tree == nil)&#123; return; &#125; // 先遍历根 然后是左半边 然后是右半边 NSLog(@\"%@\",tree.key); [self preOrder:tree.left]; [self preOrder:tree.right];&#125; 中序遍历如果二叉树非\b空，则执行以下操作： 中序遍历左子树 访问根节点 中序遍历右子树 1234567891011121314-(void)centerOrder&#123; [self centerOrder:_rootNode];&#125;// 中序遍历 开始： 左边 头 右边-(void)centerOrder:(GYEBSNode*)tree&#123; if (tree == nil) &#123; return; &#125; [self centerOrder:tree.left]; NSLog(@\"%@\",tree.key); [self centerOrder:tree.right];&#125; 后序遍历 先遍历左子树 后遍历右子树 访问根节点 1234567891011121314151617-(void)postCenter&#123; [self postOrder:_rootNode];&#125;// 后序遍历 先左边遍历 右边遍历 根节点-(void)postOrder:(GYEBSNode*)tree&#123; if(tree == nil )&#123; return; &#125; [self postOrder:tree.left]; [self postOrder:tree.right]; NSLog(@\"%@\",tree.key);&#125; 搜索查找思路：在树中查找某个对象，首先我们需要从根节点开始判断，如果小于当前的值则找左边，如果大于当前你的值则查找右边，如果等于说明已经查找到了。一直顺着这个方法进行向下查找就可以了。 1234567891011121314151617181920212223/* 这里存在查找某个值，查找最大值 查找最小值 */-(GYEBSNode*)search:(id)key&#123; return [self searchFrom:_rootNode key:key];&#125;-(GYEBSNode*)searchFrom:(GYEBSNode*)node key:(id)key&#123; if (node == nil) &#123; return node; &#125; // 这里做判断 如果相等直接返回，如果小于向左搜索 如果大于向右搜索 // 这里的判断需要自己写明 int cmp = [key isEqual:node.key]; if (cmp &lt; 0) &#123; return [self searchFrom:node.left key:key]; &#125;else if(cmp &gt; 0)&#123; return [self searchFrom:node.right key:key]; &#125;else&#123; return node; &#125;&#125; 最大值 和 最小值当我们已经有一颗树的时候，我们就应该了解其中的特性：比如说大的值\b往右走，小的值往左走等等。那这样我们就能够很明确的\b知道我们的最大值应该就是最右边的值，而最小值就应该是最左边的值了。 最大值123456789101112-(GYEBSNode*)maxValue:(GYEBSNode*)node &#123; if (node.right == nil) &#123; return node; &#125; return [self maxValue:node.right];&#125;-(GYEBSNode *)maxValue&#123; return [self maxValue:_rootNode];&#125; 最小值1234567891011121314-(GYEBSNode*)minValue:(GYEBSNode*)node&#123; if (node.left == nil) &#123; return node; &#125; return [self minValue:node];&#125;-(GYEBSNode*)minValue&#123; GYEBSNode *node = [self minValue:_rootNode]; return node;&#125; 前驱和后继节点的前驱：是该节点左子树中最大的节点，查找二叉树中小于该节点的最大结点节点的后继：是该节点右子树中最小的节点，查找二叉树中大于该值的最小节点数 查找前驱\b结点的代码123456789101112131415161718-(GYEBSNode*)preDecessor:(GYEBSNode*)node&#123; // 如果存在左子树的话直接查找其中的最大值 if (node.left != nil) &#123; return [self maxValue]; &#125; //如果X没有左孩子，则X有以下两种可能， // 1.x是一个右孩子，则x的前驱结点为它的父节点 // 2.x是一个左孩子，则查找x的最低的父节点，并且该父节点要具有右孩子，找到这个“最低父节点” GYEBSNode *y = node.parent; while((y != nil) &amp;&amp; (node==y.left))&#123; node = y; y = y.parent; &#125; return y;&#125; 查找后继节点的代码123456789101112131415161718-(GYEBSNode*)succDecessor:(GYEBSNode*)node&#123; //如果存在右节点，则查找到该节点中最小的值 if(node.right != nil)&#123; return [self minValue]; &#125; // 还有就是不存在右节点 // x 是左孩子 则其后继节点就是它的父节点 // x是右孩子，则其后继节点就是x的最低的父节点，并且该父节点具有左孩子，找到这个最低的付家店就是x的后继节点 GYEBSNode *y = node.parent; while ((y != nil) &amp;&amp; (node == y.right)) &#123; node = y; y = y.parent; &#125; return y;&#125; 插入和删除操作插入操作思路： 首先针对于插入操作，只能存在于最后面的节点进行插入操作，所以首先需要先找到其父节点，（通过比较其中\bkey的大小，来进行查找，同时也需要保证其的不存在它想要插入的节点，如果存在则需要继续进行比对就可以了）。然后将其中的节点属性进行填充就可以了 代码实现12345678910111213141516171819202122232425262728293031323334-(void)insertTree:(GYEBSTree*)tree node:(GYEBSNode*)node&#123; // 如果不存在根节点就直接插入到根节点就可以了 if (tree.rootNode == nil) &#123; tree.rootNode = node; return; &#125; GYEBSNode *nodeY = nil; GYEBSNode *nodeX = tree.rootNode; while (nodeX != nil) &#123; nodeY = nodeX; // 这里进行比较 如果大于 说明应该往右走，如果小于那就应该往左走，直到它为nil的时候，这时候保留了nodeY 就是其parent int cmp = [nodeX.key isEqual:node.key]; if (cmp &gt; 0) &#123; nodeX = nodeX.right; &#125;else&#123; nodeX = nodeX.left; &#125; &#125; node.parent = nodeY; if (nodeY == nil) &#123; tree.rootNode = node; &#125;else&#123; // 这里再进行比较以便确定其是放在左边还是右边 int cmp = [node.key isEqual:nodeY.key]; if (cmp &gt; 0) &#123; nodeY.right = node; &#125;else&#123; nodeY.left = node; &#125; &#125;&#125; 销毁操作销毁就是将其\b设置为nil 123456789101112131415161718192021-(void)clean&#123; [self destory:_rootNode]; _rootNode = nil;&#125;-(void)destory:(GYEBSNode*)tree&#123; if (tree == nil) &#123; return; &#125; if (tree.left != nil) &#123; [self destory:tree.left]; &#125; if(tree.right != nil)&#123; [self destory:tree.right]; &#125; // 直接\b设置为nil tree = nil;&#125;","categories":[],"tags":[{"name":"数据结构 二叉树","slug":"数据结构-二叉树","permalink":"http://yoursite.com/tags/数据结构-二叉树/"}]},{"title":"队列的图文解析","slug":"queue-implement","date":"2018-06-04T02:04:56.000Z","updated":"2018-06-04T02:26:48.000Z","comments":true,"path":"2018/06/04/queue-implement/","link":"","permalink":"http://yoursite.com/2018/06/04/queue-implement/","excerpt":"摘要： 队列 是一种线性存储结构，它有以下特点： 队列中数据是按照“先进先出”（FIFO First-In-First-Out）方式进出队列； 队列只允许在队首进行删除操作，而在队尾进行插入操作","text":"摘要： 队列 是一种线性存储结构，它有以下特点： 队列中数据是按照“先进先出”（FIFO First-In-First-Out）方式进出队列； 队列只允许在队首进行删除操作，而在队尾进行插入操作 示意图队列示意图 出队列 入队列 代码实现类定义12345678910@interface GYEQueue : NSObject// 入列 加入到尾部-(void)push:(id)obj;// 出列 删除并返回第一个元素-(id)pop;@end 类实现12345678910111213141516171819202122232425@interface GYEQueue ()@property (nonatomic ,strong) GYEDoubleList *doubleList;@end@implementation GYEQueue-(instancetype)init&#123; self = [super init]; if (self) &#123; _doubleList = [[GYEDoubleList alloc] init]; &#125; return self;&#125;-(void)push:(id)obj&#123; [_doubleList addObject:obj];&#125;-(id)pop&#123; return [_doubleList removeFirstObject];&#125;@end DoubleList 增加方法1234567891011121314151617//.h-(id)removeFirstObject;// .m-(id)removeFirstObject&#123; return [self removeObjectAtIndex:1];&#125;// 修改这个操作，增加返回值-(id)removeObjectAtIndex:(NSUInteger)index&#123; GYENode * node = [self objectAtIndex:index]; [self deleteNode:node]; return node.value;&#125;","categories":[],"tags":[{"name":"数据结构 队列","slug":"数据结构-队列","permalink":"http://yoursite.com/tags/数据结构-队列/"}]},{"title":"栈的图文解析","slug":"stack-implement","date":"2018-06-04T01:35:51.000Z","updated":"2018-06-04T02:28:31.000Z","comments":true,"path":"2018/06/04/stack-implement/","link":"","permalink":"http://yoursite.com/2018/06/04/stack-implement/","excerpt":"摘要： 栈是一种线性存储结构，它有\b以下特点： 栈中的数据是“先进后出”（FILO,First In Last Out）的方式来进出栈。 向栈中添加和删除数据都是从栈顶操作的","text":"摘要： 栈是一种线性存储结构，它有\b以下特点： 栈中的数据是“先进后出”（FILO,First In Last Out）的方式来进出栈。 向栈中添加和删除数据都是从栈顶操作的 介绍栈通常包含了三种操作：push,peek,pop: push 是向栈中添加元素 peek 是返回栈顶的元素 pop 返回并删除栈顶元素的操作 示意图栈的示意图 出栈 入栈 代码实现定义需要实现的函数12345678910111213@interface GYEStack : NSObject// 添加一个元素-(void)push:(id)object;// 返回栈顶元素-(id)peek;// 返回栈顶元素并删除栈顶-(id)pop;@end \b增加DoubleList 功能1234567891011121314151617181920// 获取最后一个元素-(id)getLastObject;// 获取最后一个元素并返回-(id)getAndRemoveLastObject;//.m 实现-(id)getLastObject&#123; return [self getObjectAtIndex:count];&#125;-(id)getAndRemoveLastObject&#123; id obj = [self getObjectAtIndex:count]; [self removeObjectAtIndex:count]; return obj;&#125; 实现stack的功能1234567891011121314151617181920212223242526272829303132333435363738#import \"GYEStack.h\"#import \"GYEDoubleList.h\"@interface GYEStack ()@property (nonatomic ,strong) NSMutableArray *stackArray;@property (nonatomic ,strong) GYEDoubleList *doubleList;@end@implementation GYEStack-(instancetype)init&#123; self = [super init]; if (self) &#123; //初始化数据 _stackArray = [NSMutableArray arrayWithCapacity:0]; _doubleList = [[GYEDoubleList alloc] init]; &#125; return self;&#125;-(void)push:(id)object&#123; [_doubleList addObject:object];&#125;-(id)peek&#123; return [_doubleList getLastObject];&#125;-(id)pop&#123; return [_doubleList getAndRemoveLastObject];&#125;@end ok，功能已经完善了，这里利用了\bDoubleList来实现了，我们的\b栈的操作。","categories":[],"tags":[{"name":"数据结构 栈","slug":"数据结构-栈","permalink":"http://yoursite.com/tags/数据结构-栈/"}]},{"title":"数组、单链表和双链表介绍及实现","slug":"implement-of-array-signal-list-double-list","date":"2018-05-31T01:40:17.000Z","updated":"2018-05-31T06:49:19.000Z","comments":true,"path":"2018/05/31/implement-of-array-signal-list-double-list/","link":"","permalink":"http://yoursite.com/2018/05/31/implement-of-array-signal-list-double-list/","excerpt":"摘要： 线性表是一种线性结构，它具有相同类型的n(n&gt;=0)个数据元素组成有序列表。这次主要介绍线性表中的几个组成部分：\b数组、单向链表、双向链表","text":"摘要： 线性表是一种线性结构，它具有相同类型的n(n&gt;=0)个数据元素组成有序列表。这次主要介绍线性表中的几个组成部分：\b数组、单向链表、双向链表 数组数组是有上界和下界的，数组的元素在上下界\b中是\b连续的 存储10，20，30，40，50的数组的示意图如下： 内存的布局：12345NSArray *array1 = @[@\"10\",@\"20\",@\"30\",@\"40\",@\"50\"];[array1 enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@\" the obj is %@ address %p\",obj,obj);&#125;]; 打印出来 1234562018-05-30 22:30:50.454716-0400 GYEBLEManager[255:41494] the obj is 10 address 0xa4e2c2018-05-30 22:30:50.454824-0400 GYEBLEManager[255:41494] the obj is 20 address 0xa4e3c2018-05-30 22:30:50.454880-0400 GYEBLEManager[255:41494] the obj is 30 address 0xa4e4c2018-05-30 22:30:50.454932-0400 GYEBLEManager[255:41494] the obj is 40 address 0xa4e5c2018-05-30 22:30:50.454983-0400 GYEBLEManager[255:41494] the obj is 50 address 0xa4e6c 注意：这里目前只是针对字符串进行打印，其他的打印出来貌似不是顺序的，可以存在使用链表的方式来进行存储，还需要考究下。 数组的特点：数组是联系的；随机访问速度快。数组中稍微复杂\b一点的就是多维数组。对于C语言而言，多维数组本质上也是通过一维数组来实现的。还有就是\b动态数组，也就是数组的容量能动态的增加的数组。在Objective-C 中有NSMutableArray来实现。 iOS 多维数组的实现方法1234567891011121314151617181920212223// 添加一个对象-(void)addObject:(ObjectType)anObject;// 在\b某个位置添加对象-(void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;// 移除最后一个对象-(void)removeLastObject;// 用某个对象取代某个位置的对象-(void)repalceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;// 添加一个数组的对象-(void)addObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;// 移除所有的对象-(void)removeAllObjects;// 移除某个位置的对象-(void)removeObjectAtIndex:(NSUInteger)index;// 移除某个对象-(void)removeObject:(ObjectType)anObject; 这里只是部分举例，如果需要更加详细的需要查看文档。 单链表单链表是链表的一种，它是由节点组成，每个节点都包含下一个节点的指针。 单链表的示意图如下： 标头为空，标头的后继节点是“节点10”，然后依次是“节点20”，“节点30”… 我们知道链表中的对象都是存放着后续节点的指针，而且每个对象在内存中的布局是零散的，不是连续的，这样要进行查找起来的话，就需要跳转来找到对应的指针区域。所以大体可以推算出针对链表来说插入和删除会比较容易点，但是针对其做遍历的话可能就会比素组麻烦点。 单链表删除节点 删除“节点30”删除之前：‘节点20’的后继节点是“节点30”，‘节点30’的后继节点是“节点40”删除之后：“节点20”的后继节点是“节点40” 单链表添加节点 添加“节点15”添加之前：\b”节点10”的后继节点是“节点20”添加之后：”节点10”的后继节点是“节点15”，”节点15”的后继节点是”节点20” 单链表的特点：节点的链接方向是单向的；相对于数组来说，单链表的随机访问速度慢，但是删除和添加的效率\b很高。 双链表双链表是链表的一种，和单链表一样也是由节点组成，它的每个数据节点都有两个指针，分别指向直接后继和直接前驱。所以从双向链表的人员一个节点都可以很方便的访问它的前驱和后继节点，这样就构成了双向循环的链表。 双链表删除节点 双链表添加节点 代码实现双向链表节点12345678@interface GYENode : NSObject@property (nonatomic ,strong) GYENode *preNode;@property (nonatomic ,strong) GYENode *next;@property (nonatomic ,strong) id value;@end 双链表.h文件12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;@interface GYEDoubleList : NSObject-(void)addObject:(id)object;-(void)addObject:(id)object atIndex:(NSUInteger)index;-(void)removeObject:(id)object;-(id)getObjectAtIndex:(NSUInteger)index;-(BOOL)isEmpty;-(NSUInteger)size;-(void)replaceObject:(id)object atIndex:(NSUInteger)index;-(void)removeObjectAtIndex:(NSUInteger)index;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#import \"GYEDoubleList.h\"#import \"GYENode.h\"@interface GYEDoubleList ()&#123; int count;&#125;@property (nonatomic ,strong) GYENode *headNode;@property (nonatomic ,strong) GYENode *lastNode;@property (nonatomic ,strong) GYENode *currentNode;@end@implementation GYEDoubleList-(instancetype) init&#123; self = [super init]; if (self) &#123; [self createHead]; &#125; return self;&#125;/* 初始化的时候。创建头部，也就是一个新的双向链表 */-(void)createHead&#123; _headNode = [self createNode:nil]; _currentNode = _headNode; _lastNode = _headNode; count = 0;&#125;-(GYENode*)createNode:(id)object&#123; GYENode *node = [[GYENode alloc] init]; node.value = object; node.next = node; node.preNode = node; return node;&#125;-(GYENode*)objectAtIndex:(NSUInteger)index&#123; // 判断是否超出范围 if (index &gt; count) &#123; return nil; &#125; if (index &gt; count/2) &#123; // 从后面开始查找 GYENode *node = _headNode.preNode; for (int i = count; i&lt;index; i--) &#123; node = node.preNode; &#125; return node; &#125;else&#123; // 从head开始查找 GYENode *node = _headNode.next; for (int i = 0; i&lt;index; i++) &#123; node = node.next; &#125; return node; &#125;&#125;/* 添加对象的操作 */-(void)appendNode:(GYENode *)addNode &#123; addNode.preNode = _currentNode; if(_currentNode == _headNode)&#123; addNode.next = _currentNode; _currentNode.preNode = addNode; &#125;else&#123; addNode.next = _currentNode.next; _currentNode.next.preNode = addNode; &#125; _currentNode.next = addNode; count++;&#125;-(void)addObject:(id)object&#123; [self addObject:object atIndex:count];&#125;-(void)addObject:(id)object atIndex:(NSUInteger)index&#123; GYENode *node = [self objectAtIndex:0]; if (node == nil) &#123; return; &#125; _currentNode = node; GYENode *addNode = [self createNode:object]; [self appendNode:addNode];&#125;/* 移除对象的操作 */-(void)removeObject:(id)object&#123; GYENode *node = _headNode.next; for (int i = 0; i&lt;count; i++) &#123; GYENode *selectNode = node.next; if (selectNode.value == object) &#123; [self deleteNode:selectNode]; break; &#125; &#125;&#125;-(void)removeObjectAtIndex:(NSUInteger)index&#123; GYENode * node = [self objectAtIndex:index+1]; [self deleteNode:node];&#125;-(void)removeAllObjects&#123; for (int i= 0; i &lt; count; i++) &#123; [self removeObjectAtIndex:i]; &#125;&#125;-(void)deleteNode:(GYENode*)node&#123; // 删除node的操作 node.preNode.next = node.next; node.next.preNode = node.preNode; count--;&#125;/* 替换 */-(void)replaceObject:(id)object atIndex:(NSUInteger)index&#123; GYENode *node = [self objectAtIndex:index+1]; node.value = object;&#125;/* 判断是否为空 */-(BOOL)isEmpty&#123; return count;&#125;/* 大小 */-(NSUInteger)size&#123; return count;&#125;/* 获取具体的值 */-(id)getObjectAtIndex:(NSUInteger)index&#123; GYENode *node = [self objectAtIndex:index+1]; return node.value;&#125; 结构体和类的区分单链表中的操作 添加 删除 修改","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"观察者模式","slug":"design-observer-module","date":"2018-05-30T02:12:30.000Z","updated":"2018-05-30T03:18:49.000Z","comments":true,"path":"2018/05/30/design-observer-module/","link":"","permalink":"http://yoursite.com/2018/05/30/design-observer-module/","excerpt":"摘要： 在软件开发的过程中，我们有一种需求，就是我们需要监听某个对象的某些动作或者属性，当\b发生变化的时候，我们的对象也需要进行相应的改变。这里就分为观察者和目标（被观察者）两个对象。一个观察目标可以对用多个观察者，而且这些观察者之间没有\b相互关联，可以根据需求增加和删除观察者，使得系统更易于扩展。","text":"摘要： 在软件开发的过程中，我们有一种需求，就是我们需要监听某个对象的某些动作或者属性，当\b发生变化的时候，我们的对象也需要进行相应的改变。这里就分为观察者和目标（被观察者）两个对象。一个观察目标可以对用多个观察者，而且这些观察者之间没有\b相互关联，可以根据需求增加和删除观察者，使得系统更易于扩展。 定义观察者模式：定义对象间一种一对多依赖关系，使得每当一个对象状态发生改变的时候，其相关依赖对象都得到通知并\b被自动更新，观察者模式又叫做发布——订阅模式。 观察者模式是一种对象行为模式 结构观察者模式包含如下角色： Subject : 目标 ConcreteSubject: 具体目标 Observer: 观察者 ConcreteObserver : 具体观察者 从结构图中我们可以看出目标有一个 关于Observer的链表\b，用于添加和删除Observer的操作同时当属性或许需要通知的时候会调用目标的\bnotify()来通知所有的Observer来执行其对应的uodate的操作。 时序图 通过时序图我们可以更加明确其操作的流程： 创建具体的Observer 和具体的Subject 具体的Subject 添加 Observer 当具体的Subject 的执行了 setState() 后，在Subject的内部执行notify()的操作 在Subject的内部会调用 Observer 的update()的操作 反过来在Observer 中会调用 Subject 的 getState()的方法来获取变动 代码分析Subject1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// subject.h@protocol GYEObserver;@interface GYESubject : NSObject//-(void)attach:(id &lt;GYEObserver&gt;)observer;-(void)detach:(id &lt;GYEObserver&gt;)observer;-(void)notify;@end// subject.m@interface GYESubject ()@property (nonatomic ,copy) NSMutableArray *observerArray;@end@implementation GYESubject-(instancetype)init&#123; self = [super init]; if (self) &#123; _observerArray = [NSMutableArray arrayWithCapacity:0]; &#125; return self;&#125;-(void)attach:(id &lt;GYEObserver&gt;)observer&#123; [_observerArray addObject:observer];&#125;-(void)detach:(id &lt;GYEObserver&gt;)observer&#123; [_observerArray removeObject:observer];&#125;-(void)notify&#123; [_observerArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; id &lt;GYEObserver&gt; observer = obj; [observer update:self]; &#125;];&#125;@end Observer：12345@protocol GYEObserver &lt;NSObject&gt;-(void)update:(GYESubject *)subject;@end GYEConcreteSubject1234567891011121314151617181920212223// .h@interface GYEConcreteSubject : GYESubject@property (nonatomic ,assign) NSUInteger state;@end//.m@implementation GYEConcreteSubject-(void)setState:(NSUInteger)state&#123; _state = state; [self notify];&#125;-(NSUInteger)getState&#123; return _state;&#125;@end \bConcreteObserver12345678910111213141516171819// .h@interface GYEConcreteObserver : NSObject &lt;GYEObserver&gt;@end//.m@implementation GYEConcreteObserver-(void)update:(GYESubject *)subject&#123; // 具体的操作 GYEConcreteSubject *subj = (GYEConcreteSubject *)subject; subj.state;&#125;@end Main12345678910111213141516171819202122232425262728//.h@interface ObserverMain : NSObject@end//.m#import \"ObserverMain.h\"#import \"GYESubject.h\"#import \"GYEObserver.h\"@implementation ObserverMain-(void)mainAction&#123; GYEConcreteSubject *subject = [[GYEConcreteSubject alloc] init]; GYEConcreteObserver *observer = [[GYEConcreteObserver alloc] init]; [subject attach:observer]; subject.state = 1;&#125;@end 模式分析 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。 这个模式的关键对象是观察目标和观察者，一个目标可以有任意多个与之相依赖的观察者，一旦目标发生改变，所有有观察者都将得到到通知。 适用环境 一个\b抽象模型有两个方面，其中一个方面依赖于其他方面，将这些方面封装在独立对象中使他们可以各自独立的改变和复用。 一个对象的改变将导致其他一个或者多个对象也发生改变而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度 一个对象必须通知其他对象，而并不知道这些对象是谁 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"iOS 组件化开发","slug":"ios-mudulization","date":"2018-05-28T02:15:12.000Z","updated":"2018-05-30T08:42:18.000Z","comments":true,"path":"2018/05/28/ios-mudulization/","link":"","permalink":"http://yoursite.com/2018/05/28/ios-mudulization/","excerpt":"摘要： 随着项目的增加，可能存在公共的模块比较多，比如说登陆模块,可能很多\b项目都是通用一个登陆的模块，即使不同也只体现在界面中，但是整体的流程还是一模一样的，这就导致，如果其中有个项目的模块已经\b渐渐完善了，但是其他项目要更新的话，就要一个一个的复制过去，这样就造成了很多不必要的工作\b,最主要的是效率太低下，作为一个程序员如果不能\b更灵活的做开发的话，那就太悲哀了。所以果断尝试模块化我的项目。","text":"摘要： 随着项目的增加，可能存在公共的模块比较多，比如说登陆模块,可能很多\b项目都是通用一个登陆的模块，即使不同也只体现在界面中，但是整体的流程还是一模一样的，这就导致，如果其中有个项目的模块已经\b渐渐完善了，但是其他项目要更新的话，就要一个一个的复制过去，这样就造成了很多不必要的工作\b,最主要的是效率太低下，作为一个程序员如果不能\b更灵活的做开发的话，那就太悲哀了。所以果断尝试模块化我的项目。 概要当前的模块化开发主流就只有两种，一个是Casa 的基于target-action的方法，还有一个是基于MGJ的URL的方案。其实对两种方案大体查看了下，个人比较推崇Casa的方案，首先我们的项目更多的已经是发布过的，也就是模块都已经有了，只是之间的耦合没有解开，而且其不需要对整体APP进行改造，可以一个一个的分离出来处理，而\bMGJ的方案，一开始就要注册整个APP的URL 要不然就走不下去了，这样改动就要全部一起动，\b工程量大不适合我当前的工作，毕竟没有单独的时间来做这些操作。 中间人 （CTMediator）ok，既然选择了CTMediator的方案，那首先就要先了解其实现的原理. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 声明@interface CTMedaitor : NSObject+(interface)shareInterface;// 远程APP调用入口-(id)performActionWithUrl:(NSURL *)url completion:(void(^)(NSDictionary*)info)completion;// 本地组件调用入口-(id)perforTarget:(NSString*)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget;-(void)releaseCachedTargetWithTargetName:(NSString *)targetName;@end// 实现这里是用来缓存target的操作 ，这样就不需要每次都重新创建一个target了@property (nonatomic ,strong ) NSMutableDictionary *cacheTarget;#pargma mark - getting and setters-(NSMutableDictionary *)cacheTarget&#123; if(_cahceTarget == nil)&#123; _cacheTarget = [[NSMutableDictionary alloc] init]; &#125; retutn _cachedTarget;&#125;#paragma mark - public methods// 核心-(id)performTarget:(NSString*)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget&#123; // 这里是采用RunTime的方法来进行解耦的操作 NSString *targetClassString = [NSString stringWithFormat:@\"Target_%@\",targetName]; NSStirng *actionString = [NSStirng stringWithFormat:@\"Action_%@\",action\bName]; // 这里拼接了 target 和 Action 的名称，首先一个target 就表示我们需要一个新的文件，比如我们的target 是A 那我们就要创建一个Target_A的文件，然后里面要实现Action_cationName的方法 Class targetClass; NSObject *target = self.cacheTarget[targetClassString]; if(target == nil)&#123; targetClass = NSClassFromString(targetClassString); target = [][targetClass alloc] init]; &#125; SEL action = NSSelectorFromString(actionString); if(target == nil)&#123; // 说明没有实现这个类 return nil; &#125; // if (shouldCacheTarget)&#123; self.cacheTarget[targetClassString] = target; &#125; // 判断类是否实现action的操作 if([target responseToSelector:action])&#123; [self safePerformAction:action target:target parems:params ]; &#125;else&#123; // 有可能target 是Swift对象 actionString = [NSStirng stringWithFormat:@\"Action_@WithParams:\",action\bName]; action = NSSelectorFormString(actionString); if([target responseToSelector:action])&#123; return [self safePerformAction:action target:target params:patams]; &#125;else&#123; // 这里是处理无响应请求的地方，如果无响应，则尝试调用target的notFound方法统一处理 SEL action = NSSelectorFormString(@\"notFound:\"); if ([target responseToSelector:action])&#123; return [self safePerformAction:action target:target patams:patams]; &#125; &#125; &#125;&#125; 从上面的代码，我们大概能够得知CTMediator的实现的方法，首先会将我们传入的target action 进行字符串的扩展，这样就要求我们实现target和\b具体的action的。也就是我们要在我们的组件中实现对用的方法。 实施方案创建私有仓库创建私有代码仓库 首先创建一个托管当前组件的私有代码仓库，然后将仓库\bClone下来，把模块的代码push上去，这就是一个最简单的组件化代码的创建，后面还需要针对CTMediator进行修改，先单独出一个工程出来 创建私有Spec仓库 创建私有Spec仓库。 首先在我们使用GitHub中的CocoaPod的时候，我们是从source &#39;https://github.com/CocoaPods/Specs.git&#39;中获取的，但是我们针对我们的私有组件的代码，放在这里显然就不是私有了，就变成公开了。所以我们也需要有\b一个私有的Spec来管理我们的组件。还是和原来创建仓库一样，先创建一个工程就可以了。这个不需要Clone操作，因为这里的主要是存放针对相同的\b\b组件仓库的不同版本的podspec的描述。 然后执行： pod repo add [私有Pod源仓库名字] [私有\bPod源的repo地址] 搭建环境创建.podspec文件找到私有仓库所在的目录，在这个目录下通过下面的命令，创建一个新的.podspec文件,在这个文件中对私有仓库进行一些配置的工作123pod sepc create GyennoLoginSpecification created at GyennoLogin.podspec 创建完这个文件后，需要修改里面的一些东西， 这里列举我修改后的1234567891011121314151617181920212223242526// 名称s.name = &quot;GyennoLogin&quot;// 版本号s.version = &quot;0.0.1&quot;// 简要\b概述s.summary = &quot;登录模块，主要负责登录的操作&quot;// 描述s.description = &lt;&lt;-DESC 这是一个Gyenno的登录模块 DESC// 主页s.homepage = &quot;http://gitlab.xxxxx.com/xxxx/GyennoLoginModule&quot;// 认证s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;// 作者s.author = &#123; &quot;xxxxxx&quot; =&gt; &quot;xxxxxx@xxxxx.com&quot; &#125;// 平台s.platform = :ios// 代码源s.source = &#123; :git =&gt; &quot;http://gitlab.xxxx.com/xxxxx/GyennoLoginModule.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;// 包含文件s.source_files = &quot;GyennoLogin/*.&#123;h,m&#125;&quot;// 排除文件s.exclude_files = &quot;GyennoLogin/AppDelegate.&#123;h,m&#125;&quot;,&quot;GyennoLogin/main.m&quot;s.requires_arc = true 其中我们需要创建一个LICENSE文件 开发过程验证podspec文件先用pod命令验证下这个.podspec文件有没有问题 1pod lib lint 如果没有问题会提示1XXXXX passed validation. 如果没有问题，就将私有工程的代码提交到私有服务器上，连同生成的.podspec文件也要一起提交上去 关联podspec到Spec私有仓库通过下面的命令，添加远程Spec长裤到本地，相当于建立一个连接关系。（这里是Spec的地址）1pod repo add GyennoSpec &apos;url for spec&apos; 添加完后，用\b下面的命令检查下是否成功 1pod repo lint 提交代码到Spec私有仓库如果上面的命令没有问题，这就代表组件的私有仓库和其对应的Spec仓库，已经可以提交并向外提供代码了，这时候我们就可以进行代码开发了，开发完成以后通过下面的代码提交\b或者更新到\bspec仓库。1pod repo push GyennoSpec GyennoLogin.podspec 提交给Spec私有仓库的文件，可以通过.podspec 文件的s.source_files字段进行过滤，符合过滤条件的文件都会\b被提交到Spec 仓库 使用私有仓库代码当Spec私有仓库有可用的代码后，就可以通过CocoaPods命令来使用组件代码了，在podfile文件中需要声明私有仓库的地址，例如如下的代码： 12345678platform :ios, &apos;9.0&apos;// 我们的私有源Spec 的地址source &apos;http://gitlab.gyenno.com/xxxx/GyennoSpec.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos;pod ‘GyennoLogin’,&apos;0.0.1&apos; 在配置好环境后，之后的开发只需要执行上面的pod repo push的操作就可以了。根据业务的需求发布指定的组件版本，并将组件push到spec私有仓库供其他人使用就可以了。 版本控制也非常简单，值需要在podfile中指定某个私有仓库的版本号就可以了 组件实践CocoaPod 和 Xcode冲突在使用Pod的时候，一直无法正确的使用Pod的\b相关操作，后面发现是CocoaPod 和Xcode冲突了，\b 12345### Error```RuntimeError - [Xcodeproj] Unknown object version./Users/lmzqm/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/xcodeproj-1.5.2/lib/xcodeproj/project.rb:217:in `initialize_from_file&apos; 查看当前CocoaPod的源 12345gem souece -l*** CURRENT SOURCES ***https://ruby.taobao.org 删除该映像 1gem source --remove https://ruby.taobao.org 添加新的映像1gem source -a https://gems.ruby-china.org 安装最先的CocoaPod1sudo gem install -n /usr/local/bin cocoapods –pre 这样就可以了 创建一个CTMediator的扩展工程步骤和上面的步骤一样，但是这里需要注意的是，这里需要添加依赖 感谢私有Pod源仓库的创建 cocoapods 和 XCode 版本冲突","categories":[],"tags":[{"name":"iOS 组件化","slug":"iOS-组件化","permalink":"http://yoursite.com/tags/iOS-组件化/"}]},{"title":"iOS iPhone X 适配","slug":"ios-iphonex-config","date":"2018-05-25T05:55:42.000Z","updated":"2018-08-10T10:14:46.000Z","comments":true,"path":"2018/05/25/ios-iphonex-config/","link":"","permalink":"http://yoursite.com/2018/05/25/ios-iphonex-config/","excerpt":"摘要： iPhone X 出来了，所以我们要对它进行适配。","text":"摘要： iPhone X 出来了，所以我们要对它进行适配。 启动页面的适配 首先 iPhone \bX的尺寸变为 ： 1125 * 2436 刷新框架适配纯代码宽高比适配iphone x 高度系数是 812.0iPhone 8 高度系数是 667.0 纯代码适配齐刘海在iPhone X 之前导航的高度为64iPhoneX 的导航栏的高度变为了88 iPhone X的状态栏由原来的20变更为现在的44 所以定义一个宏来做处理1#define SafeAreaTopHeight (ScreenHeight == 812.0 ? 88 : 64) 纯代码适配iPhone X 脚底1#define SafeAreaBottomHeight (ScreenHeight == 812.0 ? 34 : 0) 国际化操作\b应用名称国际化然后在Project-&gt;info-&gt;localizations 中添加你想要的实现国际化的语言 首先新建一个Strings 的文件，取名为infoPlist 然后点击新建的infoPlist.strings 在右侧\b选择你需要国际化的语言 这里进行勾选后在文件下面会多出来个文件 然后你就可以针对不同的系统语言做一些操作了 1CFBundleDisplayName = &quot;xxxxxx&quot;; 代码国际化首先也和前面的创建infoPlist一样，但是文件名是固定的Locaizable就可以了 最终呈现出来： 这样就已经大体\b完成了，然后就是要同步英文和中文里的信息啦！ 采用的是localString的操作 启动图片国际化首先取消默认的启动图，将默认的LaunchScreen 去掉，留空就可以了 这里首先需要用到的是针对国际化的处理，首先保证图片的名称和格式都是一模一样的，然后分别针对图片进行国际化的处理 点击图片，然后将图片看到右边栏中的国际化处理，针对不同的语言进行不同的操作，比如说中文的启动页就进行中文的国际化处理，然后在中文的图片中再增加英文的国际化处理，这时候会出现一个说已经存在了英文的相同名字的图片了，这时候将这个图片添加就可以了。 然后针对plist 文件，使用Source Code 的方式进行打开，然后编辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;key&gt;UILaunchImages&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;UILaunchImageMinimumOSVersion&lt;/key&gt; &lt;string&gt;8.0&lt;/string&gt; &lt;key&gt;UILaunchImageName&lt;/key&gt; &lt;string&gt;launchImage_4&lt;/string&gt; &lt;key&gt;UILaunchImageOrientation&lt;/key&gt; &lt;string&gt;Portrait&lt;/string&gt; &lt;key&gt;UILaunchImageSize&lt;/key&gt; &lt;string&gt;&#123;320,480&#125;&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UILaunchImageMinimumOSVersion&lt;/key&gt; &lt;string&gt;8.0&lt;/string&gt; &lt;key&gt;UILaunchImageName&lt;/key&gt; &lt;string&gt;launchImage_5&lt;/string&gt; &lt;key&gt;UILaunchImageOrientation&lt;/key&gt; &lt;string&gt;Portrait&lt;/string&gt; &lt;key&gt;UILaunchImageSize&lt;/key&gt; &lt;string&gt;&#123;320,568&#125;&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UILaunchImageMinimumOSVersion&lt;/key&gt; &lt;string&gt;8.0&lt;/string&gt; &lt;key&gt;UILaunchImageName&lt;/key&gt; &lt;string&gt;launchImage_6&lt;/string&gt; &lt;key&gt;UILaunchImageOrientation&lt;/key&gt; &lt;string&gt;Portrait&lt;/string&gt; &lt;key&gt;UILaunchImageSize&lt;/key&gt; &lt;string&gt;&#123;375,667&#125;&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UILaunchImageMinimumOSVersion&lt;/key&gt; &lt;string&gt;8.0&lt;/string&gt; &lt;key&gt;UILaunchImageName&lt;/key&gt; &lt;string&gt;launchImage_6p&lt;/string&gt; &lt;key&gt;UILaunchImageOrientation&lt;/key&gt; &lt;string&gt;Portrait&lt;/string&gt; &lt;key&gt;UILaunchImageSize&lt;/key&gt; &lt;string&gt;&#123;414,736&#125;&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; 其中，需要修改的是文件名和string中图片的size的大小 注意： 在使用这个方法进行启动页面国际化的时候，需要通过完全删除后，才能生效也就是说即使你在使用的过程中切换语言，启动图片也是不会变化的，这点是需要注意的。 权限申请提示语国际化在开发过程中我们经常需要用到一些权限的提示语 比如说照相机 定位等，如果这时候你再针对APP 做国际化处理的话，那么你也需要针对提示语进行国际化处理，其实操作还是很简单的，如果你针对APP 名称的国际化已经完成了的话： 只需要针对你想要申请的权限添加相应的字符串就OK了 12345678910111213141516171819Xcode 8 权限提示语国际化配置配置权限国际化和配置应用程序名字国际化一样。具体Key值如下NSMicrophoneUsageDescription 麦克风权限NSCameraUsageDescription 相机权限NSPhotoLibraryUsageDescription 相册权限NSBluetoothPeripheralUsageDescription 蓝牙权限NSSpeechRecognitionUsageDescription 语音转文字权限NSCalendarsUsageDescription 日历权限NSLocationWhenInUseUsageDescription 定位权限NSLocationAlwaysUsageDescription 定位权限 图片国际化时间国际化在APP 内部设置国际化操作123456789#define NSLocalizedString(key, comment) \\ [NSBundle.mainBundle localizedStringForKey:(key) value:@\"\" table:nil]#define NSLocalizedStringFromTable(key, tbl, comment) \\ [NSBundle.mainBundle localizedStringForKey:(key) value:@\"\" table:(tbl)]#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \\ [bundle localizedStringForKey:(key) value:@\"\" table:(tbl)]#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \\ [bundle localizedStringForKey:(key) value:(val) table:(tbl)] 这个当用户选择好后，就可以根据用户所选择的语言，然后进行选取对应的en.lproj 文件夹，然后再选取其中的table 文件 12345678#define Localized(key)NSString *language = [[NSUserDefaults standardUserDefaults] objectForKey:@\"appLanguage\"];NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@\"lproj\"];NSBundle *languangeBundle = [NSBundle bundleWithPath:path];NSString *localStr = [languangeBundle localizedStringForKey:@\"key\" value:nil table:@\"LanguageTable\"]; 首先可以将用户选取的语言用 NSUserDefaults 来存取 对应的键值是 appLanguage 然后获取到en.lproj 文件中的 LabgaugeTable.string 文件来获取相应的信息 iOS 跳转到设置界面常规操作在iOS 10 以后，跳转到设置界面很多都已经被设置为私有的API 所以如果在你的应用中还需要实现这个功能的话，可能就要多做一些操作了 123456789101112// App-Prefs:root=WIFI NSURL *url = [NSURL URLWithString:@\"App-Prefs:root=WIFI\"]; if ([[UIApplication sharedApplication] canOpenURL:url]) &#123; if (@available(iOS 10.0, *)) &#123; [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; // Fallback on earlier versions [[UIApplication sharedApplication]openURL:url]; &#125; &#125; iOS11 后的操作前段时间提交审核的时候遇到这个问题： 123456Your app uses the \"prefs:root=\" non-public URL scheme, which is a private entity. The use of non-public APIs is not permitted on the App Store because it can lead to a poor user experience should these APIs change.Continuing to use or conceal non-public APIs in future submissions of this app may result in the termination of your Apple Developer account, as well as removal of all associated apps from the App Store.To resolve this issue, please revise your app to provide the associated functionality using public APIs or remove the functionality using the \"prefs:root\" or \"App-Prefs:root\" URL scheme. 现在连这个都不让使用了，搜索了很多资料，基本上都是将这些跳转的操作给删除掉了。但是还是有一些特殊的操作 123456789101112131415这里的操作是将 App-Prefs:root=WIFI 转 ASCII 码 NSData *encryptString = [[NSData alloc] initWithBytes:(unsigned char [])&#123;0x41,0x70,0x70,0x2d,0x50,0x72,0x65,0x66,0x73,0x3a,0x72,0x6f,0x6f,0x74,0x3d,0x57,0x49,0x46,0x49&#125; length:19]; NSString *string = [[NSString alloc] initWithData:encryptString encoding:NSUTF8StringEncoding]; NSURL *url = [NSURL URLWithString:string]; //[NSURL URLWithString:UIApplicationOpenSettingsURLString] if (@available(iOS 10.0, *)) &#123; [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; // Fallback on earlier versions [[UIApplication sharedApplication]openURL:url]; &#125; \b感谢iOS11和iPhone X的适配 3分钟实现iOS语言本地化/国际化（图文详解） iOS开发技巧-国际化(Localization)，只看一篇就够了","categories":[],"tags":[{"name":"iOS 适配","slug":"iOS-适配","permalink":"http://yoursite.com/tags/iOS-适配/"}]},{"title":"MVC MVP MVVM","slug":"mvc-mvp-mvvm","date":"2018-05-24T02:57:57.000Z","updated":"2018-08-25T09:16:06.000Z","comments":true,"path":"2018/05/24/mvc-mvp-mvvm/","link":"","permalink":"http://yoursite.com/2018/05/24/mvc-mvp-mvvm/","excerpt":"摘要： 首先了解架构的设计理念，架构主要是为了让我们的代码更好的组合起来。首先针对开发者来说能够很清楚\b的了解具体的代码会\b存放在哪里？哪些部分做哪些事情？不同部分之间的关联是什么？等等。\b个人对架构的归纳就是如何更好的组织你的代码文件，当然对于架构的熟练能够让我们很清楚自己需要在哪些地方处理哪些事情，而不会将代码弄得错乱也不便于\b其他开发人员的查看和修改添加等操作。","text":"摘要： 首先了解架构的设计理念，架构主要是为了让我们的代码更好的组合起来。首先针对开发者来说能够很清楚\b的了解具体的代码会\b存放在哪里？哪些部分做哪些事情？不同部分之间的关联是什么？等等。\b个人对架构的归纳就是如何更好的组织你的代码文件，当然对于架构的熟练能够让我们很清楚自己需要在哪些地方处理哪些事情，而不会将代码弄得错乱也不便于\b其他开发人员的查看和修改添加等操作。 \b概述假如你不关心架构，那么总有一天，需要在一个庞大的类中调试若干复杂的事情，你就会发现在这个条件下，根本不可能在\b这个类中快速的找到以及有效的修改任何的bug,当然将这个类想象成一个整体是困难的，因此，有可能一些重要的细节总是会在这个过程中被忽略。如果现在的你正处于这样一个开发环境，很可能具体的情况会像下面这样： 这个类是一个UIViewController的子类 数据直接在UIViewController中存储 UIView 类几乎不做任何的事情 Model 也仅仅是一个数据结构 单元测试覆盖不了任何用例 一个好的架构应该具备的特点： 任务均衡分摊给具有清晰角色的实体 可测性通常用于来自于一个合适的架构 易用性和低成本维护 当今我们已经有很多架构设计模式方面的选择： MVC MVP MVVM VIPER 前面三种架构将\b一个应用中的实体分为以下三类： Models — 负责主要的数据或者操作数据的数据访问层 Views — 负责展示层 Controller/Presenter/ViewModel — 负责协调Model和View ,通常根据用户在View上的动作\b在Model\b上做出相对应的更改，同时将更改的信息返回到View上 将实体进行划分给我们带来的以下好处： 更好的理解它们之间的关系 复用 （尤其是对View和Model） 独立的测试 这里增加下个人的理解\b: 首先实体划分，或者说功能的划分，对于内部的操作，我们更加清晰的知道，哪些事情是要放在哪个实体里面操作的，这样对于后面修改和维护的时候，思路比较清晰，也便于扩展操作。 针对测试这一块来说，在Presenter 或 ViewModel 中没有界面的生命周期的影响，在测试代码中可以更加方便灵活的进行测试。 在View 中测试View 之间的逻辑也可以单独针对View 这个文件进行测试。 我个人针对View -&gt; Presenter -&gt; Model 之间的理解。 首先View -&gt; Presenter 这里的 action 如果是View 的内部的逻辑 其实是没有必要交给Presenter 的，因为这里不需要Presenter 做任何事情，比如 UITextField 中字符的校验，还有就是满足条件后提交\b按钮的显示可以点击的操作等。个人认为只有针对Model 的修改的地方或者地方才能使用到Presener 。所以还是得遵循单一原则，自己能坐的事情就自己做。 这里遗留下一个问题： 假如说你一个登陆界面 可能在里面涉及到很多逻辑，能够让其 满足变成 注册 忘记密码 修改密码 等界面。这时候内部的逻辑就会比较复杂，对于新增或者修改就会造成 很多逻辑的判断，一不小心就把逻辑搞乱。简而言之就是不\b利于后期的维护和升级的操作。\b(我们需要将内部的逻辑进行拆分，这里更多的是逻辑的不同，还有界面的排版不同，所以个人感觉应该添加一个协议，满足最基本的操作，1\b.首先需要哪些对象 （initObjects）,对象布局(layoutSubvies),数据校验（dataPrase）,数据获取(getDatas)，数据填充(configData),但是这里的页面逻辑，也就是页面是一个共有的因素，只是我们可以通过懒加载的操作来进行创建的操作，避免内存开销) MVC传统的 MVC 从上图中我们可以看出 Model,View,Controller三者紧密耦合。当用户在View 有动作的时候，View发送用户的action给Controller ，然后\bController 就会调用一个直接取代整个View的操作，同时也会将Model 进行更新的操作。Model变化了以后也会向View发送通知，然后View会或者改变的状态值。 苹果推荐的MVC - 愿景 由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的\b联系，Controller是最小可重用单元，这也就是我们写逻辑复杂度比较高的代码，而这些代码又不适合放在Model中。首先当View接收到用户的动作后将消息发送到Controller，然后Controller更新Model，或者当Model有变化了以后\b\b通知Controller 有变化，然后Controller就会去更行View的视图。 这里将Controller 作为最小可重用单元，也就是可能View 会发生改变，Model 也会发生改变，但是Controller 中的逻辑\b变化的不是特别大，可以进行重用 苹果推荐的MVC — 事实 Cocoa的MVC 模式使我们写出了臃肿的视图控制器，因为他们经常被混杂到View的生命周期中，因此很难说View和ViewController是分离的。尽管仍可以将业务逻辑和数据切换到Model，但是大多数情况下当需要为View减负的时候我们\b就有些无能为力了，View的最大的任务就是向Controller传递用户的动作事件，ViewController不再承担一切代理和数据源的职责，通常指负责一些\b分发和取消网络请求以及一些其他任务。 任务均摊 ： View 和 Model 确实是分开的，但是View 和 Controller \b是紧密耦合的。 可测试性：由于糟糕的分散性，只能对Model 进行测试 易用性：与其他几种模式相比最小的代码量。熟悉的人也比较多，因而即使对于经验不是那么丰富的\b开发者阿里说维护起来也\b比较容易 MVPMVP 实现了Cocoa的MVC \b的愿景 通过上面的结构图可以分析下，三者之间的关系， 首先View和Presenter 中View 是拥有了Presenter ,并当用户有action的时候，将\b\b消息发送给Presenter ，交给Presenter进行处理，在Presenter中也对View 进行了\b弱引用的操作，这样Presenter 就可以对View 进行 update 的操作了。 Presenter 与 Model 之间，Presenter 拥有Model 并且可以更新Model 的操作，并且当Model变化的时候可以通知Presenter 进行更新的操作。其实这里所谓的更新个人感觉可以理解为一个\b网络请求，然后当请求成功后，将Model 的值传回给Presenter \b的操作，这样Presenter 还可以根据有没有哪些界面需要更新操作的，库进行更新的操作 Presenter中根本没有和布局相关的代码，但是它且负责更新View的数据和状态 就MVP 而言，UIViewController 的子类实际上就是 Views 并不是Presenters 这点区别使得模式的可测性得到了极大的提高，付出的代价就是开发速度的一些降低，因为必须要做一些手动的数据和事件的绑定 代码示例这里需要确认哪些操作在哪里执行 ViewS： \b页面的布局 和\b 页面的\b初始化操作 等 将页面的动作交给Presenter 进行操作 ， 同时做好本地接收 更新的操作 所有以页面相关的操作 Presenter: 首先 拥有了Model 并且对 ViewS 是一种弱引用 当需要使用的时候再使用强引用 Presenter 对Model \b进行控制 然后更多是\b为了进行网络的请求，然后将网络请求的数据返回回来给Presenter 进行处理，这时候 Presenter 的处理可以通过 将Model \b展示到View中进行显示，这时候就会使用到 \b弱引用的Views 来进行更新的操作 Models： 主要负责首先model 的构建 也就是原型 负责是关于数据的请求操作 还有一点：这里可以使用协议的操作方法，因为很多时候，有一些通用的操作方法这样就可以进一步的规范代码的书写同时也便于对代码的理解操作，而不会出现说多人操作的时候，同一种操作出现了不同的函数名的现象。 我们来看下MVP模式下的三个特性的分析： 任务均摊 - 我们将最主要的任务划分到Presenter 和 Model 而View 的功能较少 可测性 — 非常好，由于一个功能简单的View 层，所以测试大多数业务逻辑变得简单 易用性 — 虽然代码量变大了，但是MVP的概念非常清晰 MVVM 从结构图中感觉和MVP看起来非常像： 这里做了数据的绑定操作，当用户点击的时候，调用的是\bViewModel 的操作，在ViewModel中操作的时候，会调用其自身的Block 来实现数据的传递，然后在View中会有ViewModel的属性，这个属性就会\b构造一个Blcok 来更新View中的数据，当用户点击的时候，ViewModel获取到数据，并返回给View 然后View就会给对应的视图更新界面来进行操作。 这里相比较于MVP 来说：首先这里的ViewModel 直接对数据 和 用户的动作进行了绑定，也就是用户的动作直接是传给ViewModel 的，然后数据的返回直接是在用户的View里面通过block来做操作的。\b这样就避免了，ViewModel 需要对View 提供了\b函数来进行操作，View 也\b不需要对 ViewModel 提供一些方法给他们使用。 首先这里也分析下三者之间的关系： 首先View 还是要拥有ViewModel 的 只是在ViewModel中不需要对View 进行\b弱引用的操作，直接采用Block的回调的操作来实现就可以了。其中涉及到的数据绑定的时候。 关于三个特性的评估： 任务均摊 — MVVM的View 要比 MVP中的View 承担的责任更多，因为前者通过ViewModel来设置绑定以便更新状态，而后者只是监听Presenger的事件但是不会对自己有更新。 可测性 — ViewModel 不知道关于View 的任何事情，这运行我们就可以轻易的测试ViewModel的同时View也可以被测试，单数只属于UIKit的范畴，对他们的测试通常会被\b忽略。 总结没有最好的架构，只有最适合\b你应用的架构。 感谢iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构","categories":[],"tags":[{"name":"iOS 架构","slug":"iOS-架构","permalink":"http://yoursite.com/tags/iOS-架构/"}]},{"title":"iOS 自动释放池","slug":"ios-autoreleasepool-detail","date":"2018-05-23T08:21:49.000Z","updated":"2018-07-24T08:44:25.000Z","comments":true,"path":"2018/05/23/ios-autoreleasepool-detail/","link":"","permalink":"http://yoursite.com/2018/05/23/ios-autoreleasepool-detail/","excerpt":"摘要： 整个 iOS 的应用都是包含在一个自动释放池 \bblock,\b自动释放池什么时候创建，如何创建？自动释放池什么时候释放，自动释放池如何释放？这篇文章将带你看看…","text":"摘要： 整个 iOS 的应用都是包含在一个自动释放池 \bblock,\b自动释放池什么时候创建，如何创建？自动释放池什么时候释放，自动释放池如何释放？这篇文章将带你看看… 首先autorelease 你在哪里看到呢？最简单的main 函数里面就可以看到： 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 这里显示的看到了autoreleasePool 的调用 @autoreleasepool 123\b@autorelaesepool &#123;&#125; 里面又做了哪些操作呢？ @autoreleasepool 反编译经过反编译后可以看到@autoreleasepool 被转化为 __AtAutoReleasePool __autoreleasepool 12345678910struct __AtAutoReleasePool&#123; __AtAutoReleasePool() &#123;atautoreleasepoolobj = _objc_autoreleasePoolPush();&#125; ~__AtAutoReleasePool() &#123;_objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void *atautoreleasepoolobj;&#125; 这个结构在初始化的时候调用 _objc_autoreleasePoolPush方法 ，在析构的时候调用objc_autoreleasePoolPop的方法 这表明在我们的main函数中，实际工作其实是这样的： 12345678int main(int argc ,const char *argv[] )&#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush();// do doSomeThing objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; AutoReleasePoolPage 是什么ok,接下来分析下objc_autoreleasePoolPush 和 \bobjc_autoreleasepoolpop的实现 123456789void * objc_autoreleasePoolPush(void)&#123; // 这时候 return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125; 这里我们又引入了一个对象 AutoreleasePoolPage AutoreleasePoolPage 的结构1234567891011121314151617class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125; magic 用于对当前AutoreleasePoolPage 完整性的校验 thread 保存了当前页所在的线程 next 指向下一个空地址的地址 parent 和 child \b分别用来存放\b父页面和子页面的地方 每一个自动释放池都是由一系列\b AutoreleasePoolPage组成的，并且每一个AutoreleasepoolPage 的大小都是4096字节 双向链表通过对AutoreleasePoolPage 结构的理解可以看出，这是一个\b双向链表 自动释放池中的栈如果我们在一个AutoreleasePoolPage 初始化在内存的 0x10081600 ~ 0x10081700 中，它在内存中的结构如下： 其中有56bit \b用于存储AutoreleasepoolPage 的变量，剩下的都是用来存储加入到自动释放池中的对象 begin() 和 end（） 帮助我们快速获取page 中存放变量的边界地址 next 指向了下一个为空的内存地址，如果next 指向的地址加入了一个object ,它就会移动到下一个为空的内存地址中 在存储自身的变量和存储加进来的对象之间有一个POOL_SENTINEL 哨兵对象，这个用来区分下次 pop 的时候要 pop 到什么地方的节点。 POOL_SENTINEL （哨兵对象）POOL_SENTINEL 到底是什么？ 它有什么作用 实际上POOL_SENTINEL 只是一个nil 的别名 12#define POOL_SENTINEL nil 在每个自动释放池初始化的调用 objc_autoreleasePoolPush 的时候 都会把一个POOL_SENTINEL push 到自动释放出的栈顶 并返回这个POOL_SENTINEL 哨兵对象 而当方法objc_autoreleasePoolPop 的时候，就会向自动释放池中的对象发送release ，直到第一个POOL_SENTINEL \bobjc_autoreleasePoolPush 方法\b在objc_autoreleasePoolPush中内部的调用： 12345void * objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage:push();&#125; 它调用了AutoreleasePoolPage 的类方法push 12345static inline void *push()&#123; return autoreleaseFast(POOL_SENTINEL);&#125; 这里调用了 autoreleaseFast 并传入了POOL_SENTINEL哨兵对象 12345678910111213static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page -&gt; full()) &#123; return page-&gt;add(obj); &#125;else if(page)&#123; return autoreleaseFullPage(obj,page); &#125;else&#123; return autoreleaseNoPage(obj); &#125;&#125; 上述方法分三种情况选择不同的代码执行： 有hotpage 并且当前的 page 不满 调用 page-&gt;add(obj)方法 将对象添加至AutoreleasePoolPage的栈中 有hotPage 并且当前的page已满 调用 \bautoreleaseFullPage 初始化一个新的页面调用 page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 \b无 hotPage 调用 autoreleaseNoPage 创建一个 hotPage调用page-&gt;add(obj) 方法将对象添加值 AutoreleasePoolPage中 hotpage 可以理解为当前正在使用的AutoreleasePoolPage page-&gt;add 添加对象将对象添加到新的自动释放池页中： 123456789id *add（id obj）&#123; id *ret = next; *next = obj； next++; return ret;&#125; 这个方法就是一个入栈的操作，将对象加入到AutoreleasePoolPage 然后移动 next 的指针 autoreleaseFullPage (当前的hotpage 已满)1234567891011static id *autoreleaseFullPage(id objc , AutoreleasePoolPage *page)&#123; do &#123; if(page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125;while(page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125; 它会传入的Page 来遍历这个双向链表，直到： 查找到一个未满的AutoreleasePoolPage 使用构造器传入parent创建一个新的AutoreleasePoolPage 在查找到一个可用的poolpage后，会标记该页面成为hotPage ，然后调动上面分析过的page-&gt;add的方法添加对象 autoreleaseNoPage如果当前的内存中，不存在hotpage ，就\b\b会调用autoreleaseNoPage 方法来初始化一个AutoreleasePoolPage: 12345678910static id *autoreleaseNoPage (id obj)&#123; AutoreleasepoolPage *page = new AutoreleasepoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 当内存中不存在AutoReleasePoolPage 就要从头开始构建这个自动释放池的双向链表，也就是说，新的AutoreleasPoolPage 是没有parent指针的 初始化之后，将当前的页面标记为hotPage ，然后会向这个Page中添加一个POOL_SENTINEL对象来确保pop调用的时候不会出现异常。 objc_autoreleasePoolPop 方法12345void objc_autoreleasePoolPop(void *ctxt)&#123; AutoReleasePoolPage::pop(ctxt);&#125; 我们一般都会在这个方法中传入一个哨兵对象 \bobjc_autoreleasePoolPop 测试// 在这里我尝试着实现作者的方案，但是没有打印出来，后期会继续尝试 通过static方法获取当前的hotpage 打印 AutoReleasePoolPage 中的内容 打印当前 next 指针指向的内容，以及之前的内容 -2的时候已经到了\bbegin的位置了 使用 print（）和 printAll()打印自动释放池中的内容 \b\b POP 方法传入\b非哨兵参数时可行的，只是我们一般\b不会传入非哨兵对象 12345678910111213141516static inline void pop(void *token) &#123; AutoReleasePoolPage *page = pageForPoint(token); id *stop = (id *)token; page-&gt;releaseUntil(stop); if(page-&gt;child)&#123; if(page-&gt;lessThanHalfFull())&#123; page-&gt;child-&gt;kill(); &#125;else&#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 该静态方法总共做了三件事情： 使用pageForPoint 获取当前token所在的AutoreleasePoolPage 调用 releaseUntil方法释放栈中的对象，直到 stop; 调用 child的 kill 方法 pageForPoint 获取 AutoReleasePoolPagepageForPoint 方法主要是通过内存地址的操作，获取当前指针所在的页面的首地址1234567891011121314151617static AutoReleasePoolPage * pageForPoint(const void *p)&#123; return pageForPoint((uintptr_t)p);&#125;static AutoReleasePoolPage *pageForPoint(uintptr_t p)&#123; AutoReleasePoolPage *result; uintptr_t offset = p%SIZE; assert(offset &gt; sizeof(AutoReleasePoolPage)); result = (AutoReleasePoolPage *)(p - offset); result-&gt; fastcheck(); return result;&#125; 将指针与页面的大小也就是4096取模，得到当前指针的偏移量，因为所有的AutoReleasePoopPage在内存中都是\b对齐的。 12345p = 0x100816048p% SIZE = 0x48result = 0x100816000 而最后调用方法 fastCheck() 用来检测当前的result是不是一个AutoreleasePoolPage releaseUntil 释放对象12345678910111213141516171819202122void releaseUntil(id *stop)&#123; while(this-&gt;next != stop)&#123; AutoReleasePoolPage *page = hotPage; while (page-&gt;empty())&#123; page = page-&gt;patterns; setHotPage(page); &#125; page-&gt;unprotect(); id obj = *--page-&gt;next; memset((void *)page-&gt;next,SCRIBBEL,sizeof(*page-&gt;next)); page-&gt;protect(); if(obj ！= POOL_SENTINEL)&#123; obj_release(obj); &#125; &#125; setHotPage(this);&#125; 它的表现还是比较容易的，用一个While 的循环释放 AutoreleasePoolPage中的内容，直到next 指向了stop kill()方法1234567891011121314151617void kill()&#123; AutoReleasePoolPage *page = this; while (page-&gt;child) page = page-&gt;child; AutoReleasePoopPage *deathptr; do&#123; deathptr = page; page = page -&gt; parent; if (pages) &#123; page -&gt; unprotect(); page-&gt;child = nil; page-&gt;protect(); &#125; delete deathptr; &#125;while (deathptr != this)&#125; 这里首先获取到这个page的最后面的一个child ,然后再通过 parent \b一个一个的进行删除 的操作，然后一直循环 直到获取到了 this 的对象 才跳出循环 总结 首先在我们的程序中使用\bautoreleasePool的方法 一般都是@autoreleasePool{}的操作 但是其实 一个 autoreleasePool 的内部是由一个一个的\bAutoReleasePoopPage所构成的，在构成的过程中，针对开始和结束有两个操作分别是AutoreleasePoolPage::Push 和 AutoreleasePoolPage::POP的操作。通过对AutoreleasePoolPage的结构的了解，我们知道其内部\b包含了一个 parent,child,next等对象，并了解了哨兵POOL_SENTINEL对象。 然后我们针对了objc_autorelasePoolPush的方法进行了深入的了解，其调用\b的顺序是 autoreleaseFast-&gt; 然后在autoreleaseFast的内部 通过判断当前页面是否full来判断是直接page-&gt;add()还是调用autoreleaseFullPage在child中找到一个没有full的page 然后将该page设置为hotpage ，如果\b都是已经满了的话 就直接创建一个新的page 然后往当前hotPage里面add()对象，直接再创建一个新的page来存放，或者说当前没有hotpage的时候直接调用autoreleaseNoPage直接\b创建一个新的Page 并添加入哨兵对象然后再加入对象就可以了. objc_autoreleasePoolPop 调用了pop的操作,首先通过pageForPoint()的方法来获取当前所在的page，然后对\bpage-&gt;autoreleaseUntil(stop)对\b\b其中的对象进行release的操作 autoreleasePool 更多运用在循环中，并且针对线程也可以开启@AutoReleasePool 感谢自动释放池的前世今生 —- 深入解析 autoreleasepool","categories":[],"tags":[{"name":"iOS AutoReleasePool","slug":"iOS-AutoReleasePool","permalink":"http://yoursite.com/tags/iOS-AutoReleasePool/"}]},{"title":"适配器模式","slug":"design-adapter-pattern","date":"2018-05-21T10:06:57.000Z","updated":"2018-05-22T01:52:46.000Z","comments":true,"path":"2018/05/21/design-adapter-pattern/","link":"","permalink":"http://yoursite.com/2018/05/21/design-adapter-pattern/","excerpt":"摘要： 适配器的使用大家应该比较熟悉了吧！加入我们去欧洲旅游的时候，在我们的国内使用的电器，可能不一定能在欧洲国家使用（国内是220V，国外是110V）这时候需要用到适配器，有了适配器可以确保你在110V的时候也能够正常使用电器。简而言之就是我们要使用某个方法，但是我们无法实现，或者说有一个类已经实现了该方法，那我们就可以采用适配的方法来完成，当然还有很多例子可以满足这个需求。\b","text":"摘要： 适配器的使用大家应该比较熟悉了吧！加入我们去欧洲旅游的时候，在我们的国内使用的电器，可能不一定能在欧洲国家使用（国内是220V，国外是110V）这时候需要用到适配器，有了适配器可以确保你在110V的时候也能够正常使用电器。简而言之就是我们要使用某个方法，但是我们无法实现，或者说有一个类已经实现了该方法，那我们就可以采用适配的方法来完成，当然还有很多例子可以满足这个需求。\b 模式动机 在软件开发中采用类似于电源适配器的设计和编码技巧称为适配器模式； 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时候，现有的类可以满足客户的功能需求，但是他所提供的接口不一定是客户所期望的，这可能是因为现有的类中方法名与目标类中的方法名不一致所导致的； 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用，如果不进行这样转化，客户端就不能利用现有类的功能，适配器模式可以完成这样的转化 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器（Adapter） ,它所包装的对象\b就是适配者 也就是被适配的类 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用，也就是说：当客户类调用适配器的方法的时候，适配类中将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类，因此，适配器可以使用由接口不兼容而不能交互的类可以一起工作 模式定义 适配器模式：将一个接口转换成为客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名是包装器。适配器模式可以作为类结构模式，也可以作为对象\b结构模式。 模式\b结构 适配器模式包含如下角色： * target :目标抽象类 * Adapter ： 适配器类 * Adaptee ：适配者类 * Client : 客户端 适配器分为对象适配器和类适配器 对象适配器： 类适配器： 时序图 代码分析通过UML图和时序图我们可以大体猜测出代码的逻辑 类之间的关系：Traget 和 Adapter 是继承的关系 Adapter 和 Adaptee 是关联的关系（聚合和组合也是一种关联的关系） Target123456@interface target ：NSObject-(void)request;@end 适配者12345@interface \bAdaptee : NSObject-(void)specificRequest;@end 适配器1234567891011121314151617181920212223@interface Adapter : target@property (nonatomic ,strong) Adaptee *adaptee;@end// 适配器的实现@implementation Adapter-(instancetype)initWithAdaptee:(Adaptee *)adaptee&#123; self = [super init]; if (self) &#123; self.adaptee = adaptee; &#125; return self;&#125; -(void)request&#123; [self.adaptee specificRequest]; &#125;@end 使用123Adaptee *adaptee = [Adaptee new];Adapter *adapter = [Adapter initWithAdaptee:adaptee];[adapter request];","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"单例模式","slug":"design-sigleton-pattern","date":"2018-05-21T09:33:22.000Z","updated":"2018-05-22T01:52:44.000Z","comments":true,"path":"2018/05/21/design-sigleton-pattern/","link":"","permalink":"http://yoursite.com/2018/05/21/design-sigleton-pattern/","excerpt":"摘要： 对于系统中的某些类来说，只有一个实例是很重要的。该实例可以很好的对数据进行管理和控制。同时也能够更好的控制显示和隐藏的操作等等。那如何才能保证一个类只有一个实例呢？并且比较重要的是，这个实例\b还比较容易访问到，定义一个全局的变量，\b可以确保对象随时都可以被访问，但是不能防止我们实例化多个对象。\b一个更好的办法就是让类自身负责保存它的唯一实例，这个类可以保证\b没有其他实例被创建，并且他可以提供一个方法该实例的方法。这就是单例模式。","text":"摘要： 对于系统中的某些类来说，只有一个实例是很重要的。该实例可以很好的对数据进行管理和控制。同时也能够更好的控制显示和隐藏的操作等等。那如何才能保证一个类只有一个实例呢？并且比较重要的是，这个实例\b还比较容易访问到，定义一个全局的变量，\b可以确保对象随时都可以被访问，但是不能防止我们实例化多个对象。\b一个更好的办法就是让类自身负责保存它的唯一实例，这个类可以保证\b没有其他实例被创建，并且他可以提供一个方法该实例的方法。这就是单例模式。 定义 单例模式： 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类成为单例类，它提供全局访问的方法。 单例模式有三个要点： 某个类只有一个实例 它必须是自行创建这个实例 必须向整个\b系统提供这个实例 结构 从上图中可以看出：首先必须包含一个自身的变量 123456789101112131415161718192021222324+(Singleton *)getInstance()&#123; if (instance == null)&#123; instance = [[Singleton alloc] init]; &#125; return instance;&#125;+(void)operation&#123; NSLog(@&quot; singleton operation&quot;); // 这样操作就进一步的\b保证只有一个实例的产生了 [[Singleton getInstance] addOperation];&#125;-(void)addOperation&#123;&#125;---------操作-------[[Singleton getInstance] addOperation]; 模式分析单例模式的目的是保证一个类\b仅有一个实例，并提供一个访问它的全局访问点。单例模式包含角色只有一个，就是单例类 Singleton 。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它，除此之外，该模式还\b包含一个静态私有成员变量与静态\b公有\b的工厂方法，该工厂方法\b负责检验实例的存在性病实例化自己，然后存在在静态成员的变量中，以确保一个实例被创建。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"iOS 延时操作","slug":"ios-time-delay-method","date":"2018-05-16T07:40:46.000Z","updated":"2018-05-18T01:02:45.000Z","comments":true,"path":"2018/05/16/ios-time-delay-method/","link":"","permalink":"http://yoursite.com/2018/05/16/ios-time-delay-method/","excerpt":"摘要： 在开发的过程中很多时候我们需要用到延时的操作，或者说定时执行\b某些任务，当然我们可能在主线程执行，也可能是在子线程中执行，有些\b延时操作可以\b重复执行，可不可以取消执行等等。所以这里我们就需要定义一些适合我们的延时方法来执行相对应的操作。","text":"摘要： 在开发的过程中很多时候我们需要用到延时的操作，或者说定时执行\b某些任务，当然我们可能在主线程执行，也可能是在子线程中执行，有些\b延时操作可以\b重复执行，可不可以取消执行等等。所以这里我们就需要定义一些适合我们的延时方法来执行相对应的操作。 NSTimer特点： 可以在主线程和子线程中执行 但是方法有所不同 可以取消 可以马上执行 而且可以重复执行 主线程执行1NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timeAction) userInfo:nil repeats:YES]; 子线程执行在子线程中执行\b，需要runloop的配合才能使用123NSTimer *timer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(timeAction) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];[[NSRunLoop currentRunLoop] run]; 取消1[timer invalidate]; 后台执行采用的是后台播放音频操作的方式，首先要满足1234//开启后台处理多媒体事件 [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; AVAudioSession *session=[AVAudioSession sharedInstance]; [session setActive:YES error:nil]; 然后在进入后台的时候，要定义个taskID 1234567891011121314151617181920UIApplication* app = [UIApplication sharedApplication]; __block UIBackgroundTaskIdentifier bgTask; bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;]; dispatch_async(dispatch_get_main_queue(), ^&#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if (bgTask != UIBackgroundTaskInvalid) &#123; bgTask = UIBackgroundTaskInvalid; &#125; &#125;); &#125;); PerformSelector这是针对NSObject的一个类别，所以\b对象都可以使用该方法； 特点是：该方法只能在主线程中执行，可以传递参数\b，也可以取消 但问题是不可以暂停 而且也不存在重复的操作 ·@interface NSObject (NSDelayedPerforming)· 创建的操作123- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay; 取消的操作12+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; GCD特点： 可以在子线程和主线程执行 不可暂停 不同意取消12345678// 主线程执行dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(60*NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; &#125;); // 子线程执行 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5*NSEC_PER_SEC)),dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),^&#123; &#125;); NSThread特点：阻塞线程 （最好不要放在主线程执行） 1[NSThread sleepForTimeInterval:15]; 感谢iOS延迟操作，看这个就行了 NSTimer使用注意点 iOS NSTimer定时器详解 定时器nstimer 详解","categories":[],"tags":[{"name":"iOS 延时操作","slug":"iOS-延时操作","permalink":"http://yoursite.com/tags/iOS-延时操作/"}]},{"title":"建造者模式","slug":"design-builder-model","date":"2018-05-15T09:02:25.000Z","updated":"2018-05-18T01:06:47.000Z","comments":true,"path":"2018/05/15/design-builder-model/","link":"","permalink":"http://yoursite.com/2018/05/15/design-builder-model/","excerpt":"摘要： 无论是在现实世界中还是在软件系统中，都存在一些比较复杂的对象，他们拥有多个组成部分，如汽车，它包括车轮，方向盘，发动机等各个部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一个完整的汽车，可以通过建造者模式对其进行设计和描述。建造者模式可以将组件和其组装过程分开，一步一步创建一个复杂对象。用户只需要指定复杂对象的类型就可以得到该对象，而\b无须知道其内部的具体的构造细节。","text":"摘要： 无论是在现实世界中还是在软件系统中，都存在一些比较复杂的对象，他们拥有多个组成部分，如汽车，它包括车轮，方向盘，发动机等各个部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一个完整的汽车，可以通过建造者模式对其进行设计和描述。建造者模式可以将组件和其组装过程分开，一步一步创建一个复杂对象。用户只需要指定复杂对象的类型就可以得到该对象，而\b无须知道其内部的具体的构造细节。 需求这里我们将造车的操作引入到我们的需求中这里首先我们需要创建车，这时候我们的建造者可以建造SUV,小轿车，由指挥者来指挥具体生成那种车型 定义建造者模式：将一个复杂对象的构建于它的表示分离，是的同样的构建过程可以创建不同的表示 建造者模式是一步一步创建一个复杂的对象，它允许用户只\b通过指定复杂的对象的类型和内容就可以构建他们，用户不需要指定内部的具体构建细节。建造者模式属于对象创建模式。 模式结构建造者模式\b包含如下角色： Builder:抽象建造者 ConcreteBuilder: 具体建造者 Dierctor: 指挥者 Product: 产品角色 通过上图我们可以分析下类之间的关系： concreteBuilder 与 product是依赖的关系（是属于最弱的一种关系，作为返回值的操作）Director 和 Builder 之间是一个聚合的关系 （\b生命周期不一样,也是一种属性，）当然Builder和ConcreteBuilder 之间是一种实现关系 时序图 代码分析首先：产品 \bProduct (车) Builder :抽象建造者123\bCarBuilder:\b-(void)buildCar; 具体的建造者： CarSuvBuilder: SUV的\b建造者 1234567@property (nonatomic ,strong) Car *carProduct;\b-(void)buildCar&#123; carProduct = [[carProduct alloc] init]; carProduct.name = @&quot;SUV&quot;;&#125; CarMpvBuilder: MPV的建造者 1234567@property (nonatomic ,strong) Car *carProduct;\b-(void)buildCar&#123; carProduct = [[carProduct alloc] init]; carProduct.name = @&quot;MPV&quot;;&#125; 指挥者：1234567CarDirector ：@Property(nonatomic ,strong) CarBuilder builder;-(Car*)createCar&#123; [builder buildCar];&#125; 使用：1234CarDirector *director = [[CarBuilder alloc] init];director.builder = [[CarSuvBuilder alloc] init];[director createCar]; 实例分析 在AFNetworking中我们的request的序列化的操作，就是采用\b建造者模式 角色： 建造者：\bAFURLReqeustSerialization 具体建造者： AFHTTPRequestSerializer AFJSONRequestSerializer 指挥者：AFHTTPSessionManager 产品：\bNSURLReqeust 模式分析建造者模式和抽象工厂模式的比较： 与抽象工厂模式想比，\b建造者模式模式返回的是一个组装好的完整的产品，而抽象工厂模式返回的是一系列相关的产品，这些产品位于不同的产品登记中，构成一个产品族 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需的对象，而建造者模式中客户端可以不直接调用建造者模式的相关方法，而是通过指挥者类来\b指定如何生成对象，包括对象的组装过程和建造过程，它侧重于一步步构造一个复杂对象，返回一个完整的对象 如果将抽象工厂模式看成一个汽车配件生成工厂，生成一个产品簇的产品，那么建造者模式就是一个汽车组装工厂，通过对不见的组装可以返回一个完整的汽车","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"iOS LLDB 调试","slug":"ios-debug-lldb","date":"2018-05-10T08:48:24.000Z","updated":"2018-08-03T06:25:19.000Z","comments":true,"path":"2018/05/10/ios-debug-lldb/","link":"","permalink":"http://yoursite.com/2018/05/10/ios-debug-lldb/","excerpt":"摘要： 在\b平常调试的时候，总是有一些是正常的调试无法满足的地方，比如说要修改参数的某个值，或者说要需要打印一些信息，以及针对界面中需要修改一些参数。正常情况下都是需要将代码修改，然后再重启应用才能开到效果。常规操作……","text":"摘要： 在\b平常调试的时候，总是有一些是正常的调试无法满足的地方，比如说要修改参数的某个值，或者说要需要打印一些信息，以及针对界面中需要修改一些参数。正常情况下都是需要将代码修改，然后再重启应用才能开到效果。常规操作…… LLDB 简介Xcode中内嵌了LLDB控制台，就是我们正常使用NSLog()来打印信息的时候，所显示的地方。但是如果我们想要使用LLDB命令的时候，必须让程序进入暂停状态。 LLDB 语法首先关于LLDB的使用，语法要先有所了解，接下来才能更好的大展拳脚呀！&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;]] &lt;action&gt; [-options [option-value]] [argument] 看上去似乎有点复杂点，但是这里需要明确两个&lt; &gt; 和 [] 符号，一个是必填一个是可填的参数 所有这样就会相对简单了； 和 \\ :LLDB 调试的时候使用的\b命令，命令和子命令是按照层级结构来排列的：一个命令对象会为其指明了对象创建一个上下文 ，子命令还会为其子命令创建上下文 以此类推 \\ 执行命令的操作 \\ 命令的选项 \\ 命令的参数 举个例子： breakpoint set -f HelloWorld.m -n main -l 67 对这个命令解析command :breakpointaction :setoptions: -f -n -largument: HelloWorld.m main 67 原始命令LLDB支持不带命令选项的原始命令，原始命令会将命令后面的所有东西都当做参数来看待。当然原始命令也是可以带参数的的，需要在命令选项后面加–区分命令选项和参数 eg: expr count expr -0 – count 唯一匹配原则LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一\b匹配到某个命令，则只写前n个字母等于写下完整的命令 比如说： breakpoint brexpression expr LLDB 命令help个人认为这是最重要的一个命令啦！明白怎么使用这个，后续的问题就看你自己的了首先可能刚接触\bLLDB 还不知怎么使用最简单的： 假如说你对breakpoint比较有兴趣 想要知道具体怎么用 \b 假如你对breakpoint 中的set 比较关注的话 这样一步一步的下来你就会对这个命令比较熟悉了。当然最主要的是\b你需要对一些常用的命令有所了解，这样扩展起来就会比较快速了。 expression\bexpression 命令的作用是执行一个表达式，并将表达式的结构进行返回输出expression &lt;cmd-options&gt; -- &lt;expr&gt; \\: 命令选项 – 命令选项符结束，表示所有的命令选项已经设置完毕，如果没有命令选项，– 可以省略 \\表示要\b执行的表达式 expression 可以说是LLDB中最重要的命令，主要实现了2个功能 我们可以执行某个表达式，改变程序的运行轨迹。expr self.view.backgroundColor = [UIColor redColor]; // 改变颜色expr (void)[CATransaction flush];// 刷新界面 将返回值输出，可以打印信息 12(lldb) expr self(Class) $0 = _AFURLSessionTaskSwizzling p &amp; Print &amp; call正常情况下，我们直接用expression\b还是比较少的，相对于打印操作的时候，更多的时候我们使用的是p、print、call 这三个命令其实都是expression – 的别名1234Command Options Usage: p &lt;expr&gt;&apos;p&apos; is an abbreviation for &apos;expression --&apos; print 表示打印某个东西，可以是变量和表达式 p 可以看做是print的简写 打印一个$符号，数字，再加上一段地址信息。 call 调用\b某个方法 根据\b唯一匹配原则，如果你没有自己\b添加特殊的命令别名。e也可以表示expression的意思，原始命令默认没有命令选项，所以e也能带给你同样的效果 p 还有一个隐藏的功能 常量的进制转换1234567891011121314151617181920(lldb) p 100(int) $0 = 100// 16进制转换(lldb) p/x 100(int) $1 = 0x00000064// 8进制转换(lldb) p/o 100(int) $2 = 0144// 2进制转换(lldb) p/t 4(int) $3 = 0b00000000000000000000000000000100// 字符转10进制(lldb) p/d 'A'(char) $4 = 65、// \b10进制转字符(lldb) p/c 66(int) $5 = B\\0\\0\\0 po正常情况下打印出来的对象都是一个指针，而不是我们希望看到的对象的本身，这样的话，我们想要查看对象的一些属性的时候就无法满足我们的需求了，这时候可以使用po这个命令来进行打印一个OC的对象\b 1234567891011Command Options Usage: po &lt;expr&gt;&apos;po&apos; is an abbreviation for &apos;expression -O --&apos;(lldb) po self&lt;AFHTTPSessionManager: 0x16d581e0, baseURL: (null), session: &lt;__NSURLSessionLocal: 0x16d5e620&gt;, operationQueue: &lt;NSOperationQueue: 0x16d582a0&gt;&#123;name = &apos;NSOperationQueue 0x16d582a0&apos;&#125;&gt;(lldb) p self(AFHTTPSessionManager *) $10 = 0x16d581e0(lldb) \bpo 命令会尝试调用对象的description 方法来获取对象的信息，所以如果你想要打印更多的信息的话，可以重写该方法，增加更多的实现 ，这样在下次 po 对象的时候就可以查看到更多的信息。 thread是针对同一进程中一个或\b多个线程的操作的命令\b。 打印堆栈 thread backtrace &amp; bt当我们想要了解当前\b线程的堆栈信息的时候，可以使用这个命令将堆栈信息给打印出来1thread backtrace [-c &lt;count&gt;] [-s &lt;frame-index&gt;] [-e &lt;boolean&gt;] thread backtrace 后面跟的\b都是命令选项 -c :设置打印堆栈\b的帧数（frame） -s :设置从哪个帧开始打印 -e :是否显示额外的回溯 123456(lldb) thread backtrace* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 149.1* frame #0: 0x002170d0 GyennoSpoon`-[AFURLSessionManager initWithSessionConfiguration:](self=0x16d581e0, _cmd=&quot;initWithSessionConfiguration:&quot;, configuration=0x16e5ff90) at AFURLSessionManager.m:555frame #1: 0x001f4e40 GyennoSpoon`-[AFHTTPSessionManager initWithBaseURL:sessionConfiguration:](self=0x00000000, _cmd=&quot;initWithBaseURL:sessionConfiguration:&quot;, url=@&quot;http://apptest.gyenno.com/service_im_test/v3/&quot;, configuration=0x16e5ff90) at AFHTTPSessionManager.m:69frame #2: 0x00128f74 GyennoSpoon`+[GYNetworking creatJsonManagerWithUrl:](self=GYNetworking, _cmd=&quot;creatJsonManagerWithUrl:&quot;, url=@&quot;http://apptest.gyenno.com/service_im_test/v3/&quot;) at GYNetworking.m:232frame #3: 0x0012b5ee GyennoSpoon`+[GYNetworking postV4RequestWithURL:paramters:onSuccess:onError:](self=GYNetworking, _cmd=&quot;postV4RequestWithURL:paramters:onSuccess:onError:&quot;, url=@&quot;user/signIn&quot;, paramters=3 key/value pairs, successBlock=0x00196e0d, errorBlock=0x00197811) at GYNetworking.m:421 在这里当我们的程序发生crash的时候，我们可以使用thread backtrace 查看\b堆栈调用可以查看发生错误的对应的行数，这样就可以方便我们跟踪问题当然在使用的时候可以使用bt 来替代thead backtrace 的操作 thread return 跳出当前方法的执行Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值，这时候就该thread return 了。 1thread return [&lt;expr&gt;] thread return 可以接受一个表达式，调用命令之后直接从当前的frame返回表达式的值 使用方法：只需要在方法的开始的位置上加一个断点，当程序中断的时候，输入命令就可以了 thread return NO效果就相当于在断点位置直接调用return NO ，\b不会执行断点后面的代码 c &amp; n &amp; s &amp; finish 流程控制在我们调试程序的时候，这些都是比较常用的\b调试操作LLDB也分别针对这些命令使用了不同的快捷键来标识相对应的操作 c/continue/thread continue : 这三个命令效果相等于上图中的第一个按钮，表示程序继续运行 n/next/thread step-over :这三个命令等同于上图中第二个按钮，表示单步运行 s/step/thread step-in :这三个命令效果等同于第三个按钮 ，表示进入某个方法 finish /thread step-out : 这两个命令等同于第四个按钮，表示直接走完当前方法，返回到上一层frame thread 其他不常用的命令thread 相关的还有一些其他不怎么常用的命令， thread jump : 直接让程序跳到某一行，由于ARC编译器实际插入不少 retain,release命令，跳过一些代码不执行可能会造成对象内存混乱发生crash thread list : 列出所有的线程 thread select：选择某个线程 thread until ：传入一个line\b的参数，让\b程序执行到这行暂停 thread info : 输出当前线程的信息 frameframe 对应的就是堆栈中的信息，当然我们可以查看到一些比较详细的信息 frame veriable在我们平时进行debug的时候，主要的目的就是为了查看变量的值，但是通过frame variable命令我们可以打印冲当前frame的所有变量 1234(lldb) frame variable(AppDelegate *) self = 0x16d16710(SEL) _cmd = \"loginInWindow:\"(NSConcreteNotification *) info = 0x16e47560 @\"loginIn\" \b这里打印的是当前frame的所有的参数，如果需要打印是具体的参数的话，可以使用 123(lldb) frame variable method(__NSCFConstantString *) method = 0x003abe30 @\"GET\"(lldb) frame 不常用的命令一般用frame来打印所有变量用的比较多，frame还有些不怎么常用的命令： frame info:查看当前frame的信息 frame select:选择某个frame breakpoint\b调试的时候，我们用的最多的就是断点 breakpoint setbreakpoint set 命令在于设置断点，LLDB提供了很多设置断点的方式：使用 -n 根据方法名设置断点1breakpoint set -n viewWillAppear: 使用-f 指定文件 eg:我们需要给ViewController.m 中的viewDidLoad设置断点 1breakpoint set -f ViewController.m -n viewDidLoad 使用-l指定\b文件的某一行设置断点1breakpoint set -f ViewController.m -l 38 使用-c 设置条件断点 eg: text：方法\b接收一个ret的参数，我们想让ret == YES的时候，程序中断1breakpoint set -n text: -c ret == YES 使用-o 设置单次断点eg:如果某个断点我们只想让它中断一次：1breakpoint set -n text: -o breakpoint Command有时候我们可能需要给断点添加一些命令，比如每次走到这个断点的时候\b，我们需要打印self的对象。我们只需要给断点添加一个po self的命令，就不用每次断点再输出po self了 breakpoint command add: breakpoint command add命令就是给断点添加命令的命令\b 1breakpoint command add -o &quot;po self.view&quot; 3 -o的写法是–one-liner 表示增加一条命令，3 表示的是id为3的breakpoint ; 如果需要添加多个命令的话可以使用1234(lldb) breakpoint command add 237Enter your debugger command(s). Type &apos;DONE&apos; to end.&gt; po self&gt; DONE breakpoint command list如果你想要查看某个断点已有的命令，可以使用breakpoint command list .1234(lldb) breakpoint command list 237Breakpoint 237: Breakpoint commands: po self breakpoint command delete用于删除某个断点的命令 123(lldb) breakpoint command delete 237(lldb) breakpoint command listerror: No breakpoint specified for which to list the commands breakpoint list用于查看\b断点列表 1234567(lldb) breakpoint listCurrent breakpoints:1: file = &apos;/Users/lmzqm/GyennoSpoonIOS/GyennoSpoon/GyennoSpoon/NetWorkManager/NetWorkManager.m&apos;, line = 292, exact_match = 0, locations = 1, resolved = 1, hit count = 0 1.1: where = GyennoSpoon`__47-[NetWorkManager validateUser:success:failure:]_block_invoke + 32 at NetWorkManager.m:292, address = 0x00091aa0, resolved, hit count = 02: file = &apos;/Users/lmzqm/GyennoSpoonIOS/GyennoSpoon/GyennoSpoon/NetWorkManager/NetWorkManager.m&apos;, line = 298, exact_match = 0, locations = 1, resolved = 1, hit count = 0 breakpoint disable/enable让断点失效/生效的操作 后面跟参数也是断点的id \b breakpoint delete删除某个具体的断点 12(lldb) breakpoint delete 2371 breakpoints deleted; 0 breakpoint locations disabled. 如果想要删除所有的断点 就不需要带参数就可以了 watchpointbreakpoint 和watchpoint 最大的不同是一个是\b针对断点进行监控\b，一个是针对地址进行控制。使用watchpoint 来对地址进行观察，当地址里面的东西改变的时候，就让这个程序中断。 watchPoint 是直接设置到该变量所在的内存地址上，所以当这个变量释放后，watchpoint 仍然会对这个地址的内存生效 我们在LLDB 中直接watchPoint 的命令，可以通过选项实现更多效果 12345678910watchpoint set self-&gt;testVar //为该变量地址设置watchpointwatcpoint set expression 0x00007fb27b49 //为该地址设置watchpoint \b内存地址可以从前面提到的p命令提取watchPoint command add -o 'frame info' 1 //为watchpoing 1 加上子命令 、frame info、watchpoint list ：列出所有的watchpointwatchpoint delete //删除所有的watchpoint watchpoint set用于添加一个watchpoint .只要这个地址中的内容发生变化了，程序就会中断。 watchpoint set variable 12345(lldb) watchpoint set variable wifiSSIDWatchpoint created: Watchpoint 1: addr = 0x006e5428 size = 4 state = enabled type = w declare @ &apos;/Users/lmzqm/GyennoSpoonIOS/GyennoSpoon/GyennoSpoon/Devices/Controller/GYEDeviceConnectViewController.m:134&apos; watchpoint spec = &apos;wifiSSID&apos; new value: 0x16eb8ab0 其中传入的是变量名称 watchpoint set expression 如果我们想要直接观察某个地址\b，我们可以使用watchpoint set expression:可以先用p 打印地址，然后再监听这个地址 watchpoint command和breakpoint 类似，在watchpoint中也\b可以添加命令 watchpoint command add 1(lldb) watchpoint command add -o &apos;bt&apos; 1 watchpoint command list watchpoint command delete Watchpoint list如果我们想要看所有的watchpoint,可以使用watchpoint list watchpoint disable当我们不想要让某个watchpoint生效的时候，可以使用watchpoint disable watchpoint enable当我们想要某个watchpoint 生效的时候 watchpoint delete删除某个watchpoint 的操作 Targettarget modules lookup (image lookup) 对于target这个命令\b，用的比较多的可能就是target modules lookup.由于LLDB给target modusles \b取了个别名image ,所以这个命令我们又可以写成 image lookup image lookup -address当我们有一个地址的时候，想要查找这个地址具体对应的文件位置，可以使用image lookup –address .可以简写为 image lookup -a比如在我们程序崩溃的时候回，我们可以通过这个边界的地址，来查看具体是哪里发生了崩溃的地方 1234image lookup -a 0x0000000xxxx// 然后打印想用的堆栈信息 image lookup -name 查找方法源当我们需要查找一个方法或者符号信息，包括在第三方SDK 中的方法 比如所在文件位置的时候，我们可以使用image lookup –name 123456(lldb) image lookup -n userDetailAction2 matches found in /Users/lmzqm/Library/Developer/Xcode/DerivedData/GyennoSpoon-elemepertoodhifkmigcnotkwtxs/Build/Products/Debug-iphoneos/GyennoSpoon.app/GyennoSpoon: Address: GyennoSpoon[0x0009de98] (GyennoSpoon.__TEXT.__text + 612160) Summary: GyennoSpoon`-[GYENoSpoonViewController userDetailAction] at GYENoSpoonViewController.m:44 Address: GyennoSpoon[0x000bd6f8] (GyennoSpoon.__TEXT.__text + 741280) Summary: GyennoSpoon`-[GYEMySpoonViewController userDetailAction] at GYEMySpoonViewController.m:42 可以通过这个迅速的查找到\b对应方法所在的位置 image lookup – type 查找成员当我们需要查看一个某个Class 的所有属性和成员变量的时候 ，可以使用image lookup –type 12345678910(lldb) image lookup -t SpoonModel1 match found in /Users/lmzqm/Library/Developer/Xcode/DerivedData/GyennoSpoon-elemepertoodhifkmigcnotkwtxs/Build/Products/Debug-iphoneos/GyennoSpoon.app/GyennoSpoon:id = &#123;0x700000027&#125;, name = \"SpoonModel\", byte-size = 12, decl = SpoonModel.h:11, compiler_type = \"@interface SpoonModel : NSObject&#123; NSString * _prefix; NSString * _detail;&#125;@property ( getter = prefix,setter = setPrefix:,readwrite,copy,nonatomic ) NSString * prefix;@property ( getter = detail,setter = setDetail:,readwrite,copy,nonatomic ) NSString * detail;@end\" target stop-hooktarget stop-hook命令是让你在可以在每次stop的时候去执行一些命令： target stop-hook 只对breakpoint 和 watchpoint 的程序的stop生效。点击xcode上的暂停是不会生效的 target stop-hook add &amp; display 假如我们想要在每次程序stop的时候，都用命令打印当前frame的所有变量，我们可以添加一个stop-hook target stop-hook list 当添加完stop-hook之后，我们想看当前所有的stop-hook怎么办，可以使用stop-hook list target stop-hook delete &amp; undisplay 有添加的命令就会有删除的命令 如果觉得命令有点长 可以直接使用 undisplay target stop-hook disable/enable 如果我们想要让某个stop-hook失效的时候，我们可以使用 \btarget stop-hook disable id 当然有失效就会有生效 可以使用 target stop-hook enable id target symbols add (add-dsym) dsym文件，程序运行的时候，都会编译成二进制文件。因为计算机只\b识别二进制文件，那为什么我们还能在代码上打断点？ 这主要是因为在编译的时候xcode 会生成dsYM 文件记录了哪些代码对应着哪些二进制，这样我们对代码打断点就会对应到二进制上 当Xcode找不到dsYM文件的时候，我们就无法对代码打断点。进行调试。target symbols add 命令的作用就是让我们可以手动的将dsYM 文件添加上去。LLDB 对这个\b命令起来一个别名：add-dsYM 别名其实很多命令的是LLDB 一些命令的别名，比如p 是frame variable 的别名，p View 实际上是frame variable View ，除了系统自建LLDB 别名，你也可以自定义自己的别名。 自定义别名 command alias很多时候，LLDB 完整的命令很长，比如前面所说的image Lookup -address 这个组合命令，为了方便日常的使用，提高效率，LLDB 命令也提供通过简称的方式调用命令。 \b123456(lldb) command alias itemShow frame variable(lldb) itemShow(GYELoginView *) self = 0x17dd6180(SEL) _cmd = \"configLoginData\"(GYEUser *) user = 0x17ef9280 带参数别名 command alias %1 %2等等123456(lldb) command alias deletepoint breakpoint delete %1(lldb) breakpoint 1invalid command 'breakpoint 1'.(lldb) deletepoint 11 breakpoints deleted; 0 breakpoint locations disabled. 持久化存储我们在\bXCode 下打 command alias 在下次项目运行的时候直接就没了，有个办法可以做到持久化存储，LLDB 初始化的时候会读取这个 ~/.lldbinit 文件 ，我们可以把简写的命令写进这个文件中 添加的步骤： 打开终端，输入vi ~/.lldbinit 进入文件编辑 写入自定义的内容，如: command alias 堆栈 thread backtrace 然后ESC 键，出现冒号好输入wq ,enter键保存并退出编辑 感谢熟练使用 LLDB，让你调试事半功倍与调试器共舞 - LLDB 的华尔兹iOS之LLDB常用命令iOS调试-LLDB学习总结","categories":[],"tags":[{"name":"LLDB","slug":"LLDB","permalink":"http://yoursite.com/tags/LLDB/"}]},{"title":"AFNetworking源码之AFURLRequestSerialization","slug":"AFNetworking-AFURLRequestSerialization","date":"2018-05-09T01:50:01.000Z","updated":"2018-07-10T02:55:13.000Z","comments":true,"path":"2018/05/09/AFNetworking-AFURLRequestSerialization/","link":"","permalink":"http://yoursite.com/2018/05/09/AFNetworking-AFURLRequestSerialization/","excerpt":"摘要：在之前我们看到过\bAFHTTPSessionManager 中进行网络请求操作的时候有两个步骤： 首先先构建request 通过构建的request来创建task 关于利用request来创建task的步骤以及在AFURLSessionManager中已经将过程的\b都有很详细的描述了。 那我们的reqeust是如何进行构建的呢？就是我们今天的主角啦！","text":"摘要：在之前我们看到过\bAFHTTPSessionManager 中进行网络请求操作的时候有两个步骤： 首先先构建request 通过构建的request来创建task 关于利用request来创建task的步骤以及在AFURLSessionManager中已经将过程的\b都有很详细的描述了。 那我们的reqeust是如何进行构建的呢？就是我们今天的主角啦！ 实例这里直接截取代码后面再一步\b\b一步的解析：这里是核心代码哦！来自于 AFHTTPSessionManager123NSError *serializationError = nil;NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; API解析接下来分析下AFURLRequestSerialization的来龙去脉 AFURLRequestSerialization123456@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;// 该协议只有一个方法- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW; AFHTTPReqeustSerializer首先：@interface AFHTTPRequestSerializer : NSObject &lt;AFURLRequestSerialization&gt; 属性123456789101112131415161718192021222324252627// \b字符串的编码格式 主要用于对参数的编码 默认是NSUTF8stringEncoding@property (nonatomic, assign) NSStringEncoding stringEncoding;// 创建的请求是否可以使用蜂窝\b数据 默认是YES@property (nonatomic ,assign) BOOL allowsCellularAccess;// 请求的缓存策略 默认是：NSURLRequestUseProtocolCachePolicy@property (nonatomic ,assign) NSURLRequestCachePolicy cachePolicy;// 创建的request是否可以用默认的cookie 处理 默认是YES@property (nonatomic ,assign) BOOL HTTPShouldHandleCookies;// 请求是否在接收到响应之前继续传输数据 默认为NO@property (nonatomic ,assign) BOOL HTTPShouldUsePipelining;// 请求的网络服务@property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;// 请求超时时间@property (nonatomic, assign) NSTimeInterval timeoutInterval;// 请求头的\b字段@property (nonatomic ,readonly, strong) NSDictionary &lt;NSString *,NSString *&gt; *HTTPReqeustHeaders;// 针对序列化后将参数转为字符串的请求 \bGET HEAD delete@property (nonatomic, strong) NSSet &lt;NSString *&gt; *HTTPMethodsEncodingParametersInURI; 方法12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建并返回一个采用默认配置的序列化对象+（instancetype ）serializer;// 为请求头设置信息- (void)setValue:(nullable NSString *)valueforHTTPHeaderField:(NSString *)field;// 获取请求头中对应字段的值 没有就返回nil- (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;// 为&quot;Authorization&quot; 设置字段值- (void)setAuthorizationHeaderFieldWithUsername:(NSString *)username password:(NSString *)password;// 清楚&quot;Authorization&quot;- (void)clearAuthorizationHeader;- (void)setQueryStringSerializationWithStyle:(AFHTTPRequestQueryStringSerializationStyle)style;// 设置序列化的\b接口- (void)setQueryStringSerializationWithBlock:(nullable NSString * (^)(NSURLRequest *request, id parameters, NSError * __autoreleasing *error))block// 接下来请求的方法// 创建一个NSMutableURLReqeust 对象通过特殊的HTTP方法和URL-(NSMutableURLRequest*)requestWith\bMethod:(NSString *)methods URLString:(NSString *)URLString parameters:(nullable id )parameters error:(NSError *_Nullable __autoreleasing *)error;// 这里也是创建一个NSMutableURLReqeust 并且利用特殊的参数和multipart formData 来构建一个‘multipart/form-data’的\bHTTP BODY - (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(nullable NSDictionary&lt;NSString *, id&gt; *)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError * _Nullable __autoreleasing *)error;//- (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request writingStreamContentsToFile:(NSURL *)fileURL completionHandler:(nullable void (^)(NSError * _Nullable error))handler; 初始化操作12345678910111213141516171819202122232425262728293031323334353637383940-（instancetype）init&#123; self = [super init]; if (!self) &#123; return nil; &#125; self.stringEncoding = NSUTF8StringEncoding; self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary]; // 枚举系统的语言列表 然后设置Accept-language NSMutableArray *acceptLanugagesComponents = [NSMutableArray array]; [NSLocation preferredLanguages] enumerateKeysAndObjectsUsingBlock:^(id obj,NSUInteger idx ,BOOL *stop)]&#123; float q = 1.0f- (idx *0.1f); [acceptLanugagesComponents addObject:[NSString stringWithFormat:@&quot;%@;q=%0.1g&quot;,obj,q]]; *stop = q&lt; 0.5f; &#125; [self setvalue:[acceptLanugagesComponents componentJoinedByString:@&quot;,&quot;] forHTTPHeaderField:@&quot;Accept-Language&quot;]; NSString *userAgent = nil; userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]]; // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html// 需要将parameter转换为query参数的方法集合self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil];self.mutableObservedChangedKeyPaths = [NSMutableSet set];// 添加对 蜂窝数据，缓存策略。cookie 管道 网络状态 超时这几个属性的观察for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext]; &#125;&#125;return self;&#125; 感谢AFNetWorking源码之AFURLRequestSerialization","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"工厂方法模式","slug":"factior-method-pattern","date":"2018-05-08T08:19:41.000Z","updated":"2018-08-06T07:43:35.000Z","comments":true,"path":"2018/05/08/factior-method-pattern/","link":"","permalink":"http://yoursite.com/2018/05/08/factior-method-pattern/","excerpt":"摘要：工厂方法模式成为工厂模式，它属于类创建模式。在工厂模式中。工厂的父类负责定义创建产品对象的公共接口，而子类则负责生成具体的产品对象，这样做的目的是将产品类的实例操作延迟到工厂子类中完成，\b也就是通过工厂子类来创建具体的产品类。 工厂方法模式的用意是 定义一个创建\b产品的对象的工厂接口，将实际创建工厂推迟到子类中。","text":"摘要：工厂方法模式成为工厂模式，它属于类创建模式。在工厂模式中。工厂的父类负责定义创建产品对象的公共接口，而子类则负责生成具体的产品对象，这样做的目的是将产品类的实例操作延迟到工厂子类中完成，\b也就是通过工厂子类来创建具体的产品类。 工厂方法模式的用意是 定义一个创建\b产品的对象的工厂接口，将实际创建工厂推迟到子类中。 工厂方法模式工厂方法模式是对简单工厂模式的进一步抽象的结果 假如不使用反射的工厂方法模式，那么所有的if…else… 都放在工厂类中，势必造成工厂类无限臃肿 这时候就需要工厂方法模式来处理这个问题，工厂方法模式中狠心的工厂类再不负责所有对象的创建，而是将具体的创建工作交给子类去做。这个类\b就变成了一个抽象工厂的角色了，仅仅复杂给具体的子类必须实现的接口 这一步的改进，使得系统可以在不修改具体工厂角色的情况下引入新的产品。 模式结构工厂方法模式包含如下角色： 1、Product ：抽象产品 工厂方法模式所场景的对象的超类 2、ConcreteProduct : 具体角色 该角色实现了抽象角色所声明的接口，工厂方法模式所创建的\b每一个对象都是具体的角色导出角色的实例 3、Factory : 抽象工厂角色 担任这个角色是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口 4、ConcreteFactory : 具体工厂 担任这个角色的是实现了工厂接口的具体类。具体的工厂角色与业务密切相关，并且随着使用者的调用以创建导出类 代码分析需求分析： 首先由\b一个文件导出操作，一个是导出PDF 一个是导出HTML的操作 // 抽象的工厂 @protocol GYEFileFactory &lt;NSObject&gt; -(id&lt;GYEProduct&gt;) creatProduct; @end // 具体的工厂 @interface GYEHtmlFileFactory:NSObject &lt;GYEFileFactory&gt; @end // 具体的工厂 @interface GYEPDFFileFactory:NSObject &lt;GYEFileFactory&gt; @end 在具体的工厂中创建具体的对象 @implementation GYEHtmlFileFactory -(id&lt;GYEProduct&gt;) creatProduct{ return [[GYEHtmlProduct alloc] init]; } @end @implementation GYEPDFFileFactory -(id&lt;GYEProduct&gt;) creatProduct{ return [[GYEPDFProduct alloc] init]; } @end 模式分析 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用面向对象的多态性，工厂方法模式保持了简单工厂模式的特点，而且也克服了它的缺点。在工厂模式中不在负责所有产品的创建而是将具体的创建交给子类去做。\b这个核心类仅仅负责给出具体工厂必须实现的接口，而不是负责哪一个产品被实例化的细节，这使得工厂模式可以允许系统在不修改工厂角色的情况下引进新产品 总结 工厂方法模式的主要优点是增加了新的产品类的时候无需修改\b现有系统\b，并封装了产品对象的创建细节，系统有良好的灵活性和可扩展性；缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对的增加，在一定程度上增加了系统的复杂性 对于系统的\b设计应该足够灵活并尽降低代码直接的耦合。当修改或者增加一个新的功能的时候，使得使用者尽可能\b修改少的地方就可以。加入设计不够灵活，将无法面对多变的需求，可能一个极小的需求的变更，都会使代码结构发生改变。并导致其他使用的人都要修改他们的代码。牵一发而动全身，系统然后的维护将变得艰难","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"简单工厂模式","slug":"simple-factory-pattern","date":"2018-05-08T06:45:39.000Z","updated":"2018-05-09T01:32:41.000Z","comments":true,"path":"2018/05/08/simple-factory-pattern/","link":"","permalink":"http://yoursite.com/2018/05/08/simple-factory-pattern/","excerpt":"摘要： 简单工厂模式又称为静态工厂方法模式。它属于创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他\b类的实例，被创建的实例通常具有共同的父类。","text":"摘要： 简单工厂模式又称为静态工厂方法模式。它属于创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他\b类的实例，被创建的实例通常具有共同的父类。 模式结构 简单工厂模式包含如下角色： Factory：工厂角色 工厂角色服装实现穿甲所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是创建所有对象的父类，负责描述所有实例的公共接口 ConcreteProduct：具体产品角色 具体的产品角色是创建的目标，所有创建的对象都充当这个角色的某一个具体类的实例 代码分析 将根据产品，工厂，\b\b和使用方法来进行分析 产品： // 创建一个抽象的产品 @protocol GYEProduct &lt;NSObject&gt; - (void)use; @end // 具体的产品A @interface GYESimpleProductA : NSObject &lt;GYEProduct&gt; @end // 具体的产品B @interface GYESimplePriductB : NSObject &lt;GYEProduct&gt; @end 工厂类： @implementation GYESimpleFactory -(id&lt;GYEProduct&gt; )createProduct:(NSString *)product{ if ([product isEqualToString:@&quot;A&quot;]) { return [GYESimpleProductA new]; }else if([product isEqualToString:@&quot;B&quot;]){ return [[GYESimplePriductB alloc] init]; }else{ return nil; } } 使用： -(void)test{ id &lt;GYEProduct&gt; product = [self createProduct:@&quot;A&quot;]; [product use]; } 优化： 这里工厂类中，随着产品的增加 if…else…的操作会越来越多，慢慢的增加，一直这样下去将会越来越长 这里可以使用runtime的方式来进行简化操作 //这里也可以采用runtime的方式来进行处理 // 根据传入的的类的字符串来进行操作 Class class = NSClassFromString(product); if ([class conformsToProtocol:NSProtocolFromString(@“GYEProduct”)]) { //判断这个实例有没有实现GYEProduct这个协议 return [[class alloc] init]; } 在使用的时候也要进行修改： -(void)test{ id &lt;GYEProduct&gt; product = [self createProduct:NSStringFromClass([GYESimplePriductB class])]; [product use]; } 模式分析 将对象的创建和对象本身业务\b处理分离可以降低系统的耦合度，是的两者修改起来相对容易 在对外部的使用过程中使用父类来替代子类，这样可以统一做处理，而且子类都需要实现父类的方法 简单工厂模式主要在于工厂\b类中需要根据传入的参数然后\b创建对应的子类的实例化对象 该方法屏蔽了实例化的过程，对于用户来说\b不需要知道如何创建的，只需要根据自己的需求来获取对应的实例就可以了 实例运用在AFNetworking中有一个序列化的操作： 首先\b有一个协议 AFURLRequestSerialization @protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt; 协议中有一个方法： -(nullable NSURLRequest )requestBySerializingRequest:(NSURLRequest )request withParameters:(nullable id)parameters error:(NSError _Nullable __autoreleasing )error AFHTTPRequestSerializer @interface AFHTTPRequestSerializer : NSObject - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error { NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; // 对GET HEAD DELETE等方法中，直接使用父类的处理方式 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) { // 将HttpRequstHeader中的值添加加入到请求头中 if (![request valueForHTTPHeaderField:field]) { [mutableRequest setValue:value forHTTPHeaderField:field]; } }]; NSString *query = nil; if (parameters) { if (self.queryStringSerialization) { NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) { if (error) { *error = serializationError; } return nil; } } else { switch (self.queryStringSerializationStyle) { case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; } } } if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) { if (query &amp;&amp; query.length &gt; 0) { mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]]; } } else { // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) { query = @&quot;&quot;; } if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) { [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; } [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; } return mutableRequest; } AFJSONRequestSerializer @interface AFJSONRequestSerializer : AFHTTPRequestSerializer - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error { NSParameterAssert(request); // 对于GET HEAD DELETE等方法中，直接使用父类的处理方式 if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) { return [super requestBySerializingRequest:request withParameters:parameters error:error]; } NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) { if (![request valueForHTTPHeaderField:field]) { [mutableRequest setValue:value forHTTPHeaderField:field]; } }]; // 设置请求头的Content-Type类型 if (parameters) { if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) { [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; } [mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]]; } return mutableRequest; } 在使用的时候：我们可以将其改造成\b简单工厂模式 NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; 总结 针对类的实例化过程进行了抽象，能够将对象的创建和对象的使用过程进行分离 简单工厂模式由三个角色：工厂角色 负责创建所有实例的内部逻辑；抽象\b产品 是\b所创建的所有对象的父类，负责提供实例所有的共接口；具体的产品角色是创建目标 简单工厂模式最大的优点就是实现了对象的创建和使用的分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂不够灵活，增加新的\b具体产品需要修改工厂类的相关逻辑代码而且\b随者产品的增加会越来越复杂 \b","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"AFNetworking-AFHTTPSessionManager 详解","slug":"AFNetworking-AFHTTPSessionManager","date":"2018-05-08T02:51:55.000Z","updated":"2018-05-08T06:31:26.000Z","comments":true,"path":"2018/05/08/AFNetworking-AFHTTPSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/08/AFNetworking-AFHTTPSessionManager/","excerpt":"摘要： 这里我们要给大家讲述下AFHTTPSessionManager\b\b中的知识点。\b首先要知道AFHTTPSessionManager是继承与AFURLSessionManager的，所以，创建\bTask的是可以完成的。AFHTTPSessionManager 更多是关注与HTTP的请求的操作，其核心更多是关于Request的构建，这个request主要用于task的创建。","text":"摘要： 这里我们要给大家讲述下AFHTTPSessionManager\b\b中的知识点。\b首先要知道AFHTTPSessionManager是继承与AFURLSessionManager的，所以，创建\bTask的是可以完成的。AFHTTPSessionManager 更多是关注与HTTP的请求的操作，其核心更多是关于Request的构建，这个request主要用于task的创建。 属性//这个是请求的基础URL 后续的可以使用拼接构成一个新的URL来进行请求的操作 @property(readonly , nonatomic, strong, nullable) NSURL *baseURL; // 这是请求的序列化 主要针对请求的过程中进行reqeust的构建 @property(nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLReqeustSerialization&gt; *requestSerializer; // 这是响应的序列化 主要针对Response中数据的处理操作 @property (nonatomic, strong) AFHTTPReponseSerializer &lt;AFURLResonseSerialization&gt; *responseSerializer; 方法这里的方法主要有初始化的方法，还有针对不同请求方式的方法 初始化/** Creates and returns an `AFHTTPSessionManager` object. */ + (instancetype)manager; /** Initializes an `AFHTTPSessionManager` object with the specified base URL. @param url The base URL for the HTTP client. @return The newly-initialized HTTP client */ - (instancetype)initWithBaseURL:(nullable NSURL *)url; // - (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration { //调用父类来创建一个实例 self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) { url = [url URLByAppendingPathComponent:@&quot;&quot;]; } self.baseURL = url; // 默认采用HTTPSErializer self.requestSerializer = [AFHTTPRequestSerializer serializer]; // 默认采用JSONResonseSerilizer self.responseSerializer = [AFJSONResponseSerializer serializer]; return self; } GET// 通过一个requst来创建并运行一个Get的请求 - (nullable NSURLSessionDataTask*)GET:(NSString*)URLString parameters:(nullable id)parameters success:(nullable void(^)(NSURLSessionDataTask *_Nullable task ,id _Nullable responseObject ))success failure:(nullable void (^)(NSURLSessionDataTask *_Nullable task ,NSError *error))failure; - (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; HEAD- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; POST- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE; - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; PUT- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; PATCH- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; DELETE- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 核心// 构建网络请求的操作 这里主要是针对一些\b比较\b简单的 除了带\bformData 的数据的处理 - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure { // 这里进行序列化的操作 通过序列化\b获得到\b一个请求操作 NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; // 如果序列化出错的处理操作 if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } // 获取task的操作 __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask; } POST的操作方式 - (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure { NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError]; NSDictionary *dic = request.allHTTPHeaderFields; // NSData *data = request.HTTPBodyStream; // id body = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; NSLog(@&quot;%@&quot;,dic); // NSLog(@&quot;%@&quot;,body); if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(task, error); } } else { if (success) { success(task, responseObject); } } }]; [task resume]; return task; } POST请求的常用格式 在众多请求方法中POST的请求还是相对复杂点的，比如\b说比较常见的文件上传的请求操作，其中还会带带一些额外的参数，这样的话请求体的构建\b就会比较复杂点。 application/x-www-form-urlencoded 格式的\bPOST请求这是比较常见的POST提交数据的方式。浏览器原生表单，如果不设置\b的话，默认就会用这种方式提交。如果以这种格式\b进行操作的话：提交的数据会按照 key1=val1&amp;key2=val2的方式进行编码。同时key和val都会进行URL转码 代码展示： // 构建一个sessionConfig NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; config.HTTPAdditionalHeaders = @{};//可以添加额外的请求头信息 // 创建一个HTTPSessionManager AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:_config.baseUrl] sessionConfiguration:config]; //创建一个请求的序列化操作 AFHTTPRequestSerializer *serializer = [AFHTTPRequestSerializer serializer]; // 设置超时时间 serializer.timeoutInterval = 10; // 可以添加一些请求头的信息 [serializer setValue:@&quot;&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; manager.requestSerializer = serializer; NSMutableSet *mulSet = [NSMutableSet setWithSet:manager.responseSerializer.acceptableContentTypes]; [mulSet addObject:@&quot;application/json&quot;]; [mulSet addObject:@&quot;text/plain&quot;]; [mulSet addObject:@&quot;text/json&quot;]; [mulSet addObject:@&quot;text/html&quot;]; // 添加\b响应序列化操作 manager.responseSerializer = [AFHTTPResponseSerializer serializer]; manager.responseSerializer.acceptableContentTypes = mulSet; // 构建task的操作进行网络请求 [manager POST:url parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; multipart/form-data格式的POST请求这种格式主要针对上传文件的操作， 请求头和请求体的格式是比较特殊的首先：content-Type的值必须是multipart/form-data同时\b：同时还需要规定一个内容分割符来分割请求体重多个POST的内容 请求头中信息中：Content-Type:multipart/form-data ;boundary=xxxx 请求体中的信息： POST /upload HTTP/1.1 Host: xxxxx.xxxx.com Content-Type:multipart/form-data ;boundary=xxxxxx Accept-Encoding: gzip, deflate Connection: keep-alive Date: 2017-10-19 18:11:53 +0800 Accept: */* User-Agent: GyennoMedical/4.0.0 (iPhone; iOS 11.0.3; Scale/3.00) Accept-Language: en-US Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJvcmdUeXBlIjoxLCJzdWIiOiIxMzgwMDEzODAwMyIsInVzZXJUeXBlIjoxLCJleHAiOjE1MDk1Mjk1MzYsInVzZXJJZCI6OTg2NTc5LCJvcmdJZCI6Mn0.CKxnt5f5uTRvUwuEybcN79RG-uf74pFbWwWbCFk8jJI Content-Length: 4556 --xxxxxxx Content-Disposition:form-data;name=&quot;meta&quot; xxxxxxxxx 对应的字段内容 --xxxxxxx Content-Disposition:form-data;name=&quot;fileupload&quot; filename=&quot;file1.jpeg&quot; Content-Type:image/jpeg XXXXXXXXXXXXXX //图片的数据 --xxxxxxx-- 先构建下核心代码： [manager POST:prefixUrlString parameters:@{@&quot;meta&quot;:str} constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { NSData *data = UIImageJPEGRepresentation(image, 0.01); [formData appendPartWithFileData:data name:@&quot;fileUpload&quot; fileName:@&quot;file1.jpeg&quot; mimeType:@&quot;image/jpeg&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { successBlock(responseDic); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; application/json\b格式的POST请求这种格式的操作下会将数据采用json的格式进行组合 这里需要注意的就是针对\b请求序列化操作的时候采用\b AFHTTPRequestSerializer *serializer = [AFJSONRequestSerializer serializer]; 这样就可以达到效果了。 POST /xxxxx/xxxxxx HTTP/1.1 Host: xxxxx.xxxxx.com Content-Type: application/json Accept-Encoding: gzip, deflate Connection: keep-alive Date: 2017-10-17 18:11:53 +0800 Accept: */* User-Agent: GyennoMedical/4.0.0 (iPhone; iOS 11.0.3; Scale/3.00) Accept-Language: en-US Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJvcmdUeXBlIjoxLCJzdWIiOiIxMzgwMDEzODAwMyIsInVzZXJUeXBlIjoxLCJleHAiOjE1MDk1Mjk1MzYsInVzZXJJZCI6OTg2NTc5LCJvcmdJZCI6Mn0.CKxnt5f5uTRvUwuEybcN79RG-uf74pFbWwWbCFk8jJI Content-Length: 108 {&quot;userId&quot;:&quot;xxxxxxx&quot;,&quot;pageNo&quot;:1,&quot;orgType&quot;:1,&quot;pageSize&quot;:5,&quot;orgId&quot;:2,&quot;userType&quot;:1,&quot;accountNumber&quot;:&quot;xxxxxxxxx&quot;} 总结 通过上面的代码中的展示，我们可以清楚AFHTTPSessionManager主要是 RequestSerializer 和 AFURLSessionManger中的两个部分来构建： serilizer 主要是通过获取的参数来进行URLReqest的构建 URLSessionManger 主要通过request来创建Task 并允许task 所以将在下一篇分析下RequestSerializer 里面的东西 其中重点讲放在POST的请求中","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"设计模式","slug":"design-model","date":"2018-05-03T09:38:58.000Z","updated":"2018-08-06T06:36:29.000Z","comments":true,"path":"2018/05/03/design-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-model/","excerpt":"摘要： \b日常的编程中我们经常能提到抽象，耦合，聚合，关联，依赖等一些专业词汇，那我们\b通过学习了解了其的词语解释后，我们怎么样能在代码中将它们的关系给表现出来。比如说给你一个UML的图，你能看清楚线条和箭头分别代表着什么吗？你能根据这个UML的图写出对应的代码吗？","text":"摘要： \b日常的编程中我们经常能提到抽象，耦合，聚合，关联，依赖等一些专业词汇，那我们\b通过学习了解了其的词语解释后，我们怎么样能在代码中将它们的关系给表现出来。比如说给你一个UML的图，你能看清楚线条和箭头分别代表着什么吗？你能根据这个UML的图写出对应的代码吗？ 设计模式概论设计模式是什么个人感觉设计模式就是一种比较成熟的，针对一些场景下所使用了代码整合的一种方案\b。它可以重用代码，可以更好的对代码的扩展，可以保证代码的可靠性。所以设计模式使得代码编制真正工程化，设计模式是软件工程的基石脉络。 总体来\b说，设计模式分为3大类 ，23种 1.创建型模式 工厂方法模式，抽象工厂模式，单例模式、建造者模式、原型模式 这些模式的最终结果都会产生一个对象，通过这些模式可以采用不同的方式来\b创建对象 2、结构型模式 适配器模式、装饰器模式、外观模式、桥接模式、组合模式、享元模式 3、行为模式 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 设计模式的六大原则1、开闭原则OCP 开闭原则就是说，对扩展\b开放，对修改关闭 。在程序需要扩展的时候，不能去修改原有的代码，这也是为了程序的扩展性更好，易于升级和维护。 2、里氏代换原则 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何的错误和异常，但是反过来就不成立。里氏代换的原则的表现就是：在程序中尽量使用基类列席来对对象进行定义，而在运行的时候回再确定其子类类型，用子类对象来替换父类 3、控制反转原则 IOC 针对接口编程，依赖于抽象而不依赖于具体 首先需要明白\b依赖在程序中的体现：只是一个参数的表示方式，而如果我们的依赖是一个具体的对象的话，这样就只能针对该具体的子类进行操作，如果依赖于一个接口或者说基类的话，这样就可以\b针对不同的对象做扩展了。 4、接口隔离原则 ISP 使用多个隔离的接口，比使用单个接口要好 5、\b迪米特法则 DP 一个实体应当尽量少于其他实体间发生相互作用，使系统功能模块相对独立 6、合成复用原则 尽量使用组合/聚合的方式，而不是使用继承 设计中的三个关键字1、抽象化 在众多事物中提取出共同的本质的特征，舍弃非本质的特征就是抽象化。抽象化的过程就是一个裁剪的过程，在抽象的时候同于不同取决于从什么角度上来进行抽象，抽象的角度也取决于分析问题的目的 2、实现化 将抽象的类给出具体的实现就是实现化 一个类的实例就是这个类的实例化，一个具体子类就是抽象超类的实例化 3、解耦 平时经常说的高内聚低耦合，那么什么是耦合？ 所谓耦合就是两个实体\b的行为的某种强关联。而将他们之间的强关联去掉就是解耦。解耦是指将抽象化和实现化之间的耦合解开，或者说将它们之间的强关联改成\b弱关联 所谓强关联，指的是 在编译的时期已经确定的，\b无法再运行时期动态改变的关联; 所谓弱关联就是 可以动态的确定并且在运行的时期动态的改变的关联 从这个\b定义来\b看，继承关系是强关联，聚合关系是\b弱关联。 开篇——读懂UML类图和时序图首先从一个实例开始通过下图我们将一一分析类之间的关系 车的类图结构为\\&lt;abstract>,表示车是一个抽象类; 它有两个继承类：小汽车和自行车； 它们之间的关系为\b实现关系，使用带空心箭头的虚线表示 小汽车和SUV之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示 小汽车和发动机之间属于组合关系，使用带\b实心箭头的实线表示 学生和班级之间属于聚合关系，使用带空心菱形箭头的实线表示 学生和身份证之间是关联关系，使用一根实线表示 学生上学需要自行车，与自行车是一种依赖关系，使用带箭头的虚线表示 类之间的关系泛化关系（generalization） 类的继承结构在UML中表示为：泛化，实现 继承关系表示is-a的关系 表示是的关系 在UML中用时一个空心实线箭头表示 表示（A继承自B） 在最终的代码中，泛化关系表现为继承非抽象， \b实现关系(realize) 实现关系用一条空心箭头的虚线表示 eg:”车”是一个抽象概念，在现实中无法直接用来定义对象，只有指明具体的子类才可以用来定义对象，比如\b下图中的’小汽车’和‘自行车’； 在最终代码中，实现关系表现为继承抽象类 主要是\b实现协议或者接口的操作 聚合关系(aggregation) 聚合关系用一条带空心菱形箭头直线表示，表示A聚合到B上，或者说B是由A组成的 聚合关系用于表示实体对象之间的关系，表示整体由部分构成 与组合关系不同的是，整体和部分不是强依赖，即使整体不存在了，部分仍然存在 在代码中主要体现是也是类中\b的一个实例变量或者属性，改实例变量在程序外面可以改变，而且其的创建和销毁\b不是由内部来实现的，只负责使用其中的属性和方法就可以了。 组合关系(composition) 组合关系用一条带实心菱形箭头直线表示:如下图表示 A组成B 或者B 由A组成 与聚合关系一样，组合关系表示整体由部分构成的语义 但是组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在 在代码中可以体现为：首先也是一个实体的变量，但是其具体的创建应该是由构造函数来实现的，也就是说其的生命周期来源于\b组合进入的对象进行创建 关联关系(association) 关联关系用一条直线表示 描述不同类的对象之间的结构关系，它是一种\b静态关系，通常与运行的状态无关，一般由常识因素决定；它一般用来定义对象之间静态的，天然的结构；所有关联关系是一种强关联的关系 关联关系默认不强调方向，表示对象件相互知道，如果特别强调方向，如下图表示A知道B,但B不知道A 在最终代码中，关联对象同时是以成员变量的形式实现 依赖关系(dependency) 依赖关系是一套带箭头的虚线表示的，如下图表示A依赖于B ,它描述的是一个对象在运行的时候会用到另一个对象的关系 与关联关系不同的是，他是一种临时性的关系，通常发生在运行期间产生，并且随着运行时的变化，依赖关系也可能发生改变 显然依赖也是有方向的，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生 在最终的代码中，依赖关系体现为类构造方法以及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方还是使用对方的方法和属性 讨论 上面我们讨论了\b类中存在的六种关系，其中也能够看出有些关系比较类似但其实仔细分析还是能看出其中的差异，为了更好的理解，我们可以将他们用来做比较 泛化和实现的对比 相同点：都是一种继承的关系 \b不同点：泛化是继承于非抽象类，而实现是继承于抽象类 关联和依赖的对比 相同点：都\b存在于\b对象中，提供对象所使用 不同点： 依赖是一种\b\b比较弱的关系，两个类都不会增加属性，其中一个类作为另一个类的参数或者返回值，或者某个方法的变量 ，而关联的话，其中被关联的对象会成为关联对象的一个属性\b \b从生命周期来分析，依赖关系仅仅在类的方法被调用的时候产生，伴随着方法的结束而结束。关联关系当类实例化的时候产生，当类销毁的时候关系结束，相比\b依赖，关联关系的生存期更长 一个以属性的方式存在，一个以参数的方式或者返回值的方式\b存在 聚合和组合的对比 相同点： 针对对象来说都是一个属性的使用，都是关联的一种具体的体现 不同点： 聚合关系的类具有不同的生命周期，组合关系的类具有相同的生命\b周期（一个传递的是实例化对象，一个是构造一个实例对象） 信息封装性不同在聚合关系中，客户端可以同时了解两个类，他们是\b独立的在组合关系中，客户端只需要了解一个类就可以了，因为另一个类是被隐藏了 小结依赖，关联，聚合，组合，泛化代表\b类与类之间耦合的程度依次增加。依赖关系实际上是一种比较弱的关系，聚合是一种比较强的关联，组合是一种更强的关联，泛化是一种最强的关系 依赖关系比较好区分，它是一种耦合度最弱的一种，在编码中表现为类成员函数的局部变量，形参，返回值对静态方法的调用 关联、聚合、组合在编码形式上都以类成员变量的形式来表示。所以有时候很难判断出具体是哪个一个关系。 关联表示类之间存在关系，不存在集体和个体，个体与组成部分之间的关系；聚合表示类之间存在集体与个体的关系组合表示个体与组成部分之间的关系 时序图 对象之间交互的图，这些对象是按时间顺序排列的，时序图中显示的是参与交互对象以及对象之间消息交互的顺序 时序图包括对象主要有：对象（actor）生命线（Lifeline）控制焦点（Focus of control）消息（Message）等待 感谢Java设计模式1：设计模式概论 看懂UML类图和时序图","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"AFNetworking-AFURLSessionManager详解","slug":"iOS-AFNetworking-AFURLSessionManager","date":"2018-05-03T07:45:33.000Z","updated":"2018-05-08T06:29:42.000Z","comments":true,"path":"2018/05/03/iOS-AFNetworking-AFURLSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/03/iOS-AFNetworking-AFURLSessionManager/","excerpt":"摘要： 关于\biOS中的网络请求，在上一篇文章中已经大体了解了在网络请求的过程中的一些主要点，比如说一个NSURLRequest,一个NSURLSession，一个Task 等等,在我们的实际项目中我较多使用的是AFNetworking来作为我的网络请求模块，然后再对其进行封装下。个人认为对于第三进行封装是很有必要的，要不然当你切换一个\b新的第三方的时候，你需要在你的工程中找呀找，改呀该。","text":"摘要： 关于\biOS中的网络请求，在上一篇文章中已经大体了解了在网络请求的过程中的一些主要点，比如说一个NSURLRequest,一个NSURLSession，一个Task 等等,在我们的实际项目中我较多使用的是AFNetworking来作为我的网络请求模块，然后再对其进行封装下。个人认为对于第三进行封装是很有必要的，要不然当你切换一个\b新的第三方的时候，你需要在你的工程中找呀找，改呀该。 上面废话有点多了 今天我会通过源代码给大家分享下，AFNetworking的核心，AFURLSessionManager ,其实如果对于NSURLSession比较了解的话，相信用该很请求这个Manager的主体核心的功能就是通过session来创建task ,然后利用代理来做请求的反馈的过程。ok 接下来让我们先了解下吧！ 方法和属性属性//manager的会话 很熟悉吧！ @property (readonly, nonatomic, strong) NSURLSession *session; // 代理调用中用到的操作队列 @property (readonly ,nonatomic ,strong) NSOperationQueue *operationQueue; //接收信息的序列化 @property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer; // 会话的安全策略 @property (nonatomic, strong) AFSecurityPolicy *securityPolicy; /** The data, upload, and download tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks; /** The data tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks; /** The upload tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks; /** The download tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks; // 针对completionBlock的一个队列 如果为null的haul 使用main queue @property (nonatomic, strong, nullable) dispatch_queue_t completionQueue; // 针对\b组请求操作 completionBlock 的操作 @property (nonatomic, strong, nullable) dispatch_group_t completionGroup; //如果后台会话中创建上传任务失败的话 会继续创建 @property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions; 方法 初始化 // 一个配置项就可以初始化一个Manager - (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration{ self = [super init]; if (!self) { return nil; } // 如果有用户没有手动指定的话，就默认使用configuration来初始化 if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } // 赋值给属性 self.sessionConfiguration = configuration; // 初始化NSURLSession的task代理方法执行的队列 // 这里有一个关键的点就是task的代理执行的queue一次只能执行一个task 队列是串行队列 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; // 初始化NSURLSession 对象 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 如果用户没有手动指定的话，默认返回的数据是JSON格式序列化 self.responseSerializer = [AFJSONResponseSerializer serializer]; // 指定https处理的安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH // 初始化网络状态监听属性 self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif // 用于处理task和Delegate代理对象一一对应的关系 这个很关键 self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; // 初始化一个锁对象，关键操作加锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取当前session正在执行的的所有task.同时为每一个Task添加‘Delegate’代理对象 这个代理对象主要用于管理uploadTask和downLoadTask的进度管理，并且在Task执行完毕后调用相对应的Block 同时发送Notification对象，实现Task数据或者状态改变的检测 **/ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self; } 任务的创建： //创建一个dataTask 通过特殊的request - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 创建一个dataTask 并由uploadprogress 和downloadProgress的回调操作 - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过request和 一个文件的路径来创建一个uploadTask - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过一个bodyData和request来创建一个uploadTask - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过一个特殊的请求来创建\bdownLoadTask - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler; // 创建一个断点下载的downloadTask - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler; 其他： // 是否是会话无效 通过取消任务 一个是立即取消 一个是等任务完成后再取消 - (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks{ dispatch_async(dispatch_get_main_queue(), ^{ if (cancelPendingTasks) { //这个就是会话的方法啦 [self.session invalidateAndCancel]; } else { [self.session finishTasksAndInvalidate]; } }); } 各种回调的block: - (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block; - (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block; - (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block; - (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block; - (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block; - (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block; - (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block; - (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block; - (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block; - (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block; - (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block; - (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block; - (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block; - (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block; - (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block; 一看就已经很明白啦！都是针对代理的block 使用流程AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; \bNSURLSessionDataTask *task = [manager dataTaskWithRequest:reques completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) { if (error) { // successBlock(()) }else{ } }]; [task resume]; 下面我们来分析下dataTask创建中的代码： - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { __block NSURLSessionDataTask *dataTask = nil; // 这里是一个同步的操作,当然它的方法也是简单的session场景dataTask的方法 url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); // 给task添加代理 并将uploadProgressBlock 和 download\bProgressBlock 还有 completionHanler 也交给代理进行管理 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } 下面让我们来分析 addDelegateForDataTask 当中的操作这里的主要操作是为Task设置一个代理对象，从而可以实现对进度处理，Block调用、Task完成返回数据的拼装的功能 - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler { // 这里创建一个代理的对象 delegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; // 赋值delegate的manager delegate.manager = self; // 赋值deleget的completionHandler 这个是针对Task的处理的回调 delegate.completionHandler = completionHandler; //添加任务的描述 \b dataTask.taskDescription = self.taskDescriptionForSessionTasks; // 为task 添加代理 [self setDelegate:delegate forTask:dataTask]; //还有uploadblock 和 downloadblock delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock; } // Delegate 设置Task 状态改变的监听 主要是task的挂起或者重启的监听 - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task { NSParameterAssert(task); NSParameterAssert(delegate); // 这里需要用到加锁的处理 [self.lock lock]; // 为task设置与之代理方法关联关系。通过一个字典,便于后续通过task 来进行查找delegate 然后滴啊用deleget的对应的方法来进行操作 self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 添加Task开始，重启，挂起状态的通知的接收 便于控制uploadProgress和downloadProgerss [delegate setupProgressForTask:task]; [self addNotificationObserverForTask:task]; [self.lock unlock]; } 下面来分析下 AFURLSessionManagerTaskDelegate 创建： /* 初始化AFURLSessionManagerTaskDelegate */ - (instancetype)init { self = [super init]; if (!self) { return nil; } // 这个属性用于存储Task下载过程中的数据 self.mutableData = [NSMutableData data]; // 存储Task上传和下载的进度 self.uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; self.uploadProgress.totalUnitCount = NSURLSessionTransferSizeUnknown; self.downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; self.downloadProgress.totalUnitCount = NSURLSessionTransferSizeUnknown; return self; } - (void)setupProgressForTask:(NSURLSessionTask *)task { __weak __typeof__(task) weakTask = task; self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive; [self.uploadProgress setCancellable:YES]; // 当process对象取消的时候，取消task [self.uploadProgress setCancellationHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask cancel]; }]; // 当process暂停的时候，暂停task [self.uploadProgress setPausable:YES]; [self.uploadProgress setPausingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask suspend]; }]; // 重启Task if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) { [self.uploadProgress setResumingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask resume]; }]; } // 针对取消progress的操作也是一样的 [self.downloadProgress setCancellable:YES]; [self.downloadProgress setCancellationHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask cancel]; }]; [self.downloadProgress setPausable:YES]; [self.downloadProgress setPausingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask suspend]; }]; if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) { [self.downloadProgress setResumingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask resume]; }]; } // kvo的操作 会调用 observeValueForKeyPath 的函数的操作 对NSURLSessionTask 的属性进行观察操作 //数据的接收，主要针对downloadTask [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive)) options:NSKeyValueObservingOptionNew context:NULL]; //数据的上传，主要针对uploadTask [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend)) options:NSKeyValueObservingOptionNew context:NULL]; // 为progress 添加kvo 针对 fractiongCompleted [self.downloadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; [self.uploadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; } 这里是针对上面kvo的操作 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context { if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) { self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) { self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) { self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) { self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } } else if ([object isEqual:self.downloadProgress]) { // 更新下载的进度的BLock if (self.downloadProgressBlock) { self.downloadProgressBlock(object); } } else if ([object isEqual:self.uploadProgress]) { // 更新上传进度的Block if (self.uploadProgressBlock) { self.uploadProgressBlock(object); } } } ok,这些前期的工作做完以后，我们就可以开始代理的工作了： 这里的代理主要实现了几个方法： \b当任务完成以后： #pragma mark - NSURLSessionTaskDelegate // 当task完成以后，会调用delegate对象的方法对返回的数据进行封装 - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; // 获取Task对应的Manager对象 __strong AFURLSessionManager *manager = self.manager; // 要封装的responseObject对象 __block id responseObject = nil; // __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //返回的数据 //Performance Improvement from #2672 NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } //如果是downloadTask 就封装downloadFileUrl if (self.downloadFileURL) { userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; } else if (data) { userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; } // 针对请求错误的封装 if (error) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ // 如果task有completionHandler 就调用这个Block if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } // 发送一个指定task结束的通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); } else {//正确数据的封装 dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; // 返回数据的封装 responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; if (self.downloadFileURL) { responseObject = self.downloadFileURL; } if (responseObject) { userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; } if (serializationError) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; } // 如果Task有完成的Blokc，则调用这个Block dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } // 发送Task完成的通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } #pragma clang diagnostic pop } NSURLSessionDataTaskDelegate \b代理的操作 #pragma mark - NSURLSessionDataTaskDelegate - (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { // 这里主要做的是数据的拼接 [self.mutableData appendData:data]; } NSURLSessionDownloadTaskDelegate 代理操作： #pragma mark - NSURLSessionDownloadTaskDelegate - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { NSError *fileManagerError = nil; self.downloadFileURL = nil; // 这里的location是缓存的url的地址 if (self.downloadTaskDidFinishDownloading) { // 将获取文件的存放路径 然后将location的地址放入到存放的地址中进行文件的保存操作 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (self.downloadFileURL) { // 这里是存放的操作 [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]; if (fileManagerError) { [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; } } } } 这里是一个下载的例子，可以好好参考下： NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress *downloadProgress){ NSLog(@&quot;下载进度:%lld&quot;,downloadProgress.completedUnitCount); } destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) { NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; NSURL *fileURL = [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]]; NSLog(@&quot;fileURL:%@&quot;,[fileURL absoluteString]); return fileURL; } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) { self.imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:filePath]]; NSLog(@&quot;File downloaded to: %@&quot;, filePath); }]; 其中有一个destination的block的操作： - (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler { // 根据指定的Task，初始化一个AFURLSessionManagerTaskDelegate 其实这里采用的是MVP模式 AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; delegate.manager = self; // 设置task完成的回调你的BLOCK delegate.completionHandler = completionHandler; if (destination) { // 任务完成以后，调用destination 这个Block delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) { return destination(location, task.response); }; } // 指定Task与taskDescriptionForSessionTasks的关联，方便后面的通知中做出对应的处理 downloadTask.taskDescription = self.taskDescriptionForSessionTasks; // 添加通知 [self setDelegate:delegate forTask:downloadTask]; // 设置一个下载进度的block,以便在后面代理中调用 delegate.downloadProgressBlock = downloadProgressBlock; } 后面有一个destination的操作，我们做的事情就是给它找一个合适的地方来进行存放，然后在completion中主要做的就是将文件的地址给我们的应用就可以了 代理完成任务以后，我们要做什么？ - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 当我们的task完成任务以后： AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) { [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; } if (self.taskDidComplete) { self.taskDidComplete(session, task, error); } } // 当移除Task对应的通知和对应的AFURLSessionManagerTaskDelegate代理对象 - (void)removeDelegateForTask:(NSURLSessionTask *)task { NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; // 移除task对应的kvo [delegate cleanUpProgressForTask:task]; // 移除Task对应的delegate对象 [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock]; } 代理的清除操作： - (void)cleanUpProgressForTask:(NSURLSessionTask *)task { [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]; [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; } 其中的MVP 在AFURLSessionManager中我们可以看到，这里针对每个task 都会有一个addDelegateForTask的方法，这里的针对每一个task 都创建一个AFURLSessionTaskDelegate 的代理，这个代理就是MVP中的Present 它处理View中的一些操作，然后将处理好的操作的数据，同时P中\b对于Manager使用的是Weak的操作 一个弱引用而不是强引用 特殊模块说明AFURLSessionManager 实现了 NSSecureCoding 协议 让Manager可以归档和解档的操作 使用dispatch_semaphore_t信号量来控制对异步处理返回的结果控制// 用dispatch_semaphore_t 来控制对异步处理返回的结果的控制 - (NSArray *)tasksForKeyPath:(NSString *)keyPath { //获取session对应的task列表，通过disptch_semaphore_t来控制访问过程 __block NSArray *tasks = nil; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) { tasks = dataTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) { tasks = uploadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) { tasks = downloadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) { tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;]; } dispatch_semaphore_signal(semaphore); }]; // 这里会一直等待信号量变为1 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 返回Task. 通过信号量控制，避免了方法结束的时候，tasks还没有正常获取的情况 return tasks; } 总结ok,在这里已经将AFURLSessionManager的主要的实现都已经涉及到了。下面来","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"iOS NSURLSession 解析","slug":"NSURLSESSION-Detail","date":"2018-04-24T09:04:38.000Z","updated":"2018-05-03T07:40:45.000Z","comments":true,"path":"2018/04/24/NSURLSESSION-Detail/","link":"","permalink":"http://yoursite.com/2018/04/24/NSURLSESSION-Detail/","excerpt":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。","text":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。 一个简单的例子这里构建一个简单的请求的例子 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:smallPic]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc]init]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request]; [dataTask resume]; 从上的代码中我们可以大体的分析下，一个网络请求的过程中，我们分别需要的角色： NSURLRequest ：一个网络请求 NSURLSession ： 一个会话 NSURLSessionConfiguration ： 会话的配置项 NSURLSessionDataTask : 会话中的任务 一个会话需要会话的配置信息来进行创建，其中还存在着线程队列已经代理的设置一个任务是会话通过请求的信息来进行创建，创建出来的任务只有执行resume后才开始执行任务 下面我们将通过对这个所需的元素进行一一分析，来进一步的了解他们之间的关系，已经各个元素的一些属性和方法。 首先针对AFNetworking的扩展，其实它的核心也是一个最基础的网络请求操作，后续再对这个简单的操作进行扩展，这样就会慢慢的可以通过用户添加一些block来对函数进行一些自定义的一些操作，这些都是后话。后期的话，我会针对AFNetworking进行源码解析，同时也希望自己能够写出实现自己的网络框架。 NSURLRequest在iOS中关于请求的操作，其基类都是NSURLReqeust 当然还有一个可变的NSMutableURLReqeust当然对于可变和不可变的特性相对大家都已经比较理解了。下面我们来创建一个最基础的reqeust [[NSURLRequest alloc] initWithURL:@&quot;url&quot;]; 最简单的组成就是一个url来创建，当然它还有一些特性，这些特性针对URLReqeust更多的是可读的属性但是对可变的URLRequest则是可读可写的 创建实例对象：类方法： //通过url来进行创建 +(instancetype)requestWithURL:(NSURL*)URL; // 通过url 以及缓存策略 还有网络超时时长来进行创建 +(instancetype)requestWithURL:(NSURL*)URL cacehPolicy:(NSURLRequestCachePolicy)cachePolicy timeooutInterval:(NSTimeInterval)timeoutInterval; 实例方法： - (instancetype)initWithURL:(NSURL *)URL; // 通过实例方法创建 - (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval NS_DESIGNATED_INITIALIZER; 属性：@property (nullable, readonly, copy) NSURL *URL;// url @property (readonly) NSURLRequestCachePolicy cachePolicy;//缓存策略 @property (readonly) NSTimeInterval timeoutInterval;//网络请求超时时间 @property (nullable, readonly, copy) NSString *HTTPMethod;//请求的方法 有get post delete put 等等 @property (nullable, readonly, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields; //请求头中的字段所存放的字典 针对这字段有提供专门的方法来实现添加和查询的工作： - (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;//根据字段名字查找对应的信息 - (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//这是直接设置对应的信息 - (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//这里是添加对应的信息 @property (nullable, copy) NSData *HTTPBody;//请求中的数据信息 也就是请求体重的信息 这些是主要用到的信息，如果后期还有的话，会慢慢添加的。 其实很多对网络特别是HTTP协议不是很理解的人，可能看得有点晕，没关系，这里我们贴下http的请求给大家看看就会便于理解了 GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 上面的代码中我们可以知道关于Request中的一些信息： url:img.mukewang.com/562f25980001b1b106000338.jpg HTTPMethod:GET 接下来就是请求头的一些字段： Accept : 表示客户端接受的一些格式 Accept-Encoding：接受的压缩格式 Accept-Language：接受的语言 NSURLSessionConfiguration关于会话的配置有三种模式： //默认模式 @property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration; // 临时会话模式 @property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration; //后台模式 + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0)); 属性// 一个后台会话的标识符 @property (nullable, readonly, copy) NSString *identifier; // 请求缓存策略 @property NSURLRequestCachePolicy requestCachePolicy; // 网络请求超时时长 @property NSTimeInterval timeoutIntervalForRequest; // 网络资源请求操作 @property NSTimeInterval timeoutIntervalForResource; // 网络请求服务类型 @property NSURLRequestNetworkServiceType networkServiceType; // 是否允许用蜂窝 @property BOOL allowsCellularAccess; // 添加额外的请求头 @property (nullable, copy) NSDictionary *HTTPAdditionalHeaders; NSURLSession 这个类是关于会话的创建，会话的使用，会话的调度等等 下面通过源代码来对这个类进一步了解： 创建// 通过会话配置来进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过会话配置 还有代理 已经多线程队列进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue; 生成不同的TaskdataTask/* Creates a data task with the given request. The request may have a body stream. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request; /* Creates a data task to retrieve the contents of the given URL. */ - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url; uploadTask/* Creates an upload task with the given request. The body of the request will be created from the file referenced by fileURL */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL; /* Creates an upload task with the given request. The body of the request is provided from the bodyData. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData; /* Creates an upload task with the given request. The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */ - (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request; downTask/* Creates a download task with the given request. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request; /* Creates a download task to download the contents of the given URL. */ - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url; /* Creates a download task with the resume data. If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */ - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData; 直接带返回回调的task/* * data task convenience methods. These methods create tasks that * bypass the normal delegate calls for response and data delivery, * and provide a simple cancelable asynchronous interface to receiving * data. Errors will be returned in the NSURLErrorDomain, * see &lt;Foundation/NSURLError.h&gt;. The delegate, if any, will still be * called for authentication challenges. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * upload convenience method. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * download task convenience methods. When a download successfully * completes, the NSURL will point to a file that must be read or * copied during the invocation of the completion routine. The file * will be removed automatically. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; 属性和方法属性：@property (readonly ,retain) NSOperationQueue *delegateQueue; @property (nullable,readonly,retain) id &lt;NSURLSessionDelegate&gt; delegate; @property (readonly ,copy) NSURLSessionConfiguration *configuration; //会话的描述 @property (nullable,copy) NSString *sessionDescription; 方法：//完成所有任务后，将会话无效 // returns immediately and existing tasks will be allowed to run to completion. New tasks may not be Created。The Session will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError: has been issued; -(void)finishTasksAndInvalidate; // 会话无效后取消操作 // issues cancel to all outstanding tasks for this session. -(void)invalidateAndCancel; //invoke completionHandler with outstanding data,upload and download tasks -(void)getTasksWithCompletionHandler:(void(^)(NSArray&lt;NSURLNSURLSessionDataTask*&gt;* dataTask,NSArray&lt;NSURLSessionUploadTask*&gt;* uploadTasks,NSArray&lt;NSURLSessionDownloadTask*&gt;*downloadTask))complcompletionHandler; 代理NSURLSessionDelegate// 这是会话接收最后一条消息 当会话遇到系统级的错误 获取当会话无效的时候 -(void)URLSession:(NSUrlSession*)session didBecomeInvalidWithError:(nullable NSError *)error; //当遇到需要用户权限验证的时候，或者HTTPS验证的时候会调用这个代理 -(void)URLSession:(NSURLSession*)session didReceiveChallenge:(NSURLAuthenticationChallenge*)challenge completionHandler:(void(^)(NSURLSessionAuthChallengeDispostion disposition NSURLCredential * _Nullable credential))completionHandler; //当applicaton 接收到application handleEvnetsForBackgroundURLSession:completionHandler 的消息的时候 // 会话的代理会接受到这个消息来 处理后台消息 -(void)URLSessionDidFinisheEventsForBackgroundURLSession:(NSURLSession*)session; NSURLSessionTaskDelegate// 网络请求重定向的时候 执行的操作 我们必须设置一个新的Request 然后传入到comoletionHandler中的request中 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler; // task接受到一个用户认证的请求，如果这个代理没有被实现的话，会话的认证将不会被调用 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler; // 如果task的请求需要一个新的bodyStream的时候会调用 当认证请求失败时候，我们可以通过这个代理重新弄个bodyStream来实现 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream * _Nullable bodyStream))completionHandler; // 当上传数据的时候，会调用这个代理 主要是针对upload的请求的时候，可以获取到上传的进度 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend; // 当一个任务完成后，无论失败或者成功都会调用这个代理 如果成功的话 error 为nil - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error; NSURLSessionDataTaskDelegate//当一个task接受到返回的消息，当所有的信息都接受完毕后completionHanler会被调用。我们可以在这里取消一个请求或者将一个data的任务改为下载的task.如果你没有实现这个dialing，我们可以通过task的response属性获取对应的数据 后台模式中uploadtask不会调用给这个代理 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler; // 一个dataTask 变为downloadTask - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask; //当datatask可以用的时候，我们可以在这里获取data的数据 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data; // 缓存completionHandler缓存data 或者传入nil 不需要缓存 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler; NSURLSessionDownloadTaskDelegate// 当一个\bdownloadTask 任务完成后我们可以通过给的location 的路径值来保存文件或者移动文件 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location; // 获取下载的进度 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite; // 断点下载的操作 NSURLSessionDownloadTaskResumeData 这个字段里会告诉你 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;","categories":[],"tags":[{"name":"iOS  NSURLSession","slug":"iOS-NSURLSession","permalink":"http://yoursite.com/tags/iOS-NSURLSession/"}]},{"title":"iOS性能优化总结","slug":"iOS-youhua-detail","date":"2018-04-17T09:33:47.000Z","updated":"2018-07-20T08:19:03.000Z","comments":true,"path":"2018/04/17/iOS-youhua-detail/","link":"","permalink":"http://yoursite.com/2018/04/17/iOS-youhua-detail/","excerpt":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。","text":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。 首先思考问题： 为什么要性能优化？ 性能优化主要是针对哪些方法的优化？ 发现问题 问题的发现目前主要还是依靠的是工具来进行发现。因为这样比较直观而且也有利于我们能够发现具体问题产生的地方，以便于我们队问题的解决。要不然我们都知道有问题，但是问题具体原因在哪里查不出来的话，这样的意义就小多了。当然最主要的还是用户体验方面能够感受到性能的问题，如果存在卡顿，或者闪退什么的，这样的体验就low了。所以问题一个是来自于用户的反馈还有就是测试人员或者开发人员一些体验的感受。 好了废话不多说：直接上工具 MLeakFinder 内存检测工具FPS性能检测工具 内存检测 内存分为内存泄露和内存开销 FPS监控 解决问题优化业务流程合理的线程分配预处理和延时加载缓存正确API的使用预防问题","categories":[],"tags":[{"name":"iOS 优化","slug":"iOS-优化","permalink":"http://yoursite.com/tags/iOS-优化/"}]},{"title":"iOS RunLoop 深入理解","slug":"iOS-RunLoop-detail","date":"2018-04-09T10:23:53.000Z","updated":"2018-08-07T02:30:48.000Z","comments":true,"path":"2018/04/09/iOS-RunLoop-detail/","link":"","permalink":"http://yoursite.com/2018/04/09/iOS-RunLoop-detail/","excerpt":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关","text":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关 RunLoop 概念正常情况下一个线程只能执行一个任务，当任务完成了，线程也就退出了。那么如何才能确保我们的线程能够随时能够处理事件并且不退出，直到我们主动要求线程退出的时候就退出？ 答案是有的，这就是我们今天的主角：RunLoop 从字面意思上解析这是一个运行着的循环，我们大体实现下它的伪代码：1234567function loop()&#123; initialize(); do&#123; var message = getMessage(); processMessage(message); &#125;while&#123;message != quit&#125;&#125; 从伪代码中我们可以大体的了解到其中的一些逻辑处理 RunLoop 的关键点在于：如何管理事件、消息，如何让线程在没有处理消息的时候休眠以避免资源的占用、在有消息的时候到来的时候能够能立即唤醒。 \b所以，RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行\bEvent Loop的逻辑。 线程执行了这个函数后，就会一直处于这个函数的内部“接受消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束，函数返回。 首先由一个入口函数的操作，在这里采用do…while的操作，首先先从消息队列中获取消息，当然如果没有消息的话，这个循环也是会一直发生的，因为我们还没有发送quit的消息。同时在我们有一个消息到来的时候，我们可以获取对应的消息来做处理。 总而言之就是一个一直运行着的事件循环操作 iOS中的RunLoop在 iOS 中为我们提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef CFRunLoopRef 是在CoreFoundation 框架中的，提供了纯C函数的API,所有的API都是线程安全的 NSRunLoop 是基于CFRunLoopRef 的封装，提供了面向对象的API,但是这些API是线程不安全的 下面我们从源码中来分析RunLoop: 1234567void CFRunLoopRun(void)&#123; int32_t result; do&#123; result = CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125;while(kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result)&#125; 下面再来分析下 CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 首先回去CurrentMode CFRunLoopModeRef CurrentMode = __CFRunLoopFindMode(r1,modelName,false); 然后对currentMode进行判断 判断其是否存在或者是否为空 if(currentMode == NULL || __CFRunLoopModelIsEmpty)&#123; return finish;//返回完成 就退出了runloop &#125; 这里就是RunLoop结束的一个很重要的因素下面我们在看看其中最重要的部分： if(currentMode-&gt;observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopEntry); result = __CFRunLoopRun(r1,currentMode,seconds,returnAfterSourceHandled,previousMode); if(currentMode-&gt;observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopExit);下面借鉴网上的博客资源分析下：（采用伪代码）[参照](http://www.cnblogs.com/kenshincui/p/6823841.html)~~~ objc int32_t __CFRunLoopRun()&#123; //通知即将进入runloop __CFRunLoopDoObservers(kCFRunLoopEntry); do&#123; //通知将要处理timer和source __CFRunLoopDoObservers(kcfrunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); //处理非延迟的主线程调用 __CFRunLoopDoBlocks(); //处理source0事件 __CFRunLoopDoSource0(); if(sourceHandledThisRoop)&#123; __CFRunLoopDoBlocks(); &#125; //如果有Source1 (基于Port) 处于ready状态，直接处理这个Source1 然后跳转去处理消息 if(__Source0DidDispatchProtLastTime)&#123; Boolean hasMsg = __CFRunLoopServiceMachPort(); if(hasMsg)&#123; goto handle_msg; &#125; &#125; //通知 Observers 线程即将进入休眠 if(!sourceHandledThisRoop)&#123; __CFRunLoopDoObservers(runloop,currentMode,KCFrunLoopBeforeWaiting); &#125; //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); //即将进入休眠 __CFRunLoopDoObservers(KCFrunLoopBeforeWaiting); //等待内核mach_msg事件 mach_port_t weakUpPort = RunLoop 和线程的关系苹果不允许直接创建 RunLoop ,它值提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunloopGetCurrent(). 这两个函数内部的逻辑大概是下面这样的： 12345678910111213141516171819202122232425262728293031323334353637// 一个全局的Dictionary key是pthread_t ,value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;// 访问 loopsDic \b时候的锁static CFSpinLock_t loopsLock;CFRunLoopRef _CFRunloopGet(pthread_t thread)&#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入的时候，初始化全局的DIC ,并先给主线程创建一个RunLoop loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunloopCreate(); CFDictionarySetValue(loopsDic,pthread_main_thread_np(),mainLoop); &#125; // 直接从 Dictionary 中获取 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic,thread); if (!loop) &#123; // 如果取不到loop 就创建一个 loop = _CFRunloopCreate(); CFDictionarySetValue(loopsDic,thread,loop); // 注册一个回调，当现场销毁的时候，顺便也销毁其对应的RunLoop _CFSetTSD(...,thread,loop,__CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125;CFRunLoopRef CFRunLoopGetMain()&#123; return _CFRunloopGet(pthread_main_thread_np);&#125;CFRunLoopRef CFRunloopGetCurrent()&#123; return _CFRunloopGet(pthread_self);&#125; 从上面的代码可以看出，线程和RunLoop 之间是一一对应的，其关系是保存在一个全局的Dictionary 中，线程刚开始的时候并没有创建RunLoop ，如果你不主动获取，那么就一直不会有。RunLoop 的创建是发生在第一次获取的时候，RunLoop的销毁是在线程结束的时候。你只能在一个线程内部获取到他的RunLoop（主线程除外） RunLoop 对外接口在CoreFoundation 里关于RunLoop的有5个类123456CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef 一个RunLoop中包含若干个Mode ,每个Mode又包含若干个Source/Timer/Observer 。每次调用RunLoop 的主函数的时候，只能指定其中一个Mode,这个Mode被称为CurrentMode. 如果要切换这个Mode只能退出Loop，再重新指定一个新的Mode进入，这样做是为了分隔开不同组的Source/Timer/Observer，让其互不影响 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1 . Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用的时候，需要先调用CFRunLoopSourceSignal(source) ,将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop ，让其处理这个事件。 Source1 包含了一个mach_port 和 一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种Source 能够主动唤醒RunLoop的线程 CFRunLoopTimerRef 是基于定时器的触发器，它和NSTimer 是toll-free bridged的可以混用。其包含一个时间长度和一个回调（函数指针） 。当其加入RunLoop的时候，会在RunLoop中注册对应的时间点，当时间点到了，RunLoop就会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个Observer 都包含了一个回调（函数指针），当RunLoop的状态发生变化的时候，观察者就能通过回调接收到这个变化，可以观测的时间点有以下几个： 123456789&gt; typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;&gt; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop&gt; kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer&gt; kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source&gt; kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠&gt; kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒&gt; kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&gt; &#125;;&gt; 上面的Source/Timer/Observer 被称为Mode item 一个Item 可以被同时加入到多个mode.但是一个item 被重复加入到同一个mode 是不会生效的。如果一个mode 里一个item都没有，则RunLoop 会直接退出，不进入循环。 RunLoop 的Model1234567891011121314struct __CFRunLoopMode&#123; CFStringRef _name; CFMutableSetRef _source0; CFMutableSetRef _source1; CFMutableArrayRef _observers; CFMutableArrayRef _timers;&#125;;struct __CFRunloop&#123; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes;&#125;; 这里有个概念叫“CommonModes” 一个Mode 可以将自己标记为“Common”属性，通过将其ModeName添加到RunLoop的commonModes中，每当RunLoop的内容发生变化的时候将RunLoop会自动将_commonModeItems里的Source/Observer/Timer同步到具有“Common”标记的所有Mode里 CFRunLoop对外提供了管理Mode的接口： 12CFRunLoopAddCommonMode(CFRunLoopRef runloop,CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName,...); Mode暴露的管理Mode item的接口 有下面几个： 1234567891011CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode); 你只能通过\bmode name 来操作内部的 mode,当你传入一个新的mode name但是RunLoop 内部没有对应的mode的时候，RunLoop 会自动帮你创建对用的CFRunLoopModeRef .对于一个RunLoop 来说，其内部的mode 只能增加不能删除 RunLoop 的Source首先先看下官方的RunLoop结构图： 结合RunLoop的核心运行流程可以看出Soucre0(复杂APP内部事件，又APP负责管理出发，例如：UITouch事件)和Timer(又叫Timer Source 基于事件的出发器，上层对应NSTImer)是两个不同的RunLoop事件源。runloop 被这些事件唤醒后，就会处理并调用事件处理方法（CFRunLoopTimerRef 的回调）\u001c ，但是对于RunLoopSoureRef 除了Source0之外还有另一个版本就是Source1 ,Source1 除了包含回调指针外还包含了一个mach port 和Source0 需要手动触发不同，Source1可以监听系统端口和其他线程相互发送消息，它还能够主动唤醒RunLoop RunLoop 的内部逻辑根据苹果文档的说明，RunLoop 内部的逻辑大致如下： 内部代码整理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void CFRunLoopRun(void)&#123; CFRunLoopRunSpecific(CFRunloopGetCurrent(),kCFRunLoopDefaultMode,1.0e10,false);&#125;// 用指定的Mode启动 ，允许设置RunLoop 的超时时间int CFRunLoopRunInMode(CFStringRef modeName,CFTimeInterval seconds,Boolean stopAfterHandle)&#123; return CFRunLoopRunSpecific(CFRunloopGetCurrent(),modeName,seconds,stopAfterHandle);&#125;// RunLoop 的实现int CFRunLoopRunSpecific(runloop,modeName,seconds,stopAfterHandle)&#123; //首先通过mode name 获取mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop,modeName,false);// 如果当前的mode是\b空的，直接退出 if (__CFRunLoopModelIsEmpty(currentMode)) &#123; return; &#125;// 1.通知 Observer： RunLoop 即将进入 loop __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopEntry);// 内部函数 ，进入Loop __CFRunLoopRun(runloop,currentMode,seconds,returnAfterSourceHandled)&#123; Boolean sourceHandledThisRoop = NO; int retVal = 0; do &#123; // 2. 通知Observer : RunLoop 即将触发Timer的回调 __CFRUnLoopDoObservers(RunLoop,currentMode,kCFRunLoopBeforeTimers); // 3. 通知 \bObservers ； RunLoop 即将触发Source0的回调 __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopBeforeSources); // 执行被加入的Block __CFRunLoopDoBlocks(runloop,currentMode); // 4.RunLoop 触发 Source 0的回调 sourceHandledThisRoop = __CFRunLoopDoSource0(runloop,currentMode,stopAfterHandle); // 执行被加入的block __CFRunLoopDoBlocks(runloop , currentMode); // 如果有Source1处于ready的状态，直接处理这个Source1 ,然后调转到处理消息 if (__Source0DidDispatchProtLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort,&amp;msg); 8 &#125; // 通知Observer RunLoop 即将进入休眠 if (!sourceHandledThisRoop) &#123; __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopBeforeWaiting); &#125; // 调用 mach_msg 等待接收mach_port的消息，线程即将入休眠，直到下面某一个时间唤醒 // 一个基于port 的Source 的事件 // 一个Timer到时间了 // RunLoop 自身的超时时间到了 // 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet,&amp;msg,sizeof(msg_buffer),&amp;livePort)&#123; mach_msg(msg,MACH_RCV_MSG,port); &#125; // 通知 Observers: RunLoop 的线程刚刚被唤醒了 __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopAfterWaiting); // 9 收到消息，处理消息 handle_msg; // 9.1 如果消息是一个Timer ，触发这个timer的回调 if (msg_is_timer) &#123; __CFRUNLoopDoTomers(runloop,currentMode,mach_absoult_time()); &#125; // 9.2 如果有dispatch 到 main_queue 的block ,执行block else if (msg_is_dispatch)&#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; // 9.3 如果一个Source1 (基于port)发出的事件了，处理这个事件。 else&#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceFor马车Port（runloop,currentMode,liveport）; sourceHandledThisRoop = __CFRunLoopDoSource1(runloop , currentMode,source1,msg); if (sourceHandledThisRoop) &#123; mach_msg(reply , MACH_SEND_MSG,reply); &#125; &#125; // 执行加入到Loop 的block __CFRunLoopDoBlocks(runloop , currentMode); if (sourceHandledThisRoop &amp;&amp; stopAfterHandle) &#123; // 进入loop的时候参数说处理完事件就返回 retVal = KCFRunLoopHandledSource; &#125;else if(timeout)&#123; // 超出传入参数标记的\b超时时间 retVal = KCFRunLoopRunTimedOut; &#125;else if(__CFRunLoopIsStopped(runloop))&#123; // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125;else if(__CFRunLoopModelIsEmpty(runloop ,currentMode))&#123; // source、timer/observer 一个都没有 retVal = kCFRunLoopRunFinished; &#125; // 如果没有超时，mode没有为空 loop也没有停止 那就继续loop &#125;while&#123;retVal == 0&#125;; &#125; // 通知Observer RunLoop 即将退出 __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopExit);&#125; 通过上图和\b代码的说明我们可以比较清楚的了解runloop内部的流程操作， 这里的Observer 有几种状态： \b12345678910typedef CF_OPTIONS(CFOptionFlags,CFRunLoopActivity)&#123; kCFRunLoopEntry ,即将进入loop kCFRunLoopBeforeTimers 即将处理Timer kCFRunLoopBeforeSources 即将处理source0 kCFRunLoopBeforeWaiting 即将进入休眠 kCFRunLoopAfterWaiting \b刚从休眠中唤醒 kCFRunLoopExit 即将推出loop&#125; RunLoop 休眠其实对于RunLoop 最核心的地方是在于保障了在没有消息的时候休眠以避免占用系统的\b资源，有消息的时候能够及时唤醒处理消息。RunLoop 的这个机制完全依靠系统内核来完成的，具体来时候苹果系统核心组件Drawin中的mach 来完成的。 和其他架构不同的是Mach对象间不能直接调用，只能通过消息传递的方式来进行通信。“消息”是Mach中基础的概念，消息在两个端口之间传递，这就是Mach 的IPC 的核心 Mach 提供了进程间通信，处理器调度等基础服务，在Mach中，进程，线程间的通信以消息的方式来完成，消息在两个port之间进行传递（这也正是Source1之所以称为Port-based Source）的原因，因为它是依靠系统发送消息来指定的Port来出发\b的，消息的发送和接收使用mach/message中的Mach_msg（）函数。 Mach 的消息定义在&lt;mach/message.h&gt; 头文件中： 12345678910111213typedef struct&#123; mach_msg_header_t header; mach_msg_body_t body;&#125;mach_msg_base_t;typedef struct&#123; mach_msg_bits_t\b msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125;mach_msg_header_t； 一条Mach 消息实际上就是一个二进制的包（BLOB）,其头部定义了一个当前端口local_port和目标端口 remote_port 发送和接收消息是通过同一个API进行的，其option标记了传递方向 12345678910mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcg_name, mach_msg_timeout_t timeout, mach_port_name_t notifiy); match_msg（）的本质是一个调用mach_msg_trap()，这相当于一个系统调用，会出发内核状态切换，当程序精致的时候，RunLoop 停留在 __CFRunLoopServiceMachPort()的方法中，这个函数就是调用了mach_msg 让程序处于休眠状态 RunLoop 的核心就是一个mach_msg() ,RunLoop 调用这个函数去接收消息，如果没有别人发送port消息过来，内核会将线程至于等待的状态。例如你在模拟器里跑一个iOS的APP ，然后在APP静止的时候\b点击暂停，然后你会看到主线程调用栈是停留在mach_msg_trap() 这个地方 RunLoop 提供的接口这里讲解下NSRunLoop 的API 属性1234567// 获取当前的runloop@property (class, readonly, strong) NSRunLoop *currentRunLoop;// 获取到主线程的 runloop@property (class, readonly, strong) NSRunLoop *mainRunLoop API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));// 获取到\brunloop 的当前的mode@property (nullable, readonly, copy) NSRunLoopMode currentMode; 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 为mode 添加timer item-(void)addTimer:(NSTImer *)timer forMode:(NSRunLoopMode) mode;// 给mode tianj 一个Port-(void) addPort:(NSPort *)aPort forMode:(NSRunLoopMode )mode;// 从mode 中移除 port-(void)removePort:(NSPort *)aPort forMode:(NSRunLoopMode)mode;//-(nullable NSDate *)limitDateForMode:(NSRunLoopMode)mode;-(void)acceptInputFor\bMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;-(void)run;-(void) runUntilDate:(NSDate *)limitDate;- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate*)limitDate;/// Schedules the execution of a block on the target run loop in given modes./// - parameter: modes An array of input modes for which the block may be executed./// - parameter: block The block to execute- (void)performInModes:(NSArray&lt;NSRunLoopMode&gt; *)modes block:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));/// Schedules the execution of a block on the target run loop./// - parameter: block The block to execute- (void)performBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));/**************** Delayed perform ******************/@interface NSObject (NSDelayedPerforming)- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;@end@interface NSRunLoop (NSOrderedPerform)- (void)performSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg order:(NSUInteger)order modes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(nullable id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target;@end 实例的运用APP 启动 RunLoop12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061CFRunLoop &#123; current mode = kCFRunLoopDefaultMode; common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0(manual) CFRunLoopSourceRef&#123;order = -1,&#123;callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order = -1,&#123;callout = PurpleEventSignalCallBack&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach_port) CFRunLoopSource &#123;order = 0,&#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order = -1,&#123;callout = PurpleEventCallBack&#125;&#125; CFRunLoopSource &#123;order = 0,&#123;&#125;&#125; // Observers CFRunLoopObserver &#123;order = -2147483674 ,activities = 0x1, callout = _warpRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, callout = _UIGestureRecognizerUpdateObserver &#125; CFRunLoopObserver &#123;order = 1999000,activities = 0xa0,callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000 ,activities = 0xa0 ,callout = _ZN2CA11Transcation17Observer_callbackEP9——CFRunLoopObservermPV&#125; CFRunLoopObserver &#123;order = 2147483647 , activities = 0xa0 , callout = _warpRunLoopWithAUtoreleasepollHandler &#125; // timer CFRunLoopTimer &#123;firing = NO , interval = 3.1536E+09 ,tolerance = 0,next fire date = 453098071 (-4421),callout = _ZN2CAL14Timer_callbackEP16_CFRunLoopTimerPV(!uartZCore.framework)&#125; &#125; modes = &#123; CFRunLoopMode&#123; source0 = &#123;&#125;, source1 = &#123;&#125;, observers = &#123;&#125;, timers = &#123;&#125; &#125;. CFRunLoopMode &#123; source0 = &#123;&#125;, source1 = &#123;&#125;, observers = &#123;&#125;, timers = &#123;&#125; &#125;, CFRunLoopMode &#123; source0 = &#123;CFRunLoopSource &#123;order = 0,&#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, source1 = (null), observers = &#123; CFRUnLoopObserver &#123;activities = 0xa0 , order = 2000000 , callout = _ZN2CA11Transaction17Observer_callbackEP19_CFRunLoopObservermPV&#125; &#125;, timer = (null) &#125; &#125;&#125; 可以看出，系统默认注册了5个Mode1.KCFRunLoopDefaultMode :APP默认的Mode ,通常主线程是在这个Mode先运行的2.UITrackingRunLoopMode :界面追踪Mode ,用于ScrollView 追踪触摸滑动，保证界面滑动的时候不受其他Mode影响 UIInitializationRunLoopMode :在刚启动App的时候\b，进入的第一个Mode ，启动完成后就\b不再使用了 GSWventReceiveRunLoopMode : 接受系统事件内部的Mode,启动完成后就不再使用5.KCFRunLoopCommonMode :这是一个占位的Mode ,没有实际的作用 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; 检测当前runloop的操作AutoRelease 原理APP 启动的时候，苹果在主线程的RunLoop 里会注册两个Observer, 其回调都是_wrapRunLoopWithAutoreleasePoolHanler(). 第一个Observer 监视的时间是Entry ，其回调内部会调用 _objc_autoreleasePoolPush() 创建自动释放池，其order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个Observer 监视两个事件，BeforeWaiting（准备进入休眠）的时候调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新的池 Exit(即将退出Loop)的时候调用 _objc_autoreleasePoolPop() 来释放自耦东释放池，这个Observer 的order 是2147483647 ，优先级最低，保证其释放池发生在其他回调之后 通常在主线程执行的代码，通常\b是写在注入事件回调，Timer 回调中，这些回调会被RunLoop 创建好的AutoReleasePool 环绕着，所以不会出现内存泄露。 事件响应 苹果注册了一个Source1 (基于mach_port)的，用来接收系统事件，其回调函数为_IOHIDEventSystemClientQueueCallback(); 当一个\b硬件事件发生后，首先IOKit.farmwork生成一个IOHIDEvent事件并由SpringBoard接收，这个过程的详细情况可以参考这里。SpringBoard只接收（锁屏/静音）触摸，加速。接近传感器的几种Event,随后使用mach port 转发给App的进程。随后苹果注册的Source1 就会触发回调，并调用_UIApplicationHanleEventQueue() 进行应用内部的分发 _UIApplicationHanleEventQueue() 会把IOHIDEvent 处理并包装成UIEvent进行处理或分发，其中包括事变UIGuest/处理屏幕旋转/发送给UIWindow等，通常事件比如UIButton点击，touchsBeigin/move/end/cache事件都是在这个回调中完成的 GCD和RunLoop的关系 在RunLoop的源代码中可以看到用到了GCD相关的内容，但是RunLoop本身和GCD并没有什么直接的关系，当调用了dispatch_async(dispatch_get_main_queue(),block)的时候，libDispatch会向主线程RunLoop发送消息唤醒RunLoop，RunLoop从消息中获取block,并且在CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE里调用这个block,不过这个操作仅限于主线程，其他线程dispatch操作全部是由libDisoatch驱动的 内存检测工具FPS 工具","categories":[],"tags":[{"name":"iOS RunLoop","slug":"iOS-RunLoop","permalink":"http://yoursite.com/tags/iOS-RunLoop/"}]},{"title":"2018个人计划","slug":"what-to-do-for-2018","date":"2018-04-04T10:29:56.000Z","updated":"2018-04-04T01:23:11.000Z","comments":true,"path":"2018/04/04/what-to-do-for-2018/","link":"","permalink":"http://yoursite.com/2018/04/04/what-to-do-for-2018/","excerpt":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！","text":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！ 组件化的完善","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"iOS中Block的运用","slug":"block-use-method","date":"2018-04-04T02:06:28.000Z","updated":"2018-05-23T10:35:13.000Z","comments":true,"path":"2018/04/04/block-use-method/","link":"","permalink":"http://yoursite.com/2018/04/04/block-use-method/","excerpt":"摘要： 关于block的简单描述和使用概述","text":"摘要： 关于block的简单描述和使用概述 block的概述 Block：带有自动变量的匿名函数匿名函数：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域 语法： 声明： 返回值(^名称)(参数列表) typedef int(^ClickBlock)(NSUInteger); -(void)justAClick(ClickBlock)block{ NSLog(@&quot;Param:%@&quot;,block); } 定义： ^返回值类型(参数列表){表达式} ^(NSUInteger count){ //这里是代码展示区 return count + 1; } 自动变量 Block可以截获所使用的自动变量的值； 截获：保存自动变量的瞬间值 因为是瞬间值，所以Block之后，即便Block外面修改自动变量的值，也不会对Block内部有影响 如果需要对其的改变也会对变量产生影响的话，需要在变量的前面增加 __block block的运用 在我们的代码中，经常会用到block，其中涉及到了很多方面，下面我们将列举一些比较常见的用法和大家分享。分别是链式编程、返回参数、获取信息等。如果后续还有新的会增加。 链式编程这个在我们很多地方我们应该都能够看到（这里针对OC），比如Masonry,还有BabyBluetooth的使用方面都会涉及到链式编程 Masonry: make.top.equalto(self).offset(100); BabyBluetooth: baby.connecttoPeripherals().start(); 这样给人的感觉相对比较流畅和简洁很多。 首先先针对点式操作： 在OC中点语法就是一种语法糖，最终会调用对用属性的getter/setter的方法。 -(NSString*)hello{ return @&quot;hello&quot;; } self.hello; //会报 Property Access result unused; 我们让它的结果利用就来就不会报警告了 OK,针对点语法我们已经大概了解了，下面就针对链式中，为什么能够实现链式呢？ 这就得从返回值上做文章了，首先我们可以肯定返回值肯定是自身，要不然的话，就无法调用后续的函数进行操作了。 -(Test*)hello{ return self; } self.hello.hello; 这时候如果我们需要附带参数要如何实现： 很简单 block 动起来 -(Test*(^)(NSString*))hello{ return ^(NSString* str){ self.hello = str; return self; } } self.hello(@&quot;hello&quot;).hello(@&quot;str&quot;); NSLog(self.hello); 返回参数 参数的返回：很容易理解，就应该是利用返回值，来做判断的操作，或者利用返回值的数据，来进行一些操作。比如我们比较常用的UITabelView中针对Deletege 中的很多 比如rowCount //tableViewItem typedef NSUInteger (^CellCountBlock)(void); -(void)tableViewConfig{ if(self.CellCountBlock){ NSUInteger countNum = self.CellCountBlock(); NSLog(@&quot;the countNum is %d&quot;,countNum); } } //ViewController [tableViewItem tableViewConfig]; tableViewItem.CellCountBlock = ^{ return 10; } 当然这里我们也可以采用链式编程的方式来进行！ 获取信息 信息的获取：我们主要是在文件上传的时候可以看到关于fromData的拼接 - (NSMutableURLRequest*)multipartFormRequestWithMethod:(NSString*)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error { __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (block) { block(formData); } return [formData requestByFinalizingMultipartFormData]; } 这里将重要的代码贴出来： 这里的formData 数据是将数据的拼接防盗调用方进行拼接的，拼接完成后再将数据进行上传操作 所以这里的formData就是我们的重点 -(void)tableViewConfig:(void(^)(NSDictionary *))configBlock{ __block NSMutableDictionary *config = [NSMutableDictionary dictionaryWithCapacity:0]; if (configBlock) { configBlock(config); } NSLog(@&quot;the config is %@&quot;,config); } //使用 [[GYEBleManager shareManager] tableViewConfig:^(NSDictionary *config) { [config setValue:@&quot;hello&quot; forKey:@&quot;key&quot;]; }]; //结果： the config is { key = hello; } 链接： https://www.wangjiawen.com/ios/ios-block-usage-and-implementation https://www.jianshu.com/p/23c1bbe3c99d","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"如何构建一个Github的博客","slug":"how-to-build-github-blog","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-04T01:26:00.000Z","comments":true,"path":"2018/03/29/how-to-build-github-blog/","link":"","permalink":"http://yoursite.com/2018/03/29/how-to-build-github-blog/","excerpt":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你","text":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你 这里先列出大概的要点： Git的安装 Node.js的安装 Hexo 的安装和配置 Hexo 的发布和测试 Git安装 这里暂时没有涉及到后续补充 Node.js的安装Hexo的安装和配置Hexo 的安装npm install -g hexo-cli //全局安装hexo的客户端 如果不成功的话可以加上sudo 当这个执行成功后可以使用 hexo -v //查看是否安装成功 hexo 的初始化hexo init //这里可以针对具体的文件夹进行初始化操作 npm install //安装相对应的依赖包 hexo 框架简介 当hexo init 执行完成后，在当前的文件夹会增加框架的目录结构： _config.yml //网站的配置信息 package.json //项目包信息 scaffolds //模板文件夹，hexo 根据scaffold中的模板来新建文件 source //存放用户资源的地方 _drafts //存放草稿的地方_posts //存放发布的文件 themes //主题文件夹 hexo 简单配置首先我们需要打开_config.yml文件,这里是hexo的主要配置文件： 这里可以参考Hexo配置 title: lmzqm //网站标题 subtitle: iOS 开发者 //网站副标题 description: just do it //网站描述 keywords: //网站的关键字 author: lmzqm //您的名字 language: zh-CN //网站使用的语言 timezone: Asia/Shanghai //网站时区 hexo 命令下面简单介绍下hexo的命令： hexo generate //简写 hexo g 生成静态文件，会在当前的目录下生成一个新的public的文件夹 hexo server // 简写 hexo s 启动本地服务器，通过http://localhost:4000进行访问 hexo deploy // 简写 hexo d 部署到远程，在_config.yml中配置 hexo new post-name //简写 hexo n post-name 新建文章 hexo new page page-name //简写 hexo n page page-name 新建页面 会在Source下新建一个相对应的目录 组合命令： hexo s -g //生成和预览 hexo d -g //生成和部署 草稿命令： hexo new draft &lt;title&gt; //新建草稿，存放在source/_drafts hexo public post &lt;title&gt; //发布操作草稿文章，文章将转移到source/_posts hexo s -g // 可以开始进行预览操作 部署到GitHub pages 部署Hexo到GitHub 指的是将hexo -g生成的静态文件推送到github 对应的仓库中 因此我们需要在我们GitHub中做好相对应的准备 首先需要明确的是： 每一个github的账号都有一个GitHub的pages; 一个账号只能创建一个repository来存放GitHub pages; 仓库的名字必须是username/username.github.io 这是固定的命名约定 然后就可以通过 https://username.github.io 来进行访问 GitHub 创建的个人主页内容是在master分支下的 当你在你的github下创建了这个repository后，就可以在本地 先安装一个扩展： npm install hexo-deployer-git --save 修改 _config.yml中的配置： deploy: type:git repo:https://github.com/username/username.github.io.git branch:master 这样的话就可以通过执行 hexo d -g 将静态网站提交到github网站上 hexo 主题首先关于hexo的主题可以在github中进行查找，很方便就能找到一些主题，然后可以选择你所需要的主题，关于主题内部的具体配置，可以参照具体的网站来进行配置。 hexo clean //clean remove generated files and cache 然后就可以选择你自己想要的主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这个完成后需要在根目录下的_config.yml中将主题变换成我们现在的主题： theme: yilia 这时候在theme的文件夹下就可以就会多出一个文件夹yilia着是主题的文件夹，进入后可以用git来进行操作，切换tag来针对不同的版本，当然对于不同版本的具体要求对应的网站上去查看下详情会比较好理解 后期针对主题的设置，我们需要进入到相对应主题当中的_config.yml文件进行配置 这个可以在网上找到很多信息 后期我们再专门弄个文章来进行阐述，这里就暂时先简单描述","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"MarkDown 的基础使用","slug":"Markdown-leaning","date":"2018-03-29T10:29:56.000Z","updated":"2018-07-10T02:55:05.000Z","comments":true,"path":"2018/03/29/Markdown-leaning/","link":"","permalink":"http://yoursite.com/2018/03/29/Markdown-leaning/","excerpt":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------","text":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------ 使用#来表示字号，可以使用1-6级标题来进行表示 #一级标题##二级标题###三级标题 效果： 一级标题二级标题三级标题四级标题五级标题 段落 段落的前后需要有空行，所谓的空行是指没有文字的内容，使用两个以上的空格加上回车键就可以达到段落的效果 区块的操作在段落的每行或者只要在第一行中使用符号&gt;就可以使用区块，当然还可以使用多个嵌套 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符 void main(){ printf(&quot;hello world&quot;); } 代码区块 需要和普通的段落之间存在空行 \b同时可以使用`~~~来做代码段1234eg:~~~ objc#import &quot;&quot; 强调在强调的内容两侧分别加上*或者_,比如： *斜体* **加粗**_斜体_ __加粗__ 效果： 斜体 _斜体_ 加粗 加粗 列表无序列表使用*、+、-这几个号码来进行列表 第一项 第二项 第三项 有序列表使用数字加上英文的句号eg:121.第一行2.第二行 第一行 第二行 分割线采用三个或者三个以上的*,_,-就可以构建分割线了 链接链接有两种形式生成：行内式和参考式 [链接](http://www.baidu.com) 这就是是链接的使用方式了 图片添加图片的形式和链接的形式相似，值需要在链接的基础上前方加上一个！就可以了 ![alt text](/path/to/img.jpg) 下面阐述下这个： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着是一个普通括号，里面放上图片的网址，左后要用 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其他意义的符号，可以利用反斜杠来显示一些在markdown中存在语法的字符","categories":[],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]}