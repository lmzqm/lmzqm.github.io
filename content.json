{"meta":{"title":"lmzqm","subtitle":"iOS 开发者","description":"just do it","author":"lmzqm","url":"http://yoursite.com"},"pages":[{"title":"iOS","date":"2018-04-02T01:49:22.000Z","updated":"2018-04-02T01:49:22.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"AFNetworking-AFHTTPSessionManager 详解","slug":"AFNetworking-AFHTTPSessionManager","date":"2018-05-08T02:51:55.000Z","updated":"2018-05-08T06:31:26.000Z","comments":true,"path":"2018/05/08/AFNetworking-AFHTTPSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/08/AFNetworking-AFHTTPSessionManager/","excerpt":"摘要： 这里我们要给大家讲述下AFHTTPSessionManager\b\b中的知识点。\b首先要知道AFHTTPSessionManager是继承与AFURLSessionManager的，所以，创建\bTask的是可以完成的。AFHTTPSessionManager 更多是关注与HTTP的请求的操作，其核心更多是关于Request的构建，这个request主要用于task的创建。","text":"摘要： 这里我们要给大家讲述下AFHTTPSessionManager\b\b中的知识点。\b首先要知道AFHTTPSessionManager是继承与AFURLSessionManager的，所以，创建\bTask的是可以完成的。AFHTTPSessionManager 更多是关注与HTTP的请求的操作，其核心更多是关于Request的构建，这个request主要用于task的创建。 属性//这个是请求的基础URL 后续的可以使用拼接构成一个新的URL来进行请求的操作 @property(readonly , nonatomic, strong, nullable) NSURL *baseURL; // 这是请求的序列化 主要针对请求的过程中进行reqeust的构建 @property(nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLReqeustSerialization&gt; *requestSerializer; // 这是响应的序列化 主要针对Response中数据的处理操作 @property (nonatomic, strong) AFHTTPReponseSerializer &lt;AFURLResonseSerialization&gt; *responseSerializer; 方法这里的方法主要有初始化的方法，还有针对不同请求方式的方法 初始化/** Creates and returns an `AFHTTPSessionManager` object. */ + (instancetype)manager; /** Initializes an `AFHTTPSessionManager` object with the specified base URL. @param url The base URL for the HTTP client. @return The newly-initialized HTTP client */ - (instancetype)initWithBaseURL:(nullable NSURL *)url; // - (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration { //调用父类来创建一个实例 self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) { url = [url URLByAppendingPathComponent:@&quot;&quot;]; } self.baseURL = url; // 默认采用HTTPSErializer self.requestSerializer = [AFHTTPRequestSerializer serializer]; // 默认采用JSONResonseSerilizer self.responseSerializer = [AFJSONResponseSerializer serializer]; return self; } GET// 通过一个requst来创建并运行一个Get的请求 - (nullable NSURLSessionDataTask*)GET:(NSString*)URLString parameters:(nullable id)parameters success:(nullable void(^)(NSURLSessionDataTask *_Nullable task ,id _Nullable responseObject ))success failure:(nullable void (^)(NSURLSessionDataTask *_Nullable task ,NSError *error))failure; - (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; HEAD- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; POST- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE; - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; PUT- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; PATCH- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; DELETE- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 核心// 构建网络请求的操作 这里主要是针对一些\b比较\b简单的 除了带\bformData 的数据的处理 - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure { // 这里进行序列化的操作 通过序列化\b获得到\b一个请求操作 NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; // 如果序列化出错的处理操作 if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } // 获取task的操作 __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask; } POST的操作方式 - (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure { NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError]; NSDictionary *dic = request.allHTTPHeaderFields; // NSData *data = request.HTTPBodyStream; // id body = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil]; NSLog(@&quot;%@&quot;,dic); // NSLog(@&quot;%@&quot;,body); if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(task, error); } } else { if (success) { success(task, responseObject); } } }]; [task resume]; return task; } POST请求的常用格式 在众多请求方法中POST的请求还是相对复杂点的，比如\b说比较常见的文件上传的请求操作，其中还会带带一些额外的参数，这样的话请求体的构建\b就会比较复杂点。 application/x-www-form-urlencoded 格式的\bPOST请求这是比较常见的POST提交数据的方式。浏览器原生表单，如果不设置\b的话，默认就会用这种方式提交。如果以这种格式\b进行操作的话：提交的数据会按照 key1=val1&amp;key2=val2的方式进行编码。同时key和val都会进行URL转码 代码展示： // 构建一个sessionConfig NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; config.HTTPAdditionalHeaders = @{};//可以添加额外的请求头信息 // 创建一个HTTPSessionManager AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:_config.baseUrl] sessionConfiguration:config]; //创建一个请求的序列化操作 AFHTTPRequestSerializer *serializer = [AFHTTPRequestSerializer serializer]; // 设置超时时间 serializer.timeoutInterval = 10; // 可以添加一些请求头的信息 [serializer setValue:@&quot;&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; manager.requestSerializer = serializer; NSMutableSet *mulSet = [NSMutableSet setWithSet:manager.responseSerializer.acceptableContentTypes]; [mulSet addObject:@&quot;application/json&quot;]; [mulSet addObject:@&quot;text/plain&quot;]; [mulSet addObject:@&quot;text/json&quot;]; [mulSet addObject:@&quot;text/html&quot;]; // 添加\b响应序列化操作 manager.responseSerializer = [AFHTTPResponseSerializer serializer]; manager.responseSerializer.acceptableContentTypes = mulSet; // 构建task的操作进行网络请求 [manager POST:url parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; multipart/form-data格式的POST请求这种格式主要针对上传文件的操作， 请求头和请求体的格式是比较特殊的首先：content-Type的值必须是multipart/form-data同时\b：同时还需要规定一个内容分割符来分割请求体重多个POST的内容 请求头中信息中：Content-Type:multipart/form-data ;boundary=xxxx 请求体中的信息： POST /upload HTTP/1.1 Host: xxxxx.xxxx.com Content-Type:multipart/form-data ;boundary=xxxxxx Accept-Encoding: gzip, deflate Connection: keep-alive Date: 2017-10-19 18:11:53 +0800 Accept: */* User-Agent: GyennoMedical/4.0.0 (iPhone; iOS 11.0.3; Scale/3.00) Accept-Language: en-US Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJvcmdUeXBlIjoxLCJzdWIiOiIxMzgwMDEzODAwMyIsInVzZXJUeXBlIjoxLCJleHAiOjE1MDk1Mjk1MzYsInVzZXJJZCI6OTg2NTc5LCJvcmdJZCI6Mn0.CKxnt5f5uTRvUwuEybcN79RG-uf74pFbWwWbCFk8jJI Content-Length: 4556 --xxxxxxx Content-Disposition:form-data;name=&quot;meta&quot; xxxxxxxxx 对应的字段内容 --xxxxxxx Content-Disposition:form-data;name=&quot;fileupload&quot; filename=&quot;file1.jpeg&quot; Content-Type:image/jpeg XXXXXXXXXXXXXX //图片的数据 --xxxxxxx-- 先构建下核心代码： [manager POST:prefixUrlString parameters:@{@&quot;meta&quot;:str} constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { NSData *data = UIImageJPEGRepresentation(image, 0.01); [formData appendPartWithFileData:data name:@&quot;fileUpload&quot; fileName:@&quot;file1.jpeg&quot; mimeType:@&quot;image/jpeg&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { successBlock(responseDic); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; application/json\b格式的POST请求这种格式的操作下会将数据采用json的格式进行组合 这里需要注意的就是针对\b请求序列化操作的时候采用\b AFHTTPRequestSerializer *serializer = [AFJSONRequestSerializer serializer]; 这样就可以达到效果了。 POST /xxxxx/xxxxxx HTTP/1.1 Host: xxxxx.xxxxx.com Content-Type: application/json Accept-Encoding: gzip, deflate Connection: keep-alive Date: 2017-10-17 18:11:53 +0800 Accept: */* User-Agent: GyennoMedical/4.0.0 (iPhone; iOS 11.0.3; Scale/3.00) Accept-Language: en-US Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJvcmdUeXBlIjoxLCJzdWIiOiIxMzgwMDEzODAwMyIsInVzZXJUeXBlIjoxLCJleHAiOjE1MDk1Mjk1MzYsInVzZXJJZCI6OTg2NTc5LCJvcmdJZCI6Mn0.CKxnt5f5uTRvUwuEybcN79RG-uf74pFbWwWbCFk8jJI Content-Length: 108 {&quot;userId&quot;:&quot;xxxxxxx&quot;,&quot;pageNo&quot;:1,&quot;orgType&quot;:1,&quot;pageSize&quot;:5,&quot;orgId&quot;:2,&quot;userType&quot;:1,&quot;accountNumber&quot;:&quot;xxxxxxxxx&quot;} 总结 通过上面的代码中的展示，我们可以清楚AFHTTPSessionManager主要是 RequestSerializer 和 AFURLSessionManger中的两个部分来构建： serilizer 主要是通过获取的参数来进行URLReqest的构建 URLSessionManger 主要通过request来创建Task 并允许task 所以将在下一篇分析下RequestSerializer 里面的东西 其中重点讲放在POST的请求中","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"设计模式","slug":"design-create-model","date":"2018-05-03T10:31:21.000Z","updated":"2018-05-08T06:29:45.000Z","comments":true,"path":"2018/05/03/design-create-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-create-model/","excerpt":"摘要\b：设计模式分为三大类 创建型模式 结构型模式 行为型模式","text":"摘要\b：设计模式分为三大类 创建型模式 结构型模式 行为型模式 创建型模式创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对这些对象只需要指定他们共同的接口，而不需要知道具体的实现细节，使整个系统设计更加符合单一职责的原则 简单工厂模式 （simple Factory） 工厂方法模式 （Factory Method） 抽象工厂模式 （Abstract Factory） 建造者模式 （Builder） 原型模式 （Prototype） 单例模式 （Singletion） 结构型模式","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式 开篇——读懂UML类图和时序图","slug":"design-model","date":"2018-05-03T09:38:58.000Z","updated":"2018-05-03T10:31:27.000Z","comments":true,"path":"2018/05/03/design-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-model/","excerpt":"摘要： 这里主要是记录对设计模式的学习的过程，会出一个系列的文章。敬请期待。","text":"摘要： 这里主要是记录对设计模式的学习的过程，会出一个系列的文章。敬请期待。 首先从一个实例开始 车的类图结构为&lt;&gt;,表示车是一个抽象类; 它有两个继承类：小汽车和自行车； 它们之间的关系为\b实现关系，使用带空心箭头的虚线表示 小汽车和SUV之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示 小汽车和发动机之间属于组合关系，使用带\b实心箭头的实线表示 学生和班级之间属于聚合关系，使用带空心箭头的实线表示 学生和身份证之间是关联关系，使用一根实线表示 学生上学需要自行车，与自行车是一种依赖关系，使用带箭头的虚线表示 类之间的关系泛化关系 类的继承结构在UML中表示为：泛华，实现 继承关系表示is-a的关系 表示是的关系 在UML中用时一个空心实线箭头表示 在最终的代码中，泛化关系表现为继承非抽象 \b实现关系 实现关系用一条空心箭头的虚线表示 eg:”车”是一个抽象概念，在现实中无法直接用来定义对象，只有指明具体的子类才可以用来定义对象 在最终代码中，实现关系表现为继承抽象类 聚合关系 聚合关系用一条带空心菱形箭头直线表示，表示A聚合到B上，或者说B是由A组成的 聚合关系用于表示实体对象之间的关系，表示整体由部分构成 与组合关系不同的是，整体和部分不是强依赖，即使整体不存在了，部分任然粗壮 组合关系 组合关系用一条带实心菱形箭头直线表示 与聚合关系一样，组合关系表示整体由部分构成的语义 但是组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在 关联关系 关联关系用一条直线表示 描述不同类的对象之间的结构关系，它是一种\b静态关系，通常与运行的状态无关，一般由常识因素决定；它一般用来定义对象之间静态的，天然的结构；所有关联关系是一种强关联的关系 在最终代码中，关联对象同时是以成员变量的形式实现 依赖关系 依赖关系是一套带箭头的虚线表示的， 与关联关系不同的是，他是一种临时性的关系，通常发生在运行期间产生，并且随着运行时的变化，依赖关系也可能发生改变 显然依赖也是有方向的，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生 在最终的代码中，依赖关系体现为类构造方法以及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方还是使用对方的方法和属性 时序图 对象之间交互的图，这些对象是按时间顺序排列的，时序图中显示的是参与交互对象以及对象之间消息交互的顺序 时序图包括对象主要有：对象（actor）生命线（Lifeline）控制焦点（Focus of control）消息（Message）等待","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"AFNetworking-AFURLSessionManager详解","slug":"iOS-AFNetworking-AFURLSessionManager","date":"2018-05-03T07:45:33.000Z","updated":"2018-05-08T06:29:42.000Z","comments":true,"path":"2018/05/03/iOS-AFNetworking-AFURLSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/03/iOS-AFNetworking-AFURLSessionManager/","excerpt":"摘要： 关于\biOS中的网络请求，在上一篇文章中已经大体了解了在网络请求的过程中的一些主要点，比如说一个NSURLRequest,一个NSURLSession，一个Task 等等,在我们的实际项目中我较多使用的是AFNetworking来作为我的网络请求模块，然后再对其进行封装下。个人认为对于第三进行封装是很有必要的，要不然当你切换一个\b新的第三方的时候，你需要在你的工程中找呀找，改呀该。","text":"摘要： 关于\biOS中的网络请求，在上一篇文章中已经大体了解了在网络请求的过程中的一些主要点，比如说一个NSURLRequest,一个NSURLSession，一个Task 等等,在我们的实际项目中我较多使用的是AFNetworking来作为我的网络请求模块，然后再对其进行封装下。个人认为对于第三进行封装是很有必要的，要不然当你切换一个\b新的第三方的时候，你需要在你的工程中找呀找，改呀该。 上面废话有点多了 今天我会通过源代码给大家分享下，AFNetworking的核心，AFURLSessionManager ,其实如果对于NSURLSession比较了解的话，相信用该很请求这个Manager的主体核心的功能就是通过session来创建task ,然后利用代理来做请求的反馈的过程。ok 接下来让我们先了解下吧！ 方法和属性属性//manager的会话 很熟悉吧！ @property (readonly, nonatomic, strong) NSURLSession *session; // 代理调用中用到的操作队列 @property (readonly ,nonatomic ,strong) NSOperationQueue *operationQueue; //接收信息的序列化 @property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer; // 会话的安全策略 @property (nonatomic, strong) AFSecurityPolicy *securityPolicy; /** The data, upload, and download tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks; /** The data tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks; /** The upload tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks; /** The download tasks currently run by the managed session. */ @property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks; // 针对completionBlock的一个队列 如果为null的haul 使用main queue @property (nonatomic, strong, nullable) dispatch_queue_t completionQueue; // 针对\b组请求操作 completionBlock 的操作 @property (nonatomic, strong, nullable) dispatch_group_t completionGroup; //如果后台会话中创建上传任务失败的话 会继续创建 @property (nonatomic, assign) BOOL attemptsToRecreateUploadTasksForBackgroundSessions; 方法 初始化 // 一个配置项就可以初始化一个Manager - (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration{ self = [super init]; if (!self) { return nil; } // 如果有用户没有手动指定的话，就默认使用configuration来初始化 if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } // 赋值给属性 self.sessionConfiguration = configuration; // 初始化NSURLSession的task代理方法执行的队列 // 这里有一个关键的点就是task的代理执行的queue一次只能执行一个task 队列是串行队列 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; // 初始化NSURLSession 对象 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 如果用户没有手动指定的话，默认返回的数据是JSON格式序列化 self.responseSerializer = [AFJSONResponseSerializer serializer]; // 指定https处理的安全策略 self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH // 初始化网络状态监听属性 self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif // 用于处理task和Delegate代理对象一一对应的关系 这个很关键 self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; // 初始化一个锁对象，关键操作加锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /* 获取当前session正在执行的的所有task.同时为每一个Task添加‘Delegate’代理对象 这个代理对象主要用于管理uploadTask和downLoadTask的进度管理，并且在Task执行完毕后调用相对应的Block 同时发送Notification对象，实现Task数据或者状态改变的检测 **/ [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self; } 任务的创建： //创建一个dataTask 通过特殊的request - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 创建一个dataTask 并由uploadprogress 和downloadProgress的回调操作 - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过request和 一个文件的路径来创建一个uploadTask - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过一个bodyData和request来创建一个uploadTask - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; // 通过一个特殊的请求来创建\bdownLoadTask - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler; // 创建一个断点下载的downloadTask - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler; 其他： // 是否是会话无效 通过取消任务 一个是立即取消 一个是等任务完成后再取消 - (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks{ dispatch_async(dispatch_get_main_queue(), ^{ if (cancelPendingTasks) { //这个就是会话的方法啦 [self.session invalidateAndCancel]; } else { [self.session finishTasksAndInvalidate]; } }); } 各种回调的block: - (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block; - (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block; - (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block; - (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block; - (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block; - (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block; - (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block; - (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block; - (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block; - (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block; - (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block; - (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block; - (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block; - (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block; - (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block; 一看就已经很明白啦！都是针对代理的block 使用流程AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; \bNSURLSessionDataTask *task = [manager dataTaskWithRequest:reques completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) { if (error) { // successBlock(()) }else{ } }]; [task resume]; 下面我们来分析下dataTask创建中的代码： - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { __block NSURLSessionDataTask *dataTask = nil; // 这里是一个同步的操作,当然它的方法也是简单的session场景dataTask的方法 url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); // 给task添加代理 并将uploadProgressBlock 和 download\bProgressBlock 还有 completionHanler 也交给代理进行管理 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } 下面让我们来分析 addDelegateForDataTask 当中的操作这里的主要操作是为Task设置一个代理对象，从而可以实现对进度处理，Block调用、Task完成返回数据的拼装的功能 - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler { // 这里创建一个代理的对象 delegate AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; // 赋值delegate的manager delegate.manager = self; // 赋值deleget的completionHandler 这个是针对Task的处理的回调 delegate.completionHandler = completionHandler; //添加任务的描述 \b dataTask.taskDescription = self.taskDescriptionForSessionTasks; // 为task 添加代理 [self setDelegate:delegate forTask:dataTask]; //还有uploadblock 和 downloadblock delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock; } // Delegate 设置Task 状态改变的监听 主要是task的挂起或者重启的监听 - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task { NSParameterAssert(task); NSParameterAssert(delegate); // 这里需要用到加锁的处理 [self.lock lock]; // 为task设置与之代理方法关联关系。通过一个字典,便于后续通过task 来进行查找delegate 然后滴啊用deleget的对应的方法来进行操作 self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // 添加Task开始，重启，挂起状态的通知的接收 便于控制uploadProgress和downloadProgerss [delegate setupProgressForTask:task]; [self addNotificationObserverForTask:task]; [self.lock unlock]; } 下面来分析下 AFURLSessionManagerTaskDelegate 创建： /* 初始化AFURLSessionManagerTaskDelegate */ - (instancetype)init { self = [super init]; if (!self) { return nil; } // 这个属性用于存储Task下载过程中的数据 self.mutableData = [NSMutableData data]; // 存储Task上传和下载的进度 self.uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; self.uploadProgress.totalUnitCount = NSURLSessionTransferSizeUnknown; self.downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil]; self.downloadProgress.totalUnitCount = NSURLSessionTransferSizeUnknown; return self; } - (void)setupProgressForTask:(NSURLSessionTask *)task { __weak __typeof__(task) weakTask = task; self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive; [self.uploadProgress setCancellable:YES]; // 当process对象取消的时候，取消task [self.uploadProgress setCancellationHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask cancel]; }]; // 当process暂停的时候，暂停task [self.uploadProgress setPausable:YES]; [self.uploadProgress setPausingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask suspend]; }]; // 重启Task if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) { [self.uploadProgress setResumingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask resume]; }]; } // 针对取消progress的操作也是一样的 [self.downloadProgress setCancellable:YES]; [self.downloadProgress setCancellationHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask cancel]; }]; [self.downloadProgress setPausable:YES]; [self.downloadProgress setPausingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask suspend]; }]; if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) { [self.downloadProgress setResumingHandler:^{ __typeof__(weakTask) strongTask = weakTask; [strongTask resume]; }]; } // kvo的操作 会调用 observeValueForKeyPath 的函数的操作 对NSURLSessionTask 的属性进行观察操作 //数据的接收，主要针对downloadTask [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive)) options:NSKeyValueObservingOptionNew context:NULL]; //数据的上传，主要针对uploadTask [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent)) options:NSKeyValueObservingOptionNew context:NULL]; [task addObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend)) options:NSKeyValueObservingOptionNew context:NULL]; // 为progress 添加kvo 针对 fractiongCompleted [self.downloadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; [self.uploadProgress addObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted)) options:NSKeyValueObservingOptionNew context:NULL]; } 这里是针对上面kvo的操作 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context { if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) { self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) { self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) { self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) { self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; } } else if ([object isEqual:self.downloadProgress]) { // 更新下载的进度的BLock if (self.downloadProgressBlock) { self.downloadProgressBlock(object); } } else if ([object isEqual:self.uploadProgress]) { // 更新上传进度的Block if (self.uploadProgressBlock) { self.uploadProgressBlock(object); } } } ok,这些前期的工作做完以后，我们就可以开始代理的工作了： 这里的代理主要实现了几个方法： \b当任务完成以后： #pragma mark - NSURLSessionTaskDelegate // 当task完成以后，会调用delegate对象的方法对返回的数据进行封装 - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; // 获取Task对应的Manager对象 __strong AFURLSessionManager *manager = self.manager; // 要封装的responseObject对象 __block id responseObject = nil; // __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //返回的数据 //Performance Improvement from #2672 NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } //如果是downloadTask 就封装downloadFileUrl if (self.downloadFileURL) { userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; } else if (data) { userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; } // 针对请求错误的封装 if (error) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ // 如果task有completionHandler 就调用这个Block if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } // 发送一个指定task结束的通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); } else {//正确数据的封装 dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; // 返回数据的封装 responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; if (self.downloadFileURL) { responseObject = self.downloadFileURL; } if (responseObject) { userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; } if (serializationError) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; } // 如果Task有完成的Blokc，则调用这个Block dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } // 发送Task完成的通知 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } #pragma clang diagnostic pop } NSURLSessionDataTaskDelegate \b代理的操作 #pragma mark - NSURLSessionDataTaskDelegate - (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { // 这里主要做的是数据的拼接 [self.mutableData appendData:data]; } NSURLSessionDownloadTaskDelegate 代理操作： #pragma mark - NSURLSessionDownloadTaskDelegate - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { NSError *fileManagerError = nil; self.downloadFileURL = nil; // 这里的location是缓存的url的地址 if (self.downloadTaskDidFinishDownloading) { // 将获取文件的存放路径 然后将location的地址放入到存放的地址中进行文件的保存操作 self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (self.downloadFileURL) { // 这里是存放的操作 [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]; if (fileManagerError) { [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; } } } } 这里是一个下载的例子，可以好好参考下： NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress *downloadProgress){ NSLog(@&quot;下载进度:%lld&quot;,downloadProgress.completedUnitCount); } destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) { NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; NSURL *fileURL = [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]]; NSLog(@&quot;fileURL:%@&quot;,[fileURL absoluteString]); return fileURL; } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) { self.imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:filePath]]; NSLog(@&quot;File downloaded to: %@&quot;, filePath); }]; 其中有一个destination的block的操作： - (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler { // 根据指定的Task，初始化一个AFURLSessionManagerTaskDelegate 其实这里采用的是MVP模式 AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; delegate.manager = self; // 设置task完成的回调你的BLOCK delegate.completionHandler = completionHandler; if (destination) { // 任务完成以后，调用destination 这个Block delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) { return destination(location, task.response); }; } // 指定Task与taskDescriptionForSessionTasks的关联，方便后面的通知中做出对应的处理 downloadTask.taskDescription = self.taskDescriptionForSessionTasks; // 添加通知 [self setDelegate:delegate forTask:downloadTask]; // 设置一个下载进度的block,以便在后面代理中调用 delegate.downloadProgressBlock = downloadProgressBlock; } 后面有一个destination的操作，我们做的事情就是给它找一个合适的地方来进行存放，然后在completion中主要做的就是将文件的地址给我们的应用就可以了 代理完成任务以后，我们要做什么？ - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 当我们的task完成任务以后： AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) { [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; } if (self.taskDidComplete) { self.taskDidComplete(session, task, error); } } // 当移除Task对应的通知和对应的AFURLSessionManagerTaskDelegate代理对象 - (void)removeDelegateForTask:(NSURLSessionTask *)task { NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; // 移除task对应的kvo [delegate cleanUpProgressForTask:task]; // 移除Task对应的delegate对象 [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock]; } 代理的清除操作： - (void)cleanUpProgressForTask:(NSURLSessionTask *)task { [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))]; [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]; [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))]; } 其中的MVP 在AFURLSessionManager中我们可以看到，这里针对每个task 都会有一个addDelegateForTask的方法，这里的针对每一个task 都创建一个AFURLSessionTaskDelegate 的代理，这个代理就是MVP中的Present 它处理View中的一些操作，然后将处理好的操作的数据，同时P中\b对于Manager使用的是Weak的操作 一个弱引用而不是强引用 特殊模块说明AFURLSessionManager 实现了 NSSecureCoding 协议 让Manager可以归档和解档的操作 使用dispatch_semaphore_t信号量来控制对异步处理返回的结果控制// 用dispatch_semaphore_t 来控制对异步处理返回的结果的控制 - (NSArray *)tasksForKeyPath:(NSString *)keyPath { //获取session对应的task列表，通过disptch_semaphore_t来控制访问过程 __block NSArray *tasks = nil; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) { tasks = dataTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) { tasks = uploadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) { tasks = downloadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) { tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;]; } dispatch_semaphore_signal(semaphore); }]; // 这里会一直等待信号量变为1 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 返回Task. 通过信号量控制，避免了方法结束的时候，tasks还没有正常获取的情况 return tasks; } 总结ok,在这里已经将AFURLSessionManager的主要的实现都已经涉及到了。下面来","categories":[],"tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"iOS NSURLSession 解析","slug":"NSURLSESSION-Detail","date":"2018-04-24T09:04:38.000Z","updated":"2018-05-03T07:40:45.000Z","comments":true,"path":"2018/04/24/NSURLSESSION-Detail/","link":"","permalink":"http://yoursite.com/2018/04/24/NSURLSESSION-Detail/","excerpt":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。","text":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。 一个简单的例子这里构建一个简单的请求的例子 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:smallPic]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc]init]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request]; [dataTask resume]; 从上的代码中我们可以大体的分析下，一个网络请求的过程中，我们分别需要的角色： NSURLRequest ：一个网络请求 NSURLSession ： 一个会话 NSURLSessionConfiguration ： 会话的配置项 NSURLSessionDataTask : 会话中的任务 一个会话需要会话的配置信息来进行创建，其中还存在着线程队列已经代理的设置一个任务是会话通过请求的信息来进行创建，创建出来的任务只有执行resume后才开始执行任务 下面我们将通过对这个所需的元素进行一一分析，来进一步的了解他们之间的关系，已经各个元素的一些属性和方法。 首先针对AFNetworking的扩展，其实它的核心也是一个最基础的网络请求操作，后续再对这个简单的操作进行扩展，这样就会慢慢的可以通过用户添加一些block来对函数进行一些自定义的一些操作，这些都是后话。后期的话，我会针对AFNetworking进行源码解析，同时也希望自己能够写出实现自己的网络框架。 NSURLRequest在iOS中关于请求的操作，其基类都是NSURLReqeust 当然还有一个可变的NSMutableURLReqeust当然对于可变和不可变的特性相对大家都已经比较理解了。下面我们来创建一个最基础的reqeust [[NSURLRequest alloc] initWithURL:@&quot;url&quot;]; 最简单的组成就是一个url来创建，当然它还有一些特性，这些特性针对URLReqeust更多的是可读的属性但是对可变的URLRequest则是可读可写的 创建实例对象：类方法： //通过url来进行创建 +(instancetype)requestWithURL:(NSURL*)URL; // 通过url 以及缓存策略 还有网络超时时长来进行创建 +(instancetype)requestWithURL:(NSURL*)URL cacehPolicy:(NSURLRequestCachePolicy)cachePolicy timeooutInterval:(NSTimeInterval)timeoutInterval; 实例方法： - (instancetype)initWithURL:(NSURL *)URL; // 通过实例方法创建 - (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval NS_DESIGNATED_INITIALIZER; 属性：@property (nullable, readonly, copy) NSURL *URL;// url @property (readonly) NSURLRequestCachePolicy cachePolicy;//缓存策略 @property (readonly) NSTimeInterval timeoutInterval;//网络请求超时时间 @property (nullable, readonly, copy) NSString *HTTPMethod;//请求的方法 有get post delete put 等等 @property (nullable, readonly, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields; //请求头中的字段所存放的字典 针对这字段有提供专门的方法来实现添加和查询的工作： - (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;//根据字段名字查找对应的信息 - (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//这是直接设置对应的信息 - (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//这里是添加对应的信息 @property (nullable, copy) NSData *HTTPBody;//请求中的数据信息 也就是请求体重的信息 这些是主要用到的信息，如果后期还有的话，会慢慢添加的。 其实很多对网络特别是HTTP协议不是很理解的人，可能看得有点晕，没关系，这里我们贴下http的请求给大家看看就会便于理解了 GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 上面的代码中我们可以知道关于Request中的一些信息： url:img.mukewang.com/562f25980001b1b106000338.jpg HTTPMethod:GET 接下来就是请求头的一些字段： Accept : 表示客户端接受的一些格式 Accept-Encoding：接受的压缩格式 Accept-Language：接受的语言 NSURLSessionConfiguration关于会话的配置有三种模式： //默认模式 @property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration; // 临时会话模式 @property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration; //后台模式 + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0)); 属性// 一个后台会话的标识符 @property (nullable, readonly, copy) NSString *identifier; // 请求缓存策略 @property NSURLRequestCachePolicy requestCachePolicy; // 网络请求超时时长 @property NSTimeInterval timeoutIntervalForRequest; // 网络资源请求操作 @property NSTimeInterval timeoutIntervalForResource; // 网络请求服务类型 @property NSURLRequestNetworkServiceType networkServiceType; // 是否允许用蜂窝 @property BOOL allowsCellularAccess; // 添加额外的请求头 @property (nullable, copy) NSDictionary *HTTPAdditionalHeaders; NSURLSession 这个类是关于会话的创建，会话的使用，会话的调度等等 下面通过源代码来对这个类进一步了解： 创建// 通过会话配置来进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过会话配置 还有代理 已经多线程队列进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue; 生成不同的TaskdataTask/* Creates a data task with the given request. The request may have a body stream. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request; /* Creates a data task to retrieve the contents of the given URL. */ - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url; uploadTask/* Creates an upload task with the given request. The body of the request will be created from the file referenced by fileURL */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL; /* Creates an upload task with the given request. The body of the request is provided from the bodyData. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData; /* Creates an upload task with the given request. The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */ - (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request; downTask/* Creates a download task with the given request. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request; /* Creates a download task to download the contents of the given URL. */ - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url; /* Creates a download task with the resume data. If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */ - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData; 直接带返回回调的task/* * data task convenience methods. These methods create tasks that * bypass the normal delegate calls for response and data delivery, * and provide a simple cancelable asynchronous interface to receiving * data. Errors will be returned in the NSURLErrorDomain, * see &lt;Foundation/NSURLError.h&gt;. The delegate, if any, will still be * called for authentication challenges. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * upload convenience method. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * download task convenience methods. When a download successfully * completes, the NSURL will point to a file that must be read or * copied during the invocation of the completion routine. The file * will be removed automatically. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; 属性和方法属性：@property (readonly ,retain) NSOperationQueue *delegateQueue; @property (nullable,readonly,retain) id &lt;NSURLSessionDelegate&gt; delegate; @property (readonly ,copy) NSURLSessionConfiguration *configuration; //会话的描述 @property (nullable,copy) NSString *sessionDescription; 方法：//完成所有任务后，将会话无效 // returns immediately and existing tasks will be allowed to run to completion. New tasks may not be Created。The Session will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError: has been issued; -(void)finishTasksAndInvalidate; // 会话无效后取消操作 // issues cancel to all outstanding tasks for this session. -(void)invalidateAndCancel; //invoke completionHandler with outstanding data,upload and download tasks -(void)getTasksWithCompletionHandler:(void(^)(NSArray&lt;NSURLNSURLSessionDataTask*&gt;* dataTask,NSArray&lt;NSURLSessionUploadTask*&gt;* uploadTasks,NSArray&lt;NSURLSessionDownloadTask*&gt;*downloadTask))complcompletionHandler; 代理NSURLSessionDelegate// 这是会话接收最后一条消息 当会话遇到系统级的错误 获取当会话无效的时候 -(void)URLSession:(NSUrlSession*)session didBecomeInvalidWithError:(nullable NSError *)error; //当遇到需要用户权限验证的时候，或者HTTPS验证的时候会调用这个代理 -(void)URLSession:(NSURLSession*)session didReceiveChallenge:(NSURLAuthenticationChallenge*)challenge completionHandler:(void(^)(NSURLSessionAuthChallengeDispostion disposition NSURLCredential * _Nullable credential))completionHandler; //当applicaton 接收到application handleEvnetsForBackgroundURLSession:completionHandler 的消息的时候 // 会话的代理会接受到这个消息来 处理后台消息 -(void)URLSessionDidFinisheEventsForBackgroundURLSession:(NSURLSession*)session; NSURLSessionTaskDelegate// 网络请求重定向的时候 执行的操作 我们必须设置一个新的Request 然后传入到comoletionHandler中的request中 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler; // task接受到一个用户认证的请求，如果这个代理没有被实现的话，会话的认证将不会被调用 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler; // 如果task的请求需要一个新的bodyStream的时候会调用 当认证请求失败时候，我们可以通过这个代理重新弄个bodyStream来实现 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream * _Nullable bodyStream))completionHandler; // 当上传数据的时候，会调用这个代理 主要是针对upload的请求的时候，可以获取到上传的进度 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend; // 当一个任务完成后，无论失败或者成功都会调用这个代理 如果成功的话 error 为nil - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error; NSURLSessionDataTaskDelegate//当一个task接受到返回的消息，当所有的信息都接受完毕后completionHanler会被调用。我们可以在这里取消一个请求或者将一个data的任务改为下载的task.如果你没有实现这个dialing，我们可以通过task的response属性获取对应的数据 后台模式中uploadtask不会调用给这个代理 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler; // 一个dataTask 变为downloadTask - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask; //当datatask可以用的时候，我们可以在这里获取data的数据 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data; // 缓存completionHandler缓存data 或者传入nil 不需要缓存 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler; NSURLSessionDownloadTaskDelegate// 当一个\bdownloadTask 任务完成后我们可以通过给的location 的路径值来保存文件或者移动文件 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location; // 获取下载的进度 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite; // 断点下载的操作 NSURLSessionDownloadTaskResumeData 这个字段里会告诉你 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;","categories":[],"tags":[{"name":"iOS  NSURLSession","slug":"iOS-NSURLSession","permalink":"http://yoursite.com/tags/iOS-NSURLSession/"}]},{"title":"iOS性能优化总结","slug":"iOS-youhua-detail","date":"2018-04-17T09:33:47.000Z","updated":"2018-04-23T10:03:10.000Z","comments":true,"path":"2018/04/17/iOS-youhua-detail/","link":"","permalink":"http://yoursite.com/2018/04/17/iOS-youhua-detail/","excerpt":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。","text":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。 首先思考问题： 为什么要性能优化？ 性能优化主要是针对哪些方法的优化？ 发现问题 问题的发现目前主要还是依靠的是工具来进行发现。因为这样比较直观而且也有利于我们能够发现具体问题产生的地方，以便于我们队问题的解决。要不然我们都知道有问题，但是问题具体原因在哪里查不出来的话，这样的意义就小多了。当然最主要的还是用户体验方面能够感受到性能的问题，如果存在卡顿，或者闪退什么的，这样的体验就low了。所以问题一个是来自于用户的反馈还有就是测试人员或者开发人员一些体验的感受。 好了废话不多说：直接上工具 MLeakFinder 内存检测工具FPS性能检测工具 内存检测 内存分为内存泄露和内存开销 FPS监控 解决问题优化业务流程合理的线程分配预处理和延时加载缓存正确API的使用预防问题","categories":[],"tags":[{"name":"iOS 优化","slug":"iOS-优化","permalink":"http://yoursite.com/tags/iOS-优化/"}]},{"title":"iOS RunLoop 深入理解","slug":"iOS-RunLoop-detail","date":"2018-04-09T10:23:53.000Z","updated":"2018-04-13T10:40:16.000Z","comments":true,"path":"2018/04/09/iOS-RunLoop-detail/","link":"","permalink":"http://yoursite.com/2018/04/09/iOS-RunLoop-detail/","excerpt":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关","text":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关 RunLoop 概念正常情况下一个线程只能执行一个任务，当任务完成了，线程也就退出了。那么如何才能确保我们的线程能够随时能够处理事件并且不退出，直到我们主动要求线程退出的时候就退出？ 答案是有的，这就是我们今天的主角：RunLoop 从字面意思上解析这是一个运行着的循环，我们大体实现下它的伪代码： function loop(){ initialize(); do{ var message = getMessage(); processMessage(message); }while{message != quit} } 从伪代码中我们可以大体的了解到其中的一些逻辑处理 首先由一个入口函数的操作，在这里采用do…while的操作，首先先从消息队列中获取消息，当然如果没有消息的话，这个循环也是会一直发生的，因为我们还没有发送quit的消息。同时在我们有一个消息到来的时候，我们可以获取对应的消息来做处理。 总而言之就是一个一直运行着的事件循环操作 iOS中的RunLoop在 iOS 中为我们提供了两个这样的对象：NSRunLLoop 和 CFRunLoopRef CFRunLoopRef 是在CoreFoundation 框架中的，提供了纯C函数的API,所有的API都是线程安全的 NSRunLoop 是基于CFRunLoopRef 的封装，提供了面向对象的API,但是这些API是线程不安全的 下面我们从源码中来分析RunLoop: void CFRunLoopRun(void){ int32_t result; do{ result = CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); }while(kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result) } 下面再来分析下 CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); 首先回去CurrentMode CFRunLoopModeRef CurrentMode = __CFRunLoopFindMode(r1,modelName,false); 然后对currentMode进行判断 判断其是否存在或者是否为空 if(currentMode == NULL || __CFRunLoopModelIsEmpty){ return finish;//返回完成 就退出了runloop } 这里就是RunLoop结束的一个很重要的因素 下面我们在看看其中最重要的部分： if(currentMode-&gt;observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopEntry); result = __CFRunLoopRun(r1,currentMode,seconds,returnAfterSourceHandled,previousMode); if(currentMode-&gt;observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopExit); 下面借鉴网上的博客资源分析下：（采用伪代码）参照 int32_t __CFRunLoopRun(){ //通知即将进入runloop __CFRunLoopDoObservers(kCFRunLoopEntry); do{ //通知将要处理timer和source __CFRunLoopDoObservers(kcfrunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); //处理非延迟的主线程调用 __CFRunLoopDoBlocks(); //处理source0事件 __CFRunLoopDoSource0(); if(sourceHandledThisRoop){ __CFRunLoopDoBlocks(); } //如果有Source1 (基于Port) 处于ready状态，直接处理这个Source1 然后跳转去处理消息 if(__Source0DidDispatchProtLastTime){ Boolean hasMsg = __CFRunLoopServiceMachPort(); if(hasMsg){ goto handle_msg; } } //通知 Observers 线程即将进入休眠 if(!sourceHandledThisRoop){ __CFRunLoopDoObservers(runloop,currentMode,KCFrunLoopBeforeWaiting); } //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); //即将进入休眠 __CFRunLoopDoObservers(KCFrunLoopBeforeWaiting); //等待内核mach_msg事件 mach_port_t weakUpPort =","categories":[],"tags":[{"name":"iOS RunLoop","slug":"iOS-RunLoop","permalink":"http://yoursite.com/tags/iOS-RunLoop/"}]},{"title":"2018个人计划","slug":"what-to-do-for-2018","date":"2018-04-04T10:29:56.000Z","updated":"2018-04-04T01:23:11.000Z","comments":true,"path":"2018/04/04/what-to-do-for-2018/","link":"","permalink":"http://yoursite.com/2018/04/04/what-to-do-for-2018/","excerpt":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！","text":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！ 组件化的完善","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"iOS中Block的运用","slug":"block-use-method","date":"2018-04-04T02:06:28.000Z","updated":"2018-04-23T10:23:55.000Z","comments":true,"path":"2018/04/04/block-use-method/","link":"","permalink":"http://yoursite.com/2018/04/04/block-use-method/","excerpt":"摘要： 关于block的简单描述和使用概述","text":"摘要： 关于block的简单描述和使用概述 block的概述 Block：带有自动变量的匿名函数匿名函数：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域 语法： 声明： 返回值(^名称)(参数列表) typedef int(^ClickBlock)(NSUInteger); -(void)justAClick(ClickBlock)block{ NSLog(@&quot;Param:%@&quot;,block); } 定义： ^返回值类型(参数列表){表达式} ^(NSUInteger count){ //这里是代码展示区 return count + 1; } 自动变量 Block可以截获所使用的自动变量的值； 截获：保存自动变量的瞬间值 因为是瞬间值，所以Block之后，即便Block外面修改自动变量的值，也不会对Block内部有影响 如果需要对其的改变也会对变量产生影响的话，需要在变量的前面增加 __block block的运用 在我们的代码中，经常会用到block，其中涉及到了很多方面，下面我们将列举一些比较常见的用法和大家分享。分别是链式编程、返回参数、获取信息等。如果后续还有新的会增加。 链式编程这个在我们很多地方我们应该都能够看到（这里针对OC），比如Masonry,还有BabyBluetooth的使用方面都会涉及到链式编程 Masonry: make.top.equalto(self).offset(100); BabyBluetooth: baby.connecttoPeripherals().start(); 这样给人的感觉相对比较流畅和简洁很多。 首先先针对点式操作： 在OC中点语法就是一种语法糖，最终会调用对用属性的getter/setter的方法。 -(NSString*)hello{ return @&quot;hello&quot;; } self.hello; //会报 Property Access result unused; 我们让它的结果利用就来就不会报警告了 OK,针对点语法我们已经大概了解了，下面就针对链式中，为什么能够实现链式呢？ 这就得从返回值上做文章了，首先我们可以肯定返回值肯定是自身，要不然的话，就无法调用后续的函数进行操作了。 -(Test*)hello{ return self; } self.hello.hello; 这时候如果我们需要附带参数要如何实现： 很简单 block 动起来 -(Test*(^)(NSString*))hello{ return ^(NSString* str){ self.hello = str; return self; } } self.hello(@&quot;hello&quot;).hello(@&quot;str&quot;); NSLog(self.hello); 返回参数 参数的返回：很容易理解，就应该是利用返回值，来做判断的操作，或者利用返回值的数据，来进行一些操作。比如我们比较常用的UITabelView中针对Deletege 中的很多 比如rowCount //tableViewItem typedef NSUInteger (^CellCountBlock)(void); -(void)tableViewConfig{ if(self.CellCountBlock){ NSUInteger countNum = self.CellCountBlock(); NSLog(@&quot;the countNum is %d&quot;,countNum); } } //ViewController [tableViewItem tableViewConfig]; tableViewItem.CellCountBlock = ^{ return 10; } 当然这里我们也可以采用链式编程的方式来进行！ 获取信息 信息的获取：我们主要是在文件上传的时候可以看到关于fromData的拼接 - (NSMutableURLRequest*)multipartFormRequestWithMethod:(NSString*)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error { __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (block) { block(formData); } return [formData requestByFinalizingMultipartFormData]; } 这里将重要的代码贴出来： 这里的formData 数据是将数据的拼接防盗调用方进行拼接的，拼接完成后再将数据进行上传操作 所以这里的formData就是我们的重点 -(void)tableViewConfig:(void(^)(NSDictionary *))configBlock{ __block NSMutableDictionary *config = [NSMutableDictionary dictionaryWithCapacity:0]; if (configBlock) { configBlock(config); } NSLog(@&quot;the config is %@&quot;,config); } //使用 [[GYEBleManager shareManager] tableViewConfig:^(NSDictionary *config) { [config setValue:@&quot;hello&quot; forKey:@&quot;key&quot;]; }]; //结果： the config is { key = hello; } 链接： https://www.wangjiawen.com/ios/ios-block-usage-and-implementation https://www.jianshu.com/p/23c1bbe3c99d","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"MarkDown 的基础使用","slug":"Markdown-leaning","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-23T10:03:14.000Z","comments":true,"path":"2018/03/29/Markdown-leaning/","link":"","permalink":"http://yoursite.com/2018/03/29/Markdown-leaning/","excerpt":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------","text":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------ 使用#来表示字号，可以使用1-6级标题来进行表示 #一级标题##二级标题###三级标题 效果： 一级标题二级标题三级标题四级标题五级标题 段落 段落的前后需要有空行，所谓的空行是指没有文字的内容，使用两个以上的空格加上回车键就可以达到段落的效果 区块的操作在段落的每行或者只要在第一行中使用符号&gt;就可以使用区块，当然还可以使用多个嵌套 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符 void main(){ printf(&quot;hello world&quot;); } 代码区块 需要和普通的段落之间存在空行 强调在强调的内容两侧分别加上*或者_,比如： *斜体* **加粗**_斜体_ __加粗__ 效果： 斜体 _斜体_ 加粗 加粗 列表使用*、+、-这几个号码来进行列表 第一项 第二项 第三项 分割线采用三个或者三个以上的*,_,-就可以构建分割线了 链接链接有两种形式生成：行内式和参考式 [链接](http://www.baidu.com) 这就是是链接的使用方式了 图片添加图片的形式和链接的形式相似，值需要在链接的基础上前方加上一个！就可以了 ![alt text](/path/to/img.jpg) 下面阐述下这个： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着是一个普通括号，里面放上图片的网址，左后要用 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其他意义的符号，可以利用反斜杠来显示一些在markdown中存在语法的字符","categories":[],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"如何构建一个Github的博客","slug":"how-to-build-github-blog","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-04T01:26:00.000Z","comments":true,"path":"2018/03/29/how-to-build-github-blog/","link":"","permalink":"http://yoursite.com/2018/03/29/how-to-build-github-blog/","excerpt":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你","text":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你 这里先列出大概的要点： Git的安装 Node.js的安装 Hexo 的安装和配置 Hexo 的发布和测试 Git安装 这里暂时没有涉及到后续补充 Node.js的安装Hexo的安装和配置Hexo 的安装npm install -g hexo-cli //全局安装hexo的客户端 如果不成功的话可以加上sudo 当这个执行成功后可以使用 hexo -v //查看是否安装成功 hexo 的初始化hexo init //这里可以针对具体的文件夹进行初始化操作 npm install //安装相对应的依赖包 hexo 框架简介 当hexo init 执行完成后，在当前的文件夹会增加框架的目录结构： _config.yml //网站的配置信息 package.json //项目包信息 scaffolds //模板文件夹，hexo 根据scaffold中的模板来新建文件 source //存放用户资源的地方 _drafts //存放草稿的地方_posts //存放发布的文件 themes //主题文件夹 hexo 简单配置首先我们需要打开_config.yml文件,这里是hexo的主要配置文件： 这里可以参考Hexo配置 title: lmzqm //网站标题 subtitle: iOS 开发者 //网站副标题 description: just do it //网站描述 keywords: //网站的关键字 author: lmzqm //您的名字 language: zh-CN //网站使用的语言 timezone: Asia/Shanghai //网站时区 hexo 命令下面简单介绍下hexo的命令： hexo generate //简写 hexo g 生成静态文件，会在当前的目录下生成一个新的public的文件夹 hexo server // 简写 hexo s 启动本地服务器，通过http://localhost:4000进行访问 hexo deploy // 简写 hexo d 部署到远程，在_config.yml中配置 hexo new post-name //简写 hexo n post-name 新建文章 hexo new page page-name //简写 hexo n page page-name 新建页面 会在Source下新建一个相对应的目录 组合命令： hexo s -g //生成和预览 hexo d -g //生成和部署 草稿命令： hexo new draft &lt;title&gt; //新建草稿，存放在source/_drafts hexo public post &lt;title&gt; //发布操作草稿文章，文章将转移到source/_posts hexo s -g // 可以开始进行预览操作 部署到GitHub pages 部署Hexo到GitHub 指的是将hexo -g生成的静态文件推送到github 对应的仓库中 因此我们需要在我们GitHub中做好相对应的准备 首先需要明确的是： 每一个github的账号都有一个GitHub的pages; 一个账号只能创建一个repository来存放GitHub pages; 仓库的名字必须是username/username.github.io 这是固定的命名约定 然后就可以通过 https://username.github.io 来进行访问 GitHub 创建的个人主页内容是在master分支下的 当你在你的github下创建了这个repository后，就可以在本地 先安装一个扩展： npm install hexo-deployer-git --save 修改 _config.yml中的配置： deploy: type:git repo:https://github.com/username/username.github.io.git branch:master 这样的话就可以通过执行 hexo d -g 将静态网站提交到github网站上 hexo 主题首先关于hexo的主题可以在github中进行查找，很方便就能找到一些主题，然后可以选择你所需要的主题，关于主题内部的具体配置，可以参照具体的网站来进行配置。 hexo clean //clean remove generated files and cache 然后就可以选择你自己想要的主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这个完成后需要在根目录下的_config.yml中将主题变换成我们现在的主题： theme: yilia 这时候在theme的文件夹下就可以就会多出一个文件夹yilia着是主题的文件夹，进入后可以用git来进行操作，切换tag来针对不同的版本，当然对于不同版本的具体要求对应的网站上去查看下详情会比较好理解 后期针对主题的设置，我们需要进入到相对应主题当中的_config.yml文件进行配置 这个可以在网上找到很多信息 后期我们再专门弄个文章来进行阐述，这里就暂时先简单描述","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]}]}