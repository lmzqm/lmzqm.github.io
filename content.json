{"meta":{"title":"lmzqm","subtitle":"iOS 开发者","description":"just do it","author":"lmzqm","url":"http://yoursite.com"},"pages":[{"title":"iOS","date":"2018-04-02T01:49:22.000Z","updated":"2018-04-02T01:49:22.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS性能优化总结","slug":"iOS-youhua-detail","date":"2018-04-17T09:33:47.000Z","updated":"2018-04-23T10:03:10.000Z","comments":true,"path":"2018/04/17/iOS-youhua-detail/","link":"","permalink":"http://yoursite.com/2018/04/17/iOS-youhua-detail/","excerpt":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。","text":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。 首先思考问题： 为什么要性能优化？ 性能优化主要是针对哪些方法的优化？ 发现问题 问题的发现目前主要还是依靠的是工具来进行发现。因为这样比较直观而且也有利于我们能够发现具体问题产生的地方，以便于我们队问题的解决。要不然我们都知道有问题，但是问题具体原因在哪里查不出来的话，这样的意义就小多了。当然最主要的还是用户体验方面能够感受到性能的问题，如果存在卡顿，或者闪退什么的，这样的体验就low了。所以问题一个是来自于用户的反馈还有就是测试人员或者开发人员一些体验的感受。 好了废话不多说：直接上工具 MLeakFinder 内存检测工具FPS性能检测工具 内存检测 内存分为内存泄露和内存开销 FPS监控 解决问题优化业务流程合理的线程分配预处理和延时加载缓存正确API的使用预防问题","categories":[],"tags":[{"name":"iOS 优化","slug":"iOS-优化","permalink":"http://yoursite.com/tags/iOS-优化/"}]},{"title":"iOS RunLoop 深入理解","slug":"iOS-RunLoop-detail","date":"2018-04-09T10:23:53.000Z","updated":"2018-04-13T10:40:16.000Z","comments":true,"path":"2018/04/09/iOS-RunLoop-detail/","link":"","permalink":"http://yoursite.com/2018/04/09/iOS-RunLoop-detail/","excerpt":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关","text":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关 RunLoop 概念正常情况下一个线程只能执行一个任务，当任务完成了，线程也就退出了。那么如何才能确保我们的线程能够随时能够处理事件并且不退出，直到我们主动要求线程退出的时候就退出？ 答案是有的，这就是我们今天的主角：RunLoop 从字面意思上解析这是一个运行着的循环，我们大体实现下它的伪代码： function loop(){ initialize(); do{ var message = getMessage(); processMessage(message); }while{message != quit} } 从伪代码中我们可以大体的了解到其中的一些逻辑处理 首先由一个入口函数的操作，在这里采用do…while的操作，首先先从消息队列中获取消息，当然如果没有消息的话，这个循环也是会一直发生的，因为我们还没有发送quit的消息。同时在我们有一个消息到来的时候，我们可以获取对应的消息来做处理。 总而言之就是一个一直运行着的事件循环操作 iOS中的RunLoop在 iOS 中为我们提供了两个这样的对象：NSRunLLoop 和 CFRunLoopRef CFRunLoopRef 是在CoreFoundation 框架中的，提供了纯C函数的API,所有的API都是线程安全的 NSRunLoop 是基于CFRunLoopRef 的封装，提供了面向对象的API,但是这些API是线程不安全的 下面我们从源码中来分析RunLoop: void CFRunLoopRun(void){ int32_t result; do{ result = CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); }while(kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result) } 下面再来分析下 CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); 首先回去CurrentMode CFRunLoopModeRef CurrentMode = __CFRunLoopFindMode(r1,modelName,false); 然后对currentMode进行判断 判断其是否存在或者是否为空 if(currentMode == NULL || __CFRunLoopModelIsEmpty){ return finish;//返回完成 就退出了runloop } 这里就是RunLoop结束的一个很重要的因素 下面我们在看看其中最重要的部分： if(currentMode-&gt;observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopEntry); result = __CFRunLoopRun(r1,currentMode,seconds,returnAfterSourceHandled,previousMode); if(currentMode-&gt;observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopExit); 下面借鉴网上的博客资源分析下：（采用伪代码）参照 int32_t __CFRunLoopRun(){ //通知即将进入runloop __CFRunLoopDoObservers(kCFRunLoopEntry); do{ //通知将要处理timer和source __CFRunLoopDoObservers(kcfrunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); //处理非延迟的主线程调用 __CFRunLoopDoBlocks(); //处理source0事件 __CFRunLoopDoSource0(); if(sourceHandledThisRoop){ __CFRunLoopDoBlocks(); } //如果有Source1 (基于Port) 处于ready状态，直接处理这个Source1 然后跳转去处理消息 if(__Source0DidDispatchProtLastTime){ Boolean hasMsg = __CFRunLoopServiceMachPort(); if(hasMsg){ goto handle_msg; } } //通知 Observers 线程即将进入休眠 if(!sourceHandledThisRoop){ __CFRunLoopDoObservers(runloop,currentMode,KCFrunLoopBeforeWaiting); } //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); //即将进入休眠 __CFRunLoopDoObservers(KCFrunLoopBeforeWaiting); //等待内核mach_msg事件 mach_port_t weakUpPort =","categories":[],"tags":[{"name":"iOS RunLoop","slug":"iOS-RunLoop","permalink":"http://yoursite.com/tags/iOS-RunLoop/"}]},{"title":"2018个人计划","slug":"what-to-do-for-2018","date":"2018-04-04T10:29:56.000Z","updated":"2018-04-04T01:23:11.000Z","comments":true,"path":"2018/04/04/what-to-do-for-2018/","link":"","permalink":"http://yoursite.com/2018/04/04/what-to-do-for-2018/","excerpt":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！","text":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！ 组件化的完善","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"iOS中Block的运用","slug":"block-use-method","date":"2018-04-04T02:06:28.000Z","updated":"2018-04-23T10:23:55.000Z","comments":true,"path":"2018/04/04/block-use-method/","link":"","permalink":"http://yoursite.com/2018/04/04/block-use-method/","excerpt":"摘要： 关于block的简单描述和使用概述","text":"摘要： 关于block的简单描述和使用概述 block的概述 Block：带有自动变量的匿名函数匿名函数：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域 语法： 声明： 返回值(^名称)(参数列表) typedef int(^ClickBlock)(NSUInteger); -(void)justAClick(ClickBlock)block{ NSLog(@&quot;Param:%@&quot;,block); } 定义： ^返回值类型(参数列表){表达式} ^(NSUInteger count){ //这里是代码展示区 return count + 1; } 自动变量 Block可以截获所使用的自动变量的值； 截获：保存自动变量的瞬间值 因为是瞬间值，所以Block之后，即便Block外面修改自动变量的值，也不会对Block内部有影响 如果需要对其的改变也会对变量产生影响的话，需要在变量的前面增加 __block block的运用 在我们的代码中，经常会用到block，其中涉及到了很多方面，下面我们将列举一些比较常见的用法和大家分享。分别是链式编程、返回参数、获取信息等。如果后续还有新的会增加。 链式编程这个在我们很多地方我们应该都能够看到（这里针对OC），比如Masonry,还有BabyBluetooth的使用方面都会涉及到链式编程 Masonry: make.top.equalto(self).offset(100); BabyBluetooth: baby.connecttoPeripherals().start(); 这样给人的感觉相对比较流畅和简洁很多。 首先先针对点式操作： 在OC中点语法就是一种语法糖，最终会调用对用属性的getter/setter的方法。 -(NSString*)hello{ return @&quot;hello&quot;; } self.hello; //会报 Property Access result unused; 我们让它的结果利用就来就不会报警告了 OK,针对点语法我们已经大概了解了，下面就针对链式中，为什么能够实现链式呢？ 这就得从返回值上做文章了，首先我们可以肯定返回值肯定是自身，要不然的话，就无法调用后续的函数进行操作了。 -(Test*)hello{ return self; } self.hello.hello; 这时候如果我们需要附带参数要如何实现： 很简单 block 动起来 -(Test*(^)(NSString*))hello{ return ^(NSString* str){ self.hello = str; return self; } } self.hello(@&quot;hello&quot;).hello(@&quot;str&quot;); NSLog(self.hello); 返回参数 参数的返回：很容易理解，就应该是利用返回值，来做判断的操作，或者利用返回值的数据，来进行一些操作。比如我们比较常用的UITabelView中针对Deletege 中的很多 比如rowCount //tableViewItem typedef NSUInteger (^CellCountBlock)(void); -(void)tableViewConfig{ if(self.CellCountBlock){ NSUInteger countNum = self.CellCountBlock(); NSLog(@&quot;the countNum is %d&quot;,countNum); } } //ViewController [tableViewItem tableViewConfig]; tableViewItem.CellCountBlock = ^{ return 10; } 当然这里我们也可以采用链式编程的方式来进行！ 获取信息 信息的获取：我们主要是在文件上传的时候可以看到关于fromData的拼接 - (NSMutableURLRequest*)multipartFormRequestWithMethod:(NSString*)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error { __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (block) { block(formData); } return [formData requestByFinalizingMultipartFormData]; } 这里将重要的代码贴出来： 这里的formData 数据是将数据的拼接防盗调用方进行拼接的，拼接完成后再将数据进行上传操作 所以这里的formData就是我们的重点 -(void)tableViewConfig:(void(^)(NSDictionary *))configBlock{ __block NSMutableDictionary *config = [NSMutableDictionary dictionaryWithCapacity:0]; if (configBlock) { configBlock(config); } NSLog(@&quot;the config is %@&quot;,config); } //使用 [[GYEBleManager shareManager] tableViewConfig:^(NSDictionary *config) { [config setValue:@&quot;hello&quot; forKey:@&quot;key&quot;]; }]; //结果： the config is { key = hello; } 链接： https://www.wangjiawen.com/ios/ios-block-usage-and-implementation https://www.jianshu.com/p/23c1bbe3c99d","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"MarkDown 的基础使用","slug":"Markdown-leaning","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-23T10:03:14.000Z","comments":true,"path":"2018/03/29/Markdown-leaning/","link":"","permalink":"http://yoursite.com/2018/03/29/Markdown-leaning/","excerpt":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------","text":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------ 使用#来表示字号，可以使用1-6级标题来进行表示 #一级标题##二级标题###三级标题 效果： 一级标题二级标题三级标题四级标题五级标题 段落 段落的前后需要有空行，所谓的空行是指没有文字的内容，使用两个以上的空格加上回车键就可以达到段落的效果 区块的操作在段落的每行或者只要在第一行中使用符号&gt;就可以使用区块，当然还可以使用多个嵌套 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符 void main(){ printf(&quot;hello world&quot;); } 代码区块 需要和普通的段落之间存在空行 强调在强调的内容两侧分别加上*或者_,比如： *斜体* **加粗**_斜体_ __加粗__ 效果： 斜体 _斜体_ 加粗 加粗 列表使用*、+、-这几个号码来进行列表 第一项 第二项 第三项 分割线采用三个或者三个以上的*,_,-就可以构建分割线了 链接链接有两种形式生成：行内式和参考式 [链接](http://www.baidu.com) 这就是是链接的使用方式了 图片添加图片的形式和链接的形式相似，值需要在链接的基础上前方加上一个！就可以了 ![alt text](/path/to/img.jpg) 下面阐述下这个： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着是一个普通括号，里面放上图片的网址，左后要用 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其他意义的符号，可以利用反斜杠来显示一些在markdown中存在语法的字符","categories":[],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"如何构建一个Github的博客","slug":"how-to-build-github-blog","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-04T01:26:00.000Z","comments":true,"path":"2018/03/29/how-to-build-github-blog/","link":"","permalink":"http://yoursite.com/2018/03/29/how-to-build-github-blog/","excerpt":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你","text":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你 这里先列出大概的要点： Git的安装 Node.js的安装 Hexo 的安装和配置 Hexo 的发布和测试 Git安装 这里暂时没有涉及到后续补充 Node.js的安装Hexo的安装和配置Hexo 的安装npm install -g hexo-cli //全局安装hexo的客户端 如果不成功的话可以加上sudo 当这个执行成功后可以使用 hexo -v //查看是否安装成功 hexo 的初始化hexo init //这里可以针对具体的文件夹进行初始化操作 npm install //安装相对应的依赖包 hexo 框架简介 当hexo init 执行完成后，在当前的文件夹会增加框架的目录结构： _config.yml //网站的配置信息 package.json //项目包信息 scaffolds //模板文件夹，hexo 根据scaffold中的模板来新建文件 source //存放用户资源的地方 _drafts //存放草稿的地方_posts //存放发布的文件 themes //主题文件夹 hexo 简单配置首先我们需要打开_config.yml文件,这里是hexo的主要配置文件： 这里可以参考Hexo配置 title: lmzqm //网站标题 subtitle: iOS 开发者 //网站副标题 description: just do it //网站描述 keywords: //网站的关键字 author: lmzqm //您的名字 language: zh-CN //网站使用的语言 timezone: Asia/Shanghai //网站时区 hexo 命令下面简单介绍下hexo的命令： hexo generate //简写 hexo g 生成静态文件，会在当前的目录下生成一个新的public的文件夹 hexo server // 简写 hexo s 启动本地服务器，通过http://localhost:4000进行访问 hexo deploy // 简写 hexo d 部署到远程，在_config.yml中配置 hexo new post-name //简写 hexo n post-name 新建文章 hexo new page page-name //简写 hexo n page page-name 新建页面 会在Source下新建一个相对应的目录 组合命令： hexo s -g //生成和预览 hexo d -g //生成和部署 草稿命令： hexo new draft &lt;title&gt; //新建草稿，存放在source/_drafts hexo public post &lt;title&gt; //发布操作草稿文章，文章将转移到source/_posts hexo s -g // 可以开始进行预览操作 部署到GitHub pages 部署Hexo到GitHub 指的是将hexo -g生成的静态文件推送到github 对应的仓库中 因此我们需要在我们GitHub中做好相对应的准备 首先需要明确的是： 每一个github的账号都有一个GitHub的pages; 一个账号只能创建一个repository来存放GitHub pages; 仓库的名字必须是username/username.github.io 这是固定的命名约定 然后就可以通过 https://username.github.io 来进行访问 GitHub 创建的个人主页内容是在master分支下的 当你在你的github下创建了这个repository后，就可以在本地 先安装一个扩展： npm install hexo-deployer-git --save 修改 _config.yml中的配置： deploy: type:git repo:https://github.com/username/username.github.io.git branch:master 这样的话就可以通过执行 hexo d -g 将静态网站提交到github网站上 hexo 主题首先关于hexo的主题可以在github中进行查找，很方便就能找到一些主题，然后可以选择你所需要的主题，关于主题内部的具体配置，可以参照具体的网站来进行配置。 hexo clean //clean remove generated files and cache 然后就可以选择你自己想要的主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这个完成后需要在根目录下的_config.yml中将主题变换成我们现在的主题： theme: yilia 这时候在theme的文件夹下就可以就会多出一个文件夹yilia着是主题的文件夹，进入后可以用git来进行操作，切换tag来针对不同的版本，当然对于不同版本的具体要求对应的网站上去查看下详情会比较好理解 后期针对主题的设置，我们需要进入到相对应主题当中的_config.yml文件进行配置 这个可以在网上找到很多信息 后期我们再专门弄个文章来进行阐述，这里就暂时先简单描述","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]}]}