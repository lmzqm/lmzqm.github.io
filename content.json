{"meta":{"title":"lmzqm","subtitle":"iOS 开发者","description":"just do it","author":"lmzqm","url":"http://yoursite.com"},"pages":[{"title":"iOS","date":"2018-04-02T01:49:22.000Z","updated":"2018-04-02T01:49:22.000Z","comments":true,"path":"iOS/index.html","permalink":"http://yoursite.com/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式","slug":"design-create-model","date":"2018-05-03T10:31:21.000Z","updated":"2018-05-04T02:06:13.000Z","comments":true,"path":"2018/05/03/design-create-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-create-model/","excerpt":"摘要\b：设计模式分为三大类 创建型模式 结构型模式 行为型模式","text":"摘要\b：设计模式分为三大类 创建型模式 结构型模式 行为型模式 创建型模式创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对这些对象只需要指定他们共同的接口，而不需要知道具体的实现细节，使整个系统设计更加符合单一职责的原则 简单工厂模式 （simple Factory） 工厂方法模式 （Factory Method） 抽象工厂模式 （Abstract Factory） 建造者模式 （Builder） 原型模式 （Prototype） 单例模式 （Singletion） 结构型模式","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式 开篇——读懂UML类图和时序图","slug":"design-model","date":"2018-05-03T09:38:58.000Z","updated":"2018-05-03T10:31:27.000Z","comments":true,"path":"2018/05/03/design-model/","link":"","permalink":"http://yoursite.com/2018/05/03/design-model/","excerpt":"摘要： 这里主要是记录对设计模式的学习的过程，会出一个系列的文章。敬请期待。","text":"摘要： 这里主要是记录对设计模式的学习的过程，会出一个系列的文章。敬请期待。 首先从一个实例开始 车的类图结构为&lt;&gt;,表示车是一个抽象类; 它有两个继承类：小汽车和自行车； 它们之间的关系为\b实现关系，使用带空心箭头的虚线表示 小汽车和SUV之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示 小汽车和发动机之间属于组合关系，使用带\b实心箭头的实线表示 学生和班级之间属于聚合关系，使用带空心箭头的实线表示 学生和身份证之间是关联关系，使用一根实线表示 学生上学需要自行车，与自行车是一种依赖关系，使用带箭头的虚线表示 类之间的关系泛化关系 类的继承结构在UML中表示为：泛华，实现 继承关系表示is-a的关系 表示是的关系 在UML中用时一个空心实线箭头表示 在最终的代码中，泛化关系表现为继承非抽象 \b实现关系 实现关系用一条空心箭头的虚线表示 eg:”车”是一个抽象概念，在现实中无法直接用来定义对象，只有指明具体的子类才可以用来定义对象 在最终代码中，实现关系表现为继承抽象类 聚合关系 聚合关系用一条带空心菱形箭头直线表示，表示A聚合到B上，或者说B是由A组成的 聚合关系用于表示实体对象之间的关系，表示整体由部分构成 与组合关系不同的是，整体和部分不是强依赖，即使整体不存在了，部分任然粗壮 组合关系 组合关系用一条带实心菱形箭头直线表示 与聚合关系一样，组合关系表示整体由部分构成的语义 但是组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在 关联关系 关联关系用一条直线表示 描述不同类的对象之间的结构关系，它是一种\b静态关系，通常与运行的状态无关，一般由常识因素决定；它一般用来定义对象之间静态的，天然的结构；所有关联关系是一种强关联的关系 在最终代码中，关联对象同时是以成员变量的形式实现 依赖关系 依赖关系是一套带箭头的虚线表示的， 与关联关系不同的是，他是一种临时性的关系，通常发生在运行期间产生，并且随着运行时的变化，依赖关系也可能发生改变 显然依赖也是有方向的，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生 在最终的代码中，依赖关系体现为类构造方法以及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方还是使用对方的方法和属性 时序图 对象之间交互的图，这些对象是按时间顺序排列的，时序图中显示的是参与交互对象以及对象之间消息交互的顺序 时序图包括对象主要有：对象（actor）生命线（Lifeline）控制焦点（Focus of control）消息（Message）等待","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"iOS-AFNetworking-AFURLSessionManager","slug":"iOS-AFNetworking-AFURLSessionManager","date":"2018-05-03T07:45:33.000Z","updated":"2018-05-03T07:45:33.000Z","comments":true,"path":"2018/05/03/iOS-AFNetworking-AFURLSessionManager/","link":"","permalink":"http://yoursite.com/2018/05/03/iOS-AFNetworking-AFURLSessionManager/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS NSURLSession 解析","slug":"NSURLSESSION-Detail","date":"2018-04-24T09:04:38.000Z","updated":"2018-05-03T07:40:45.000Z","comments":true,"path":"2018/04/24/NSURLSESSION-Detail/","link":"","permalink":"http://yoursite.com/2018/04/24/NSURLSESSION-Detail/","excerpt":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。","text":"摘要： 关于NSUrlSession在网络的过程中我们经常会使用到这个，通过创建一个网络的会话，然后通过会话来实现一些任务。所以在针对iOS的网络操作中NSURLSession的熟悉是必不可少的。当然其也是比较简单，没有那么复杂。 一个简单的例子这里构建一个简单的请求的例子 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:smallPic]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc]init]]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request]; [dataTask resume]; 从上的代码中我们可以大体的分析下，一个网络请求的过程中，我们分别需要的角色： NSURLRequest ：一个网络请求 NSURLSession ： 一个会话 NSURLSessionConfiguration ： 会话的配置项 NSURLSessionDataTask : 会话中的任务 一个会话需要会话的配置信息来进行创建，其中还存在着线程队列已经代理的设置一个任务是会话通过请求的信息来进行创建，创建出来的任务只有执行resume后才开始执行任务 下面我们将通过对这个所需的元素进行一一分析，来进一步的了解他们之间的关系，已经各个元素的一些属性和方法。 首先针对AFNetworking的扩展，其实它的核心也是一个最基础的网络请求操作，后续再对这个简单的操作进行扩展，这样就会慢慢的可以通过用户添加一些block来对函数进行一些自定义的一些操作，这些都是后话。后期的话，我会针对AFNetworking进行源码解析，同时也希望自己能够写出实现自己的网络框架。 NSURLRequest在iOS中关于请求的操作，其基类都是NSURLReqeust 当然还有一个可变的NSMutableURLReqeust当然对于可变和不可变的特性相对大家都已经比较理解了。下面我们来创建一个最基础的reqeust [[NSURLRequest alloc] initWithURL:@&quot;url&quot;]; 最简单的组成就是一个url来创建，当然它还有一些特性，这些特性针对URLReqeust更多的是可读的属性但是对可变的URLRequest则是可读可写的 创建实例对象：类方法： //通过url来进行创建 +(instancetype)requestWithURL:(NSURL*)URL; // 通过url 以及缓存策略 还有网络超时时长来进行创建 +(instancetype)requestWithURL:(NSURL*)URL cacehPolicy:(NSURLRequestCachePolicy)cachePolicy timeooutInterval:(NSTimeInterval)timeoutInterval; 实例方法： - (instancetype)initWithURL:(NSURL *)URL; // 通过实例方法创建 - (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval NS_DESIGNATED_INITIALIZER; 属性：@property (nullable, readonly, copy) NSURL *URL;// url @property (readonly) NSURLRequestCachePolicy cachePolicy;//缓存策略 @property (readonly) NSTimeInterval timeoutInterval;//网络请求超时时间 @property (nullable, readonly, copy) NSString *HTTPMethod;//请求的方法 有get post delete put 等等 @property (nullable, readonly, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields; //请求头中的字段所存放的字典 针对这字段有提供专门的方法来实现添加和查询的工作： - (nullable NSString *)valueForHTTPHeaderField:(NSString *)field;//根据字段名字查找对应的信息 - (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//这是直接设置对应的信息 - (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//这里是添加对应的信息 @property (nullable, copy) NSData *HTTPBody;//请求中的数据信息 也就是请求体重的信息 这些是主要用到的信息，如果后期还有的话，会慢慢添加的。 其实很多对网络特别是HTTP协议不是很理解的人，可能看得有点晕，没关系，这里我们贴下http的请求给大家看看就会便于理解了 GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 上面的代码中我们可以知道关于Request中的一些信息： url:img.mukewang.com/562f25980001b1b106000338.jpg HTTPMethod:GET 接下来就是请求头的一些字段： Accept : 表示客户端接受的一些格式 Accept-Encoding：接受的压缩格式 Accept-Language：接受的语言 NSURLSessionConfiguration关于会话的配置有三种模式： //默认模式 @property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration; // 临时会话模式 @property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration; //后台模式 + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0)); 属性// 一个后台会话的标识符 @property (nullable, readonly, copy) NSString *identifier; // 请求缓存策略 @property NSURLRequestCachePolicy requestCachePolicy; // 网络请求超时时长 @property NSTimeInterval timeoutIntervalForRequest; // 网络资源请求操作 @property NSTimeInterval timeoutIntervalForResource; // 网络请求服务类型 @property NSURLRequestNetworkServiceType networkServiceType; // 是否允许用蜂窝 @property BOOL allowsCellularAccess; // 添加额外的请求头 @property (nullable, copy) NSDictionary *HTTPAdditionalHeaders; NSURLSession 这个类是关于会话的创建，会话的使用，会话的调度等等 下面通过源代码来对这个类进一步了解： 创建// 通过会话配置来进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; // 通过会话配置 还有代理 已经多线程队列进行创建 +(NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue; 生成不同的TaskdataTask/* Creates a data task with the given request. The request may have a body stream. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request; /* Creates a data task to retrieve the contents of the given URL. */ - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url; uploadTask/* Creates an upload task with the given request. The body of the request will be created from the file referenced by fileURL */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL; /* Creates an upload task with the given request. The body of the request is provided from the bodyData. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData; /* Creates an upload task with the given request. The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */ - (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request; downTask/* Creates a download task with the given request. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request; /* Creates a download task to download the contents of the given URL. */ - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url; /* Creates a download task with the resume data. If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */ - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData; 直接带返回回调的task/* * data task convenience methods. These methods create tasks that * bypass the normal delegate calls for response and data delivery, * and provide a simple cancelable asynchronous interface to receiving * data. Errors will be returned in the NSURLErrorDomain, * see &lt;Foundation/NSURLError.h&gt;. The delegate, if any, will still be * called for authentication challenges. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * upload convenience method. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; /* * download task convenience methods. When a download successfully * completes, the NSURL will point to a file that must be read or * copied during the invocation of the completion routine. The file * will be removed automatically. */ - (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; - (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; 属性和方法属性：@property (readonly ,retain) NSOperationQueue *delegateQueue; @property (nullable,readonly,retain) id &lt;NSURLSessionDelegate&gt; delegate; @property (readonly ,copy) NSURLSessionConfiguration *configuration; //会话的描述 @property (nullable,copy) NSString *sessionDescription; 方法：//完成所有任务后，将会话无效 // returns immediately and existing tasks will be allowed to run to completion. New tasks may not be Created。The Session will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError: has been issued; -(void)finishTasksAndInvalidate; // 会话无效后取消操作 // issues cancel to all outstanding tasks for this session. -(void)invalidateAndCancel; //invoke completionHandler with outstanding data,upload and download tasks -(void)getTasksWithCompletionHandler:(void(^)(NSArray&lt;NSURLNSURLSessionDataTask*&gt;* dataTask,NSArray&lt;NSURLSessionUploadTask*&gt;* uploadTasks,NSArray&lt;NSURLSessionDownloadTask*&gt;*downloadTask))complcompletionHandler; 代理NSURLSessionDelegate// 这是会话接收最后一条消息 当会话遇到系统级的错误 获取当会话无效的时候 -(void)URLSession:(NSUrlSession*)session didBecomeInvalidWithError:(nullable NSError *)error; //当遇到需要用户权限验证的时候，或者HTTPS验证的时候会调用这个代理 -(void)URLSession:(NSURLSession*)session didReceiveChallenge:(NSURLAuthenticationChallenge*)challenge completionHandler:(void(^)(NSURLSessionAuthChallengeDispostion disposition NSURLCredential * _Nullable credential))completionHandler; //当applicaton 接收到application handleEvnetsForBackgroundURLSession:completionHandler 的消息的时候 // 会话的代理会接受到这个消息来 处理后台消息 -(void)URLSessionDidFinisheEventsForBackgroundURLSession:(NSURLSession*)session; NSURLSessionTaskDelegate// 网络请求重定向的时候 执行的操作 我们必须设置一个新的Request 然后传入到comoletionHandler中的request中 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler; // task接受到一个用户认证的请求，如果这个代理没有被实现的话，会话的认证将不会被调用 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler; // 如果task的请求需要一个新的bodyStream的时候会调用 当认证请求失败时候，我们可以通过这个代理重新弄个bodyStream来实现 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream * _Nullable bodyStream))completionHandler; // 当上传数据的时候，会调用这个代理 主要是针对upload的请求的时候，可以获取到上传的进度 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend; // 当一个任务完成后，无论失败或者成功都会调用这个代理 如果成功的话 error 为nil - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error; NSURLSessionDataTaskDelegate//当一个task接受到返回的消息，当所有的信息都接受完毕后completionHanler会被调用。我们可以在这里取消一个请求或者将一个data的任务改为下载的task.如果你没有实现这个dialing，我们可以通过task的response属性获取对应的数据 后台模式中uploadtask不会调用给这个代理 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler; // 一个dataTask 变为downloadTask - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask; //当datatask可以用的时候，我们可以在这里获取data的数据 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data; // 缓存completionHandler缓存data 或者传入nil 不需要缓存 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler; NSURLSessionDownloadTaskDelegate// 当一个\bdownloadTask 任务完成后我们可以通过给的location 的路径值来保存文件或者移动文件 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location; // 获取下载的进度 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite; // 断点下载的操作 NSURLSessionDownloadTaskResumeData 这个字段里会告诉你 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;","categories":[],"tags":[{"name":"iOS  NSURLSession","slug":"iOS-NSURLSession","permalink":"http://yoursite.com/tags/iOS-NSURLSession/"}]},{"title":"iOS性能优化总结","slug":"iOS-youhua-detail","date":"2018-04-17T09:33:47.000Z","updated":"2018-04-23T10:03:10.000Z","comments":true,"path":"2018/04/17/iOS-youhua-detail/","link":"","permalink":"http://yoursite.com/2018/04/17/iOS-youhua-detail/","excerpt":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。","text":"摘要： 性能优化是我们在软件开发中需要直面的难题。首先是因为性能优化不是一步就能到位的，其中涉及到很多的配合来进行。下面我将针对发现问题，解决问题，预防问题三个模块来进行阐述。 首先思考问题： 为什么要性能优化？ 性能优化主要是针对哪些方法的优化？ 发现问题 问题的发现目前主要还是依靠的是工具来进行发现。因为这样比较直观而且也有利于我们能够发现具体问题产生的地方，以便于我们队问题的解决。要不然我们都知道有问题，但是问题具体原因在哪里查不出来的话，这样的意义就小多了。当然最主要的还是用户体验方面能够感受到性能的问题，如果存在卡顿，或者闪退什么的，这样的体验就low了。所以问题一个是来自于用户的反馈还有就是测试人员或者开发人员一些体验的感受。 好了废话不多说：直接上工具 MLeakFinder 内存检测工具FPS性能检测工具 内存检测 内存分为内存泄露和内存开销 FPS监控 解决问题优化业务流程合理的线程分配预处理和延时加载缓存正确API的使用预防问题","categories":[],"tags":[{"name":"iOS 优化","slug":"iOS-优化","permalink":"http://yoursite.com/tags/iOS-优化/"}]},{"title":"iOS RunLoop 深入理解","slug":"iOS-RunLoop-detail","date":"2018-04-09T10:23:53.000Z","updated":"2018-04-13T10:40:16.000Z","comments":true,"path":"2018/04/09/iOS-RunLoop-detail/","link":"","permalink":"http://yoursite.com/2018/04/09/iOS-RunLoop-detail/","excerpt":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关","text":"摘要： 关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关 RunLoop 概念正常情况下一个线程只能执行一个任务，当任务完成了，线程也就退出了。那么如何才能确保我们的线程能够随时能够处理事件并且不退出，直到我们主动要求线程退出的时候就退出？ 答案是有的，这就是我们今天的主角：RunLoop 从字面意思上解析这是一个运行着的循环，我们大体实现下它的伪代码： function loop(){ initialize(); do{ var message = getMessage(); processMessage(message); }while{message != quit} } 从伪代码中我们可以大体的了解到其中的一些逻辑处理 首先由一个入口函数的操作，在这里采用do…while的操作，首先先从消息队列中获取消息，当然如果没有消息的话，这个循环也是会一直发生的，因为我们还没有发送quit的消息。同时在我们有一个消息到来的时候，我们可以获取对应的消息来做处理。 总而言之就是一个一直运行着的事件循环操作 iOS中的RunLoop在 iOS 中为我们提供了两个这样的对象：NSRunLLoop 和 CFRunLoopRef CFRunLoopRef 是在CoreFoundation 框架中的，提供了纯C函数的API,所有的API都是线程安全的 NSRunLoop 是基于CFRunLoopRef 的封装，提供了面向对象的API,但是这些API是线程不安全的 下面我们从源码中来分析RunLoop: void CFRunLoopRun(void){ int32_t result; do{ result = CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); }while(kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result) } 下面再来分析下 CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); 首先回去CurrentMode CFRunLoopModeRef CurrentMode = __CFRunLoopFindMode(r1,modelName,false); 然后对currentMode进行判断 判断其是否存在或者是否为空 if(currentMode == NULL || __CFRunLoopModelIsEmpty){ return finish;//返回完成 就退出了runloop } 这里就是RunLoop结束的一个很重要的因素 下面我们在看看其中最重要的部分： if(currentMode-&gt;observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopEntry); result = __CFRunLoopRun(r1,currentMode,seconds,returnAfterSourceHandled,previousMode); if(currentMode-&gt;observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopExit); 下面借鉴网上的博客资源分析下：（采用伪代码）参照 int32_t __CFRunLoopRun(){ //通知即将进入runloop __CFRunLoopDoObservers(kCFRunLoopEntry); do{ //通知将要处理timer和source __CFRunLoopDoObservers(kcfrunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); //处理非延迟的主线程调用 __CFRunLoopDoBlocks(); //处理source0事件 __CFRunLoopDoSource0(); if(sourceHandledThisRoop){ __CFRunLoopDoBlocks(); } //如果有Source1 (基于Port) 处于ready状态，直接处理这个Source1 然后跳转去处理消息 if(__Source0DidDispatchProtLastTime){ Boolean hasMsg = __CFRunLoopServiceMachPort(); if(hasMsg){ goto handle_msg; } } //通知 Observers 线程即将进入休眠 if(!sourceHandledThisRoop){ __CFRunLoopDoObservers(runloop,currentMode,KCFrunLoopBeforeWaiting); } //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); //即将进入休眠 __CFRunLoopDoObservers(KCFrunLoopBeforeWaiting); //等待内核mach_msg事件 mach_port_t weakUpPort =","categories":[],"tags":[{"name":"iOS RunLoop","slug":"iOS-RunLoop","permalink":"http://yoursite.com/tags/iOS-RunLoop/"}]},{"title":"2018个人计划","slug":"what-to-do-for-2018","date":"2018-04-04T10:29:56.000Z","updated":"2018-04-04T01:23:11.000Z","comments":true,"path":"2018/04/04/what-to-do-for-2018/","link":"","permalink":"http://yoursite.com/2018/04/04/what-to-do-for-2018/","excerpt":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！","text":"摘要： 这是个人2018的计划，希望自己能够一一实现，加油！ 组件化的完善","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]},{"title":"iOS中Block的运用","slug":"block-use-method","date":"2018-04-04T02:06:28.000Z","updated":"2018-04-23T10:23:55.000Z","comments":true,"path":"2018/04/04/block-use-method/","link":"","permalink":"http://yoursite.com/2018/04/04/block-use-method/","excerpt":"摘要： 关于block的简单描述和使用概述","text":"摘要： 关于block的简单描述和使用概述 block的概述 Block：带有自动变量的匿名函数匿名函数：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域 语法： 声明： 返回值(^名称)(参数列表) typedef int(^ClickBlock)(NSUInteger); -(void)justAClick(ClickBlock)block{ NSLog(@&quot;Param:%@&quot;,block); } 定义： ^返回值类型(参数列表){表达式} ^(NSUInteger count){ //这里是代码展示区 return count + 1; } 自动变量 Block可以截获所使用的自动变量的值； 截获：保存自动变量的瞬间值 因为是瞬间值，所以Block之后，即便Block外面修改自动变量的值，也不会对Block内部有影响 如果需要对其的改变也会对变量产生影响的话，需要在变量的前面增加 __block block的运用 在我们的代码中，经常会用到block，其中涉及到了很多方面，下面我们将列举一些比较常见的用法和大家分享。分别是链式编程、返回参数、获取信息等。如果后续还有新的会增加。 链式编程这个在我们很多地方我们应该都能够看到（这里针对OC），比如Masonry,还有BabyBluetooth的使用方面都会涉及到链式编程 Masonry: make.top.equalto(self).offset(100); BabyBluetooth: baby.connecttoPeripherals().start(); 这样给人的感觉相对比较流畅和简洁很多。 首先先针对点式操作： 在OC中点语法就是一种语法糖，最终会调用对用属性的getter/setter的方法。 -(NSString*)hello{ return @&quot;hello&quot;; } self.hello; //会报 Property Access result unused; 我们让它的结果利用就来就不会报警告了 OK,针对点语法我们已经大概了解了，下面就针对链式中，为什么能够实现链式呢？ 这就得从返回值上做文章了，首先我们可以肯定返回值肯定是自身，要不然的话，就无法调用后续的函数进行操作了。 -(Test*)hello{ return self; } self.hello.hello; 这时候如果我们需要附带参数要如何实现： 很简单 block 动起来 -(Test*(^)(NSString*))hello{ return ^(NSString* str){ self.hello = str; return self; } } self.hello(@&quot;hello&quot;).hello(@&quot;str&quot;); NSLog(self.hello); 返回参数 参数的返回：很容易理解，就应该是利用返回值，来做判断的操作，或者利用返回值的数据，来进行一些操作。比如我们比较常用的UITabelView中针对Deletege 中的很多 比如rowCount //tableViewItem typedef NSUInteger (^CellCountBlock)(void); -(void)tableViewConfig{ if(self.CellCountBlock){ NSUInteger countNum = self.CellCountBlock(); NSLog(@&quot;the countNum is %d&quot;,countNum); } } //ViewController [tableViewItem tableViewConfig]; tableViewItem.CellCountBlock = ^{ return 10; } 当然这里我们也可以采用链式编程的方式来进行！ 获取信息 信息的获取：我们主要是在文件上传的时候可以看到关于fromData的拼接 - (NSMutableURLRequest*)multipartFormRequestWithMethod:(NSString*)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error { __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (block) { block(formData); } return [formData requestByFinalizingMultipartFormData]; } 这里将重要的代码贴出来： 这里的formData 数据是将数据的拼接防盗调用方进行拼接的，拼接完成后再将数据进行上传操作 所以这里的formData就是我们的重点 -(void)tableViewConfig:(void(^)(NSDictionary *))configBlock{ __block NSMutableDictionary *config = [NSMutableDictionary dictionaryWithCapacity:0]; if (configBlock) { configBlock(config); } NSLog(@&quot;the config is %@&quot;,config); } //使用 [[GYEBleManager shareManager] tableViewConfig:^(NSDictionary *config) { [config setValue:@&quot;hello&quot; forKey:@&quot;key&quot;]; }]; //结果： the config is { key = hello; } 链接： https://www.wangjiawen.com/ios/ios-block-usage-and-implementation https://www.jianshu.com/p/23c1bbe3c99d","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}]},{"title":"MarkDown 的基础使用","slug":"Markdown-leaning","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-23T10:03:14.000Z","comments":true,"path":"2018/03/29/Markdown-leaning/","link":"","permalink":"http://yoursite.com/2018/03/29/Markdown-leaning/","excerpt":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------","text":"标题两种方式可以实现 使用=和-来做标记 一级标题====== 二级标题------ 使用#来表示字号，可以使用1-6级标题来进行表示 #一级标题##二级标题###三级标题 效果： 一级标题二级标题三级标题四级标题五级标题 段落 段落的前后需要有空行，所谓的空行是指没有文字的内容，使用两个以上的空格加上回车键就可以达到段落的效果 区块的操作在段落的每行或者只要在第一行中使用符号&gt;就可以使用区块，当然还可以使用多个嵌套 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符 void main(){ printf(&quot;hello world&quot;); } 代码区块 需要和普通的段落之间存在空行 强调在强调的内容两侧分别加上*或者_,比如： *斜体* **加粗**_斜体_ __加粗__ 效果： 斜体 _斜体_ 加粗 加粗 列表使用*、+、-这几个号码来进行列表 第一项 第二项 第三项 分割线采用三个或者三个以上的*,_,-就可以构建分割线了 链接链接有两种形式生成：行内式和参考式 [链接](http://www.baidu.com) 这就是是链接的使用方式了 图片添加图片的形式和链接的形式相似，值需要在链接的基础上前方加上一个！就可以了 ![alt text](/path/to/img.jpg) 下面阐述下这个： 一个感叹号! 接着一个方括号，里面放上图片的替代文字 接着是一个普通括号，里面放上图片的网址，左后要用 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其他意义的符号，可以利用反斜杠来显示一些在markdown中存在语法的字符","categories":[],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"如何构建一个Github的博客","slug":"how-to-build-github-blog","date":"2018-03-29T10:29:56.000Z","updated":"2018-04-04T01:26:00.000Z","comments":true,"path":"2018/03/29/how-to-build-github-blog/","link":"","permalink":"http://yoursite.com/2018/03/29/how-to-build-github-blog/","excerpt":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你","text":"摘要：关于如何构建一个Github的博客，这里我采用的是GitHub和Hexo组合的方案来进行，在这里我们将一步一步的进行构建，希望能够帮助到你 这里先列出大概的要点： Git的安装 Node.js的安装 Hexo 的安装和配置 Hexo 的发布和测试 Git安装 这里暂时没有涉及到后续补充 Node.js的安装Hexo的安装和配置Hexo 的安装npm install -g hexo-cli //全局安装hexo的客户端 如果不成功的话可以加上sudo 当这个执行成功后可以使用 hexo -v //查看是否安装成功 hexo 的初始化hexo init //这里可以针对具体的文件夹进行初始化操作 npm install //安装相对应的依赖包 hexo 框架简介 当hexo init 执行完成后，在当前的文件夹会增加框架的目录结构： _config.yml //网站的配置信息 package.json //项目包信息 scaffolds //模板文件夹，hexo 根据scaffold中的模板来新建文件 source //存放用户资源的地方 _drafts //存放草稿的地方_posts //存放发布的文件 themes //主题文件夹 hexo 简单配置首先我们需要打开_config.yml文件,这里是hexo的主要配置文件： 这里可以参考Hexo配置 title: lmzqm //网站标题 subtitle: iOS 开发者 //网站副标题 description: just do it //网站描述 keywords: //网站的关键字 author: lmzqm //您的名字 language: zh-CN //网站使用的语言 timezone: Asia/Shanghai //网站时区 hexo 命令下面简单介绍下hexo的命令： hexo generate //简写 hexo g 生成静态文件，会在当前的目录下生成一个新的public的文件夹 hexo server // 简写 hexo s 启动本地服务器，通过http://localhost:4000进行访问 hexo deploy // 简写 hexo d 部署到远程，在_config.yml中配置 hexo new post-name //简写 hexo n post-name 新建文章 hexo new page page-name //简写 hexo n page page-name 新建页面 会在Source下新建一个相对应的目录 组合命令： hexo s -g //生成和预览 hexo d -g //生成和部署 草稿命令： hexo new draft &lt;title&gt; //新建草稿，存放在source/_drafts hexo public post &lt;title&gt; //发布操作草稿文章，文章将转移到source/_posts hexo s -g // 可以开始进行预览操作 部署到GitHub pages 部署Hexo到GitHub 指的是将hexo -g生成的静态文件推送到github 对应的仓库中 因此我们需要在我们GitHub中做好相对应的准备 首先需要明确的是： 每一个github的账号都有一个GitHub的pages; 一个账号只能创建一个repository来存放GitHub pages; 仓库的名字必须是username/username.github.io 这是固定的命名约定 然后就可以通过 https://username.github.io 来进行访问 GitHub 创建的个人主页内容是在master分支下的 当你在你的github下创建了这个repository后，就可以在本地 先安装一个扩展： npm install hexo-deployer-git --save 修改 _config.yml中的配置： deploy: type:git repo:https://github.com/username/username.github.io.git branch:master 这样的话就可以通过执行 hexo d -g 将静态网站提交到github网站上 hexo 主题首先关于hexo的主题可以在github中进行查找，很方便就能找到一些主题，然后可以选择你所需要的主题，关于主题内部的具体配置，可以参照具体的网站来进行配置。 hexo clean //clean remove generated files and cache 然后就可以选择你自己想要的主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这个完成后需要在根目录下的_config.yml中将主题变换成我们现在的主题： theme: yilia 这时候在theme的文件夹下就可以就会多出一个文件夹yilia着是主题的文件夹，进入后可以用git来进行操作，切换tag来针对不同的版本，当然对于不同版本的具体要求对应的网站上去查看下详情会比较好理解 后期针对主题的设置，我们需要进入到相对应主题当中的_config.yml文件进行配置 这个可以在网上找到很多信息 后期我们再专门弄个文章来进行阐述，这里就暂时先简单描述","categories":[],"tags":[{"name":"Github Hexo","slug":"Github-Hexo","permalink":"http://yoursite.com/tags/Github-Hexo/"}]}]}