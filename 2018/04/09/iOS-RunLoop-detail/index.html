<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="摘要：    关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关">
<meta name="keywords" content="iOS RunLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS RunLoop 深入理解">
<meta property="og:url" content="http://yoursite.com/2018/04/09/iOS-RunLoop-detail/index.html">
<meta property="og:site_name" content="lmzqm">
<meta property="og:description" content="摘要：    关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/source.png">
<meta property="og:image" content="http://yoursite.com/images/runloop.png">
<meta property="og:image" content="http://yoursite.com/images/match.png">
<meta property="og:updated_time" content="2018-05-21T10:52:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS RunLoop 深入理解">
<meta name="twitter:description" content="摘要：    关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关">
<meta name="twitter:image" content="http://yoursite.com/images/source.png">






  <link rel="canonical" href="http://yoursite.com/2018/04/09/iOS-RunLoop-detail/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS RunLoop 深入理解 | lmzqm</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lmzqm</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">iOS 开发者</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
    </ul>
  

  
    

    
    
      
      
    
      
      
    
    

  


  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/09/iOS-RunLoop-detail/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lmzqm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lmzqm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS RunLoop 深入理解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T18:23:53+08:00">2018-04-09</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/09/iOS-RunLoop-detail/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/04/09/iOS-RunLoop-detail/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>摘要：</p>
<blockquote>
<p>  关于RunLoop 在iOS开发中经常都会涉及到它的运行，因为在iOS中所有的事件的产生都与它息息相关</p>
</blockquote>
<a id="more"></a>
<h4 id="RunLoop-概念"><a href="#RunLoop-概念" class="headerlink" title="RunLoop 概念"></a>RunLoop 概念</h4><p>正常情况下一个线程只能执行一个任务，当任务完成了，线程也就退出了。那么如何才能确保我们的线程能够随时能够处理事件并且不退出，直到我们主动要求线程退出的时候就退出？</p>
<p>答案是有的，这就是我们今天的主角：RunLoop</p>
<p>从字面意思上解析这是一个运行着的循环，我们大体实现下它的伪代码：</p>
<pre><code>function loop(){
  initialize();
  do{
    var message = getMessage();
    processMessage(message);
  }while{message != quit}
}
</code></pre><p>从伪代码中我们可以大体的了解到其中的一些逻辑处理</p>
<p>RunLoop 的关键点在于：如何管理事件、消息，如何让线程在没有处理消息的时候休眠以避免资源的占用、在有消息的时候到来的时候能够能立即唤醒。</p>
<p><strong>所以，RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行Event Loop的逻辑。</strong> 线程执行了这个函数后，就会一直处于这个函数的内部“接受消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束，函数返回。</p>
<p>首先由一个入口函数的操作，在这里采用do…while的操作，首先先从消息队列中获取消息，当然如果没有消息的话，这个循环也是会一直发生的，因为我们还没有发送quit的消息。同时在我们有一个消息到来的时候，我们可以获取对应的消息来做处理。</p>
<p>总而言之就是一个一直运行着的事件循环操作</p>
<h4 id="iOS中的RunLoop"><a href="#iOS中的RunLoop" class="headerlink" title="iOS中的RunLoop"></a>iOS中的RunLoop</h4><p>在 iOS 中为我们提供了两个这样的对象：NSRunLLoop 和 CFRunLoopRef</p>
<p>CFRunLoopRef 是在CoreFoundation 框架中的，提供了纯C函数的API,所有的API都是线程安全的</p>
<p>NSRunLoop 是基于CFRunLoopRef 的封装，提供了面向对象的API,但是这些API是线程不安全的</p>
<p>下面我们从源码中来分析RunLoop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void)&#123;</span><br><span class="line">  int32_t result;</span><br><span class="line">  do&#123;</span><br><span class="line">    result = CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">   &#125;while(kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面再来分析下 <code>CFRunLoopRunSpecific(CFRunloopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</code></p>
<pre><code>首先回去CurrentMode
CFRunLoopModeRef CurrentMode = __CFRunLoopFindMode(r1,modelName,false);

然后对currentMode进行判断
判断其是否存在或者是否为空
if(currentMode == NULL || __CFRunLoopModelIsEmpty){
  return finish;//返回完成 就退出了runloop
}

这里就是RunLoop结束的一个很重要的因素
</code></pre><p>下面我们在看看其中最重要的部分：</p>
<pre><code>if(currentMode-&gt;observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopEntry);
result = __CFRunLoopRun(r1,currentMode,seconds,returnAfterSourceHandled,previousMode);
if(currentMode-&gt;observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(r1,currentMode,kCFRunLoopExit);
</code></pre><p>下面借鉴网上的博客资源分析下：（采用伪代码）<br><a href="http://www.cnblogs.com/kenshincui/p/6823841.html">参照</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int32_t __CFRunLoopRun()&#123;</span><br><span class="line">//通知即将进入runloop</span><br><span class="line">__CFRunLoopDoObservers(kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">//通知将要处理timer和source</span><br><span class="line">__CFRunLoopDoObservers(kcfrunLoopBeforeTimers);</span><br><span class="line">__CFRunLoopDoObservers(kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">//处理非延迟的主线程调用</span><br><span class="line">__CFRunLoopDoBlocks();</span><br><span class="line"></span><br><span class="line">//处理source0事件</span><br><span class="line">__CFRunLoopDoSource0();</span><br><span class="line"></span><br><span class="line">if(sourceHandledThisRoop)&#123;</span><br><span class="line">  __CFRunLoopDoBlocks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果有Source1 (基于Port) 处于ready状态，直接处理这个Source1 然后跳转去处理消息</span><br><span class="line"></span><br><span class="line">if(__Source0DidDispatchProtLastTime)&#123;</span><br><span class="line">  Boolean hasMsg = __CFRunLoopServiceMachPort();</span><br><span class="line">  if(hasMsg)&#123;</span><br><span class="line">    goto handle_msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通知 Observers 线程即将进入休眠</span><br><span class="line">if(!sourceHandledThisRoop)&#123;</span><br><span class="line">  __CFRunLoopDoObservers(runloop,currentMode,KCFrunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//GCD dispatch main queue</span><br><span class="line">CheckIfExistMessagesInMainDispatchQueue();</span><br><span class="line"></span><br><span class="line">//即将进入休眠</span><br><span class="line">__CFRunLoopDoObservers(KCFrunLoopBeforeWaiting);</span><br><span class="line"></span><br><span class="line">//等待内核mach_msg事件</span><br><span class="line">mach_port_t weakUpPort =</span><br></pre></td></tr></table></figure></p>
<h4 id="runloop-的概念"><a href="#runloop-的概念" class="headerlink" title="runloop 的概念"></a>runloop 的概念</h4><p>一般来说一个线程在执行完后就会退出，如果我们想要一个机制，让线程能随时处理时间但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现这种模型的关键点在于：如何管理事件、消息，如何让线程在没有处理消息的时候休眠以处理消息休眠的时候避免资源占用、在有消息带来的时候立刻被唤醒。</p>
<p>所以RunLoop实际上即使一个对象，这个对象管理了其需要处理的事件和消息，并提供一个入口函数来执行上面的Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数的内部，“接受消息-&gt; 等待 -&gt; 处理”的循环中，直到这个循环结束，函数返回</p>
<h4 id="RunLoop-和线程的关系"><a href="#RunLoop-和线程的关系" class="headerlink" title="RunLoop 和线程的关系"></a>RunLoop 和线程的关系</h4><p>苹果不允许直接创建 RunLoop ,它值提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunloopGetCurrent(). 这两个函数内部的逻辑大概是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 一个全局的Dictionary key是pthread_t ,value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">// 访问 loopsDic 时候的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef _CFRunloopGet(pthread_t thread)&#123;</span><br><span class="line"></span><br><span class="line">  OSSpinLockLock(&amp;loopsLock);</span><br><span class="line"></span><br><span class="line">  if (!loopsDic) &#123;</span><br><span class="line">    // 第一次进入的时候，初始化全局的DIC ,并先给主线程创建一个RunLoop</span><br><span class="line">    loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">    CFRunLoopRef mainLoop = _CFRunloopCreate();</span><br><span class="line">    CFDictionarySetValue(loopsDic,pthread_main_thread_np(),mainLoop);</span><br><span class="line">  &#125;</span><br><span class="line">  // 直接从 Dictionary 中获取</span><br><span class="line">  CFRunLoopRef loop = CFDictionaryGetValue(loopsDic,thread);</span><br><span class="line"></span><br><span class="line">  if (!loop) &#123;</span><br><span class="line">    // 如果取不到loop 就创建一个</span><br><span class="line">    loop = _CFRunloopCreate();</span><br><span class="line">    CFDictionarySetValue(loopsDic,thread,loop);</span><br><span class="line">    // 注册一个回调，当现场销毁的时候，顺便也销毁其对应的RunLoop</span><br><span class="line">    _CFSetTSD(...,thread,loop,__CFFinalizeRunLoop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetMain()&#123;</span><br><span class="line">  return _CFRunloopGet(pthread_main_thread_np);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunloopGetCurrent()&#123;</span><br><span class="line">  return _CFRunloopGet(pthread_self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码逻辑可以看出，线程和RunLoop 是一一对应的，其关系保存在全局的Dictionary中，线程在刚刚创建的时候并没有 RunLoop ，如你不主动获取的话，它是一直都不会有。 RunLoop的创建是发生在第一次获取的时候，RunLoop 的销毁是发生在线程结束的时候，你只能在一个线程的内部获取到它的 RunLoop .主线程的RunLoop除外。</p>
<h4 id="RunLoop-对外接口"><a href="#RunLoop-对外接口" class="headerlink" title="RunLoop 对外接口"></a>RunLoop 对外接口</h4><p>在CoreFoundation 里关于RunLoop的有5个类</p>
<p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p>
<p>一个RunLoop中包含若干个Mode ,每个Mode又包含若干个Source/Timer/Observer 。每次调用RunLoop 的主函数的时候，只能指定其中一个Mode,这个Mode被称为CurrentMode. 如果要切换这个Mode只能退出Loop，再重新指定一个新的Mode进入，这样做是为了分隔开不同组的Source/Timer/Observer，让其互不影响</p>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1 .</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动出发事件。使用的时候，需要先调用CFRunLoopSourceSignal(source) ,将这个Source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop ，让其处理这个事件。</li>
<li>Source1 包含了一个mach_port 和 一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种Source 能够主动唤醒RunLoop的线程</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是基于定时器的触发器，它和NSTimer 是toll-free bridged的可以混用。其包含一个时间长度和一个回调（函数指针） 。当其加入RunLoop的时候，会在RunLoop中注册对应的时间点，当时间点到了，RunLoop就会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个Observer 都包含了一个回调（函数指针），当RunLoop的状态发生变化的时候，观察者就能通过回调接收到这个变化，可以观测的时间点有以下几个：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">&gt;    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">&gt;    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">&gt;    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">&gt;    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">&gt;    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">&gt;    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&gt;    &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的Source/Timer/Observer 被称为Mode item 一个Item 可以被同时加入到多个mode.但是一个item 被重复加入到同一个mode 是不会生效的。如果一个mode 里一个item都没有，则RunLoop 会直接退出，不进入循环。</p>
<h4 id="RunLoop-的Model"><a href="#RunLoop-的Model" class="headerlink" title="RunLoop 的Model"></a>RunLoop 的Model</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode&#123;</span><br><span class="line">  CFStringRef _name;</span><br><span class="line">  CFMutableSetRef _source0;</span><br><span class="line">  CFMutableSetRef _source1;</span><br><span class="line">  CFMutableArrayRef _observers;</span><br><span class="line">  CFMutableArrayRef _timers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __CFRunloop&#123;</span><br><span class="line">  CFMutableSetRef _commonModes;</span><br><span class="line">  CFMutableSetRef _commonModeItems;</span><br><span class="line">  CFRunLoopModeRef _currentMode;</span><br><span class="line">  CFMutableSetRef _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫“CommonModes” 一个Mode 可以将自己标记为“Common”属性，通过将其ModeName添加到RunLoop的commonModes中，每当RunLoop的内容发生变化的时候将RunLoop会自动将_commonModeItems里的Source/Observer/Timer同步到具有“Common”标记的所有Mode里</p>
<p>CFRunLoop对外提供了管理Mode的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop,CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName,...);</span><br></pre></td></tr></table></figure>
<p>Mode暴露的管理Mode item的接口 有下面几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);</span><br><span class="line">CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);</span><br><span class="line">CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode);</span><br><span class="line"></span><br><span class="line">CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);</span><br><span class="line">CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);</span><br><span class="line">CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode);</span><br><span class="line"></span><br><span class="line">CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);</span><br><span class="line">CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);</span><br><span class="line">CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode);</span><br></pre></td></tr></table></figure>
<p>你只能通过mode name 来操作内部的 mode,当你传入一个新的mode name但是RunLoop 内部没有对应的mode的时候，RunLoop 会自动帮你创建对用的CFRunLoopModeRef .对于一个RunLoop 来说，其内部的mode 只能增加不能删除</p>
<h4 id="RunLoop-的Source"><a href="#RunLoop-的Source" class="headerlink" title="RunLoop 的Source"></a>RunLoop 的Source</h4><p>首先先看下官方的RunLoop结构图：</p>
<p><img src="/images/source.png" alt="source"></p>
<p>结合RunLoop的核心运行流程可以看出Soucre0(复杂APP内部事件，又APP负责管理出发，例如：UITouch事件)和Timer(又叫Timer Source 基于事件的出发器，上层对应NSTImer)是两个不同的RunLoop事件源。runloop 被这些事件唤醒后，就会处理并调用事件处理方法（CFRunLoopTimerRef 的回调） ，但是对于RunLoopSoureRef 除了Source0之外还有另一个版本就是Source1 ,Source1 除了包含回调指针外还包含了一个mach port 和Source0 需要手动触发不同，Source1可以监听系统端口和其他线程相互发送消息，它还能够主动唤醒RunLoop</p>
<h4 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h4><p>根据苹果文档的说明，RunLoop 内部的逻辑大致如下：</p>
<p><img src="/images/runloop.png" alt="runloop"></p>
<p>内部代码整理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void CFRunLoopRun(void)&#123;</span><br><span class="line">  CFRunLoopRunSpecific(CFRunloopGetCurrent(),kCFRunLoopDefaultMode,1.0e10,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用指定的Mode启动 ，允许设置RunLoop 的超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName,CFTimeInterval seconds,Boolean stopAfterHandle)&#123;</span><br><span class="line">  return CFRunLoopRunSpecific(CFRunloopGetCurrent(),modeName,seconds,stopAfterHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RunLoop 的实现</span><br><span class="line"></span><br><span class="line">int CFRunLoopRunSpecific(runloop,modeName,seconds,stopAfterHandle)&#123;</span><br><span class="line"></span><br><span class="line"> //首先通过mode name 获取mode</span><br><span class="line">  CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop,modeName,false);</span><br><span class="line"></span><br><span class="line">// 如果当前的mode是空的，直接退出</span><br><span class="line">  if (__CFRunLoopModelIsEmpty(currentMode))  &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">// 1.通知 Observer： RunLoop 即将进入 loop</span><br><span class="line">  __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopEntry);</span><br><span class="line">// 内部函数 ，进入Loop</span><br><span class="line">  __CFRunLoopRun(runloop,currentMode,seconds,returnAfterSourceHandled)&#123;</span><br><span class="line"></span><br><span class="line">    Boolean sourceHandledThisRoop = NO;</span><br><span class="line"></span><br><span class="line">    int retVal = 0;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line"></span><br><span class="line">      // 2. 通知Observer : RunLoop 即将触发Timer的回调</span><br><span class="line">      __CFRUnLoopDoObservers(RunLoop,currentMode,kCFRunLoopBeforeTimers);</span><br><span class="line">      // 3. 通知 Observers ； RunLoop 即将触发Source0的回调</span><br><span class="line">      __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopBeforeSources);</span><br><span class="line">      // 执行被加入的Block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop,currentMode);</span><br><span class="line">      // 4.RunLoop 触发 Source 0的回调</span><br><span class="line">      sourceHandledThisRoop = __CFRunLoopDoSource0(runloop,currentMode,stopAfterHandle);</span><br><span class="line">      // 执行被加入的block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop , currentMode);</span><br><span class="line">      // 如果有Source1处于ready的状态，直接处理这个Source1 ,然后调转到处理消息</span><br><span class="line">      if (__Source0DidDispatchProtLastTime) &#123;</span><br><span class="line">        Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort,&amp;msg);</span><br><span class="line"></span><br><span class="line">      8</span><br><span class="line">      &#125;</span><br><span class="line">      // 通知Observer RunLoop 即将进入休眠</span><br><span class="line">      if (!sourceHandledThisRoop) &#123;</span><br><span class="line">        __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopBeforeWaiting);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 调用 mach_msg 等待接收mach_port的消息，线程讲江入休眠，直到下面某一个时间唤醒</span><br><span class="line">      //  一个基于port 的Source 的事件</span><br><span class="line">      //  一个Timer到时间了</span><br><span class="line">      // RunLoop 自身的超时时间到了</span><br><span class="line">      // 被其他什么调用者手动唤醒</span><br><span class="line">      __CFRunLoopServiceMachPort(waitSet,&amp;msg,sizeof(msg_buffer),&amp;livePort)&#123;</span><br><span class="line">        mach_msg(msg,MACH_RCV_MSG,port);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 通知 Observers: RunLoop 的线程刚刚被唤醒了</span><br><span class="line">      __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopAfterWaiting);</span><br><span class="line">      // 9 收到消息，处理消息</span><br><span class="line">      handle_msg;</span><br><span class="line"></span><br><span class="line">      // 9.1 如果消息是一个Timer ，触发这个timer的回调</span><br><span class="line">      if (msg_is_timer) &#123;</span><br><span class="line">        __CFRUNLoopDoTomers(runloop,currentMode,mach_absoult_time());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      // 9.2 如果有dispatch 到 main_queue 的block ,执行block</span><br><span class="line">      else if (msg_is_dispatch)&#123;</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">      &#125;</span><br><span class="line">      // 9.3 如果一个Source1 (基于port)发出的事件了，处理这个事件。</span><br><span class="line">      else&#123;</span><br><span class="line">        CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceFor马车Port（runloop,currentMode,liveport）;</span><br><span class="line">        sourceHandledThisRoop = __CFRunLoopDoSource1(runloop , currentMode,source1,msg);</span><br><span class="line"></span><br><span class="line">        if (sourceHandledThisRoop) &#123;</span><br><span class="line">          mach_msg(reply , MACH_SEND_MSG,reply);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 执行加入到Loop 的block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop , currentMode);</span><br><span class="line"></span><br><span class="line">      if (sourceHandledThisRoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        // 进入loop的时候参数说处理完事件就返回</span><br><span class="line">        retVal = KCFRunLoopHandledSource;</span><br><span class="line">      &#125;else if(timeout)&#123;</span><br><span class="line">        // 超出传入参数标记的超时时间</span><br><span class="line">        retVal = KCFRunLoopRunTimedOut;</span><br><span class="line">      &#125;else if(__CFRunLoopIsStopped(runloop))&#123;</span><br><span class="line">        // 被外部调用者强制停止了</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">      &#125;else if(__CFRunLoopModelIsEmpty(runloop ,currentMode))&#123;</span><br><span class="line">        // source、timer/observer 一个都没有</span><br><span class="line">        retVal = kCFRunLoopRunFinished;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果没有超时，mode没有为空 loop也没有停止 那就继续loop</span><br><span class="line"></span><br><span class="line">    &#125;while&#123;retVal == 0&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 通知Observer RunLoop 即将退出</span><br><span class="line">  __CFRUnLoopDoObservers(runloop,currentMode,kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上图和代码的说明我们可以比较清楚的了解runloop内部的流程操作，</p>
<h4 id="RunLoop-休眠"><a href="#RunLoop-休眠" class="headerlink" title="RunLoop 休眠"></a>RunLoop 休眠</h4><p>其实对于RunLoop 最核心的地方是在于保障了在没有消息的时候休眠以避免占用系统的资源，有消息的时候能够及时唤醒处理消息。RunLoop 的这个机制完全依靠系统内核来完成的，具体来时候苹果系统核心组件Drawin中的mach 来完成的。</p>
<p>和其他架构不同的是Mach对象间不能直接调用，只能通过消息传递的方式来进行通信。“消息”是Mach中基础的概念，消息在两个端口之间传递，这就是Mach 的IPC 的核心</p>
<p>Mach 提供了进程间通信，处理器调度等基础服务，在Mach中，进程，线程间的通信以消息的方式来完成，消息在两个port之间进行传递（这也正是Source1之所以称为Port-based Source）的原因，因为它是依靠系统发送消息来指定的Port来出发的，消息的发送和接收使用mach/message中的Mach_msg（）函数。</p>
<p>Mach 的消息定义在&lt;mach/message.h&gt; 头文件中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125;mach_msg_base_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125;mach_msg_header_t；</span><br></pre></td></tr></table></figure>
<p>一条Mach 消息实际上就是一个二进制的包（BLOB）,其头部定义了一个当前端口local_port和目标端口 remote_port 发送和接收消息是通过同一个API进行的，其option标记了传递方向</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">  mach_msg_header_t *msg,</span><br><span class="line">  mach_msg_option_t option,</span><br><span class="line">  mach_msg_size_t send_size,</span><br><span class="line">  mach_msg_size_t rcv_size,</span><br><span class="line">  mach_port_name_t rcg_name,</span><br><span class="line">  mach_msg_timeout_t timeout,</span><br><span class="line">  mach_port_name_t notifiy</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="/images/match.png" alt="match"></p>
<p>match_msg（）的本质是一个调用mach_msg_trap()，这相当于一个系统调用，会出发内核状态切换，当程序精致的时候，RunLoop 停留在 <strong>__CFRunLoopServiceMachPort()的方法中，这个函数就是调用了mach_msg </strong> 让程序处于休眠状态</p>
<h4 id="RunLoop-提供的接口"><a href="#RunLoop-提供的接口" class="headerlink" title="RunLoop 提供的接口"></a>RunLoop 提供的接口</h4><p>这里讲解下NSRunLoop 的API</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的runloop</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSRunLoop</span> *currentRunLoop;</span><br><span class="line"><span class="comment">// 获取到主线程的 runloop</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSRunLoop</span> *mainRunLoop</span><br><span class="line"> API_AVAILABLE(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"><span class="comment">// 获取到runloop 的当前的mode</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSRunLoopMode</span> currentMode;</span><br></pre></td></tr></table></figure>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 为mode 添加timer item</span></span><br><span class="line">-(<span class="keyword">void</span>)addTimer:(<span class="built_in">NSTImer</span> *)timer forMode:(<span class="built_in">NSRunLoopMode</span>) mode;</span><br><span class="line"><span class="comment">// 给mode tianj 一个Port</span></span><br><span class="line">-(<span class="keyword">void</span>) addPort:(<span class="built_in">NSPort</span> *)aPort forMode:(<span class="built_in">NSRunLoopMode</span> )mode;</span><br><span class="line"><span class="comment">// 从mode 中移除 port</span></span><br><span class="line">-(<span class="keyword">void</span>)removePort:(<span class="built_in">NSPort</span> *)aPort forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">-(<span class="keyword">nullable</span> <span class="built_in">NSDate</span> *)limitDateForMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)acceptInputForMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span>*)limitDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Schedules the execution of a block on the target run loop in given modes.</span></span><br><span class="line"><span class="comment">/// - parameter: modes   An array of input modes for which the block may be executed.</span></span><br><span class="line"><span class="comment">/// - parameter: block   The block to execute</span></span><br><span class="line">- (<span class="keyword">void</span>)performInModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes block:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Schedules the execution of a block on the target run loop.</span></span><br><span class="line"><span class="comment">/// - parameter: block   The block to execute</span></span><br><span class="line">- (<span class="keyword">void</span>)performBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block API_AVAILABLE(macosx(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** 	Delayed perform	 ******************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">NSDelayedPerforming</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument;</span><br><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSRunLoop</span> (<span class="title">NSOrderedPerform</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector target:(<span class="keyword">id</span>)target argument:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg order:(<span class="built_in">NSUInteger</span>)order modes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</span><br><span class="line">- (<span class="keyword">void</span>)cancelPerformSelector:(SEL)aSelector target:(<span class="keyword">id</span>)target argument:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg;</span><br><span class="line">- (<span class="keyword">void</span>)cancelPerformSelectorsWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="实例的运用"><a href="#实例的运用" class="headerlink" title="实例的运用"></a>实例的运用</h4><h5 id="APP-启动-RunLoop"><a href="#APP-启动-RunLoop" class="headerlink" title="APP 启动 RunLoop"></a>APP 启动 RunLoop</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CFRunLoop &#123;</span><br><span class="line">  current mode = kCFRunLoopDefaultMode;</span><br><span class="line">  common modes = &#123;</span><br><span class="line">    UITrackingRunLoopMode</span><br><span class="line">    kCFRunLoopDefaultMode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  common mode items = &#123;</span><br><span class="line">    // source0(manual)</span><br><span class="line">    CFRunLoopSourceRef&#123;order = -1,&#123;callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = -1,&#123;callout = PurpleEventSignalCallBack&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = 0,&#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"></span><br><span class="line">    // source1 (mach_port)</span><br><span class="line">    CFRunLoopSource &#123;order = 0,&#123;port = 17923&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = 0,&#123;port = 12039&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = 0,&#123;port = 16647&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = -1,&#123;callout = PurpleEventCallBack&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = 0,&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    // Observers</span><br><span class="line">    CFRunLoopObserver &#123;order = -2147483674 ,activities = 0x1, callout = _warpRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">    CFRunLoopObserver &#123;order = 0, activities = 0x20, callout = _UIGestureRecognizerUpdateObserver &#125;</span><br><span class="line">    CFRunLoopObserver &#123;order = 1999000,activities = 0xa0,callout = _afterCACommitHandler&#125;</span><br><span class="line">    CFRunLoopObserver &#123;order = 2000000 ,activities = 0xa0 ,callout = _ZN2CA11Transcation17Observer_callbackEP9——CFRunLoopObservermPV&#125;</span><br><span class="line">    CFRunLoopObserver &#123;order = 2147483647 , activities = 0xa0 , callout = _warpRunLoopWithAUtoreleasepollHandler &#125;</span><br><span class="line"></span><br><span class="line">    // timer</span><br><span class="line"></span><br><span class="line">    CFRunLoopTimer &#123;firing = NO , interval = 3.1536E+09 ,tolerance = 0,next fire date = 453098071 (-4421),callout = _ZN2CAL14Timer_callbackEP16_CFRunLoopTimerPV(!uartZCore.framework)&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modes = &#123;</span><br><span class="line"></span><br><span class="line">    CFRunLoopMode&#123;</span><br><span class="line">      source0 = &#123;&#125;,</span><br><span class="line">      source1 = &#123;&#125;,</span><br><span class="line">      observers = &#123;&#125;,</span><br><span class="line">      timers = &#123;&#125;</span><br><span class="line">    &#125;.</span><br><span class="line"></span><br><span class="line">    CFRunLoopMode &#123;</span><br><span class="line">      source0 = &#123;&#125;,</span><br><span class="line">      source1 = &#123;&#125;,</span><br><span class="line">      observers = &#123;&#125;,</span><br><span class="line">      timers = &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    CFRunLoopMode &#123;</span><br><span class="line">      source0 = &#123;CFRunLoopSource &#123;order = 0,&#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    source1 = (null),</span><br><span class="line">    observers = &#123;</span><br><span class="line">      CFRUnLoopObserver &#123;activities = 0xa0 , order = 2000000 , callout = _ZN2CA11Transaction17Observer_callbackEP19_CFRunLoopObservermPV&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    timer = (null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，系统默认注册了5个Mode<br>1.KCFRunLoopDefaultMode :APP默认的Mode ,通常主线程是在这个Mode先运行的<br>2.UITrackingRunLoopMode :界面追踪Mode ,用于ScrollView  追踪触摸滑动，保证界面滑动的时候不受其他Mode影响</p>
<ol start="3">
<li>UIInitializationRunLoopMode :在刚启动App的时候，进入的第一个Mode ，启动完成后就不再使用了</li>
<li>GSWventReceiveRunLoopMode : 接受系统事件内部的Mode,启动完成后就不再使用<br>5.KCFRunLoopCommonMode :这是一个占位的Mode ,没有实际的作用</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检测当前runloop的操作"><a href="#检测当前runloop的操作" class="headerlink" title="检测当前runloop的操作"></a>检测当前runloop的操作</h5><h5 id="AutoRelease-原理"><a href="#AutoRelease-原理" class="headerlink" title="AutoRelease 原理"></a>AutoRelease 原理</h5><pre><code>APP 启动的时候，苹果在主线程的RunLoop 里会注册两个Observer, 其回调都是_wrapRunLoopWithAutoreleasePoolHanler().

第一个Observer 监视的时间是Entry ，其回调内部会调用 _objc_autoreleasePoolPush() 创建自动释放池，其order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。

第二个Observer  监视两个事件，BeforeWaiting（准备进入休眠）的时候调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新的池 Exit(即将退出Loop)的时候调用 _objc_autoreleasePoolPop() 来释放自耦东释放池，这个Observer 的order 是2147483647 ，优先级最低，保证其释放池发生在其他回调之后

通常在主线程执行的代码，通常是写在注入事件回调，Timer 回调中，这些回调会被RunLoop 创建好的AutoReleasePool 环绕着，所以不会出现内存泄露。
</code></pre><h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>  苹果注册了一个Source1 (基于mach_port)的，用来接收系统事件，其回调函数为_IOHIDEventSystemClientQueueCallback();</p>
<p>  当一个硬件事件发生后，首先IOKit。farmwork生成一个IOHIDEvent事件并由SpringBoard接收，这个过程的详细情况可以参考这里。SpringBoard只接收（锁屏/静音）触摸，加速。接近传感器的几种Event,随后使用mach port 转发给App的进程。随后苹果注册的Source1 就会触发回调，并调用_UIApplicationHanleEventQueue() 进行应用内部的分发</p>
<p>  _UIApplicationHanleEventQueue() 会把IOHIDEvent 处理并包装成UIEvent进行处理或分发，其中包括事变UIGuest/处理屏幕旋转/发送给UIWindow等，通常事件比如UIButton点击，touchsBeigin/move/end/cache事件都是在这个回调中完成的</p>
<h5 id="GCD和RunLoop的关系"><a href="#GCD和RunLoop的关系" class="headerlink" title="GCD和RunLoop的关系"></a>GCD和RunLoop的关系</h5><p> 在RunLoop的源代码中可以看到用到了GCD相关的内容，但是RunLoop本身和GCD并没有什么直接的关系，当调用了dispatch_async(dispatch_get_main_queue(),block)的时候，libDispatch会向主线程RunLoop发送消息唤醒RunLoop，RunLoop从消息中获取block,并且在<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>里调用这个block,不过这个操作仅限于主线程，其他线程dispatch操作全部是由libDisoatch驱动的</p>
<h5 id="内存检测工具"><a href="#内存检测工具" class="headerlink" title="内存检测工具"></a>内存检测工具</h5><h5 id="FPS-工具"><a href="#FPS-工具" class="headerlink" title="FPS 工具"></a>FPS 工具</h5>
      
    </div>

    

    
    
    
    <div>
     
	<div>
   
 	<div style="text-align:center;color:#ccc;font-size:14px;">----------本文结束<i class="fa fa-paw"></i>感谢您的阅读----------</div>
   
</div>

     
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS-RunLoop/" rel="tag"><i class ="fa fa-tag"></i> iOS RunLoop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/04/what-to-do-for-2018/" rel="next" title="2018个人计划">
                <i class="fa fa-chevron-left"></i> 2018个人计划
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/17/iOS-youhua-detail/" rel="prev" title="iOS性能优化总结">
                iOS性能优化总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lmzqm</p>
              <p class="site-description motion-element" itemprop="description">just do it</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/lmzqm" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-概念"><span class="nav-number">1.</span> <span class="nav-text">RunLoop 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS中的RunLoop"><span class="nav-number">2.</span> <span class="nav-text">iOS中的RunLoop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runloop-的概念"><span class="nav-number">3.</span> <span class="nav-text">runloop 的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-和线程的关系"><span class="nav-number">4.</span> <span class="nav-text">RunLoop 和线程的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-对外接口"><span class="nav-number">5.</span> <span class="nav-text">RunLoop 对外接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-的Model"><span class="nav-number">6.</span> <span class="nav-text">RunLoop 的Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-的Source"><span class="nav-number">7.</span> <span class="nav-text">RunLoop 的Source</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-的内部逻辑"><span class="nav-number">8.</span> <span class="nav-text">RunLoop 的内部逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-休眠"><span class="nav-number">9.</span> <span class="nav-text">RunLoop 休眠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-提供的接口"><span class="nav-number">10.</span> <span class="nav-text">RunLoop 提供的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#属性"><span class="nav-number">10.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法"><span class="nav-number">10.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例的运用"><span class="nav-number">11.</span> <span class="nav-text">实例的运用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#APP-启动-RunLoop"><span class="nav-number">11.1.</span> <span class="nav-text">APP 启动 RunLoop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检测当前runloop的操作"><span class="nav-number">11.2.</span> <span class="nav-text">检测当前runloop的操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AutoRelease-原理"><span class="nav-number">11.3.</span> <span class="nav-text">AutoRelease 原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件响应"><span class="nav-number">11.4.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GCD和RunLoop的关系"><span class="nav-number">11.5.</span> <span class="nav-text">GCD和RunLoop的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存检测工具"><span class="nav-number">11.6.</span> <span class="nav-text">内存检测工具</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FPS-工具"><span class="nav-number">11.7.</span> <span class="nav-text">FPS 工具</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate"> 
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lmzqm</span>

  

  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div> 
 <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  

  
    <script id="dsq-count-scr" src="https://lmzqm.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/04/09/iOS-RunLoop-detail/';
        this.page.identifier = '2018/04/09/iOS-RunLoop-detail/';
        this.page.title = 'iOS RunLoop 深入理解';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://lmzqm.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  












  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
